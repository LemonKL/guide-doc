<header class="article-header">
<h1 class="article-title">线程池</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>在&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/thread-model.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 线程模型》</a>&nbsp;一文中，我们可以看到 Dubbo 提供了<strong>三种线程池的实现</strong>：</p>
<blockquote>
<p>ThreadPool</p>
<ul>
<li><code>fixed</code>&nbsp;固定大小线程池，启动时建立线程，不关闭，一直持有。(<strong>缺省</strong>)</li>
<li><code>cached</code>&nbsp;缓存线程池，空闲一分钟自动删除，需要时重建。</li>
<li><code>limited</code>&nbsp;可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。</li>
</ul>
</blockquote>
<p>在&nbsp;<a href="https://github.com/apache/incubator-dubbo/tree/master/dubbo-common" target="_blank" rel="external nofollow noopener noreferrer"><code>dubbo-common</code></a>&nbsp;模块的&nbsp;<code>threadpool</code>&nbsp;包下实现，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_03_05/01.png" alt="threadpool" /></p>
<h1 id="2-ThreadPool">2. ThreadPool</h1>
<p><a href="https://github.com/apache/incubator-dubbo/blob/bb8884e04433677d6abc6f05c6ad9d39e3dcf236/dubbo-common/src/main/java/com/alibaba/dubbo/common/threadpool/ThreadPool.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.common.threadpool.ThreadPool</code></a>&nbsp;，线程池接口。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"fixed"</span>)</span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Thread pool</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL contains thread parameter</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> thread pool</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="meta">@Adaptive</span>({Constants.THREADPOOL_KEY})</span><br /><span class="line">    <span class="function">Executor <span class="title">getExecutor</span><span class="params">(URL url)</span></span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>@SPI("fixed")</code>&nbsp;注解，Dubbo SPI&nbsp;<strong>拓展点</strong>，默认为&nbsp;<code>"fixed"</code>&nbsp;。</li>
<li><code>@Adaptive({Constants.THREADPOOL_KEY})</code>&nbsp;注解，基于 Dubbo SPI Adaptive 机制，加载对应的线程池实现，使用&nbsp;<code>URL.threadpool</code>&nbsp;属性。
<ul>
<li><code>#getExecutor(url)</code>&nbsp;方法，获得<strong>对应</strong>的线程池的执行器。</li>
</ul>
</li>
</ul>
<p>子类类图如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_03_05/02.png" alt="类图" /></p>
<h2 id="2-1-FixedThreadPool">2.1 FixedThreadPool</h2>
<p><code>com.alibaba.dubbo.common.threadpool.support.fixed.FixedThreadPool</code>&nbsp;，实现 ThreadPool 接口，固定大小线程池，启动时建立线程，不关闭，一直持有。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>{</span><br /><span class="line"> <span class="number">2</span>: </span><br /><span class="line"> <span class="number">3</span>:     <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line"> <span class="number">5</span>:         <span class="comment">// 线程名</span></span><br /><span class="line"> <span class="number">6</span>:         String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br /><span class="line"> <span class="number">7</span>:         <span class="comment">// 线程数</span></span><br /><span class="line"> <span class="number">8</span>:         <span class="keyword">int</span> threads = url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS);</span><br /><span class="line"> <span class="number">9</span>:         <span class="comment">// 队列数</span></span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">int</span> queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br /><span class="line"><span class="number">11</span>:         <span class="comment">// 创建执行器</span></span><br /><span class="line"><span class="number">12</span>:         <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(threads, threads, <span class="number">0</span>, TimeUnit.MILLISECONDS,</span><br /><span class="line"><span class="number">13</span>:                 queues == <span class="number">0</span> ? <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;() :</span><br /><span class="line"><span class="number">14</span>:                         (queues &lt; <span class="number">0</span> ? <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()</span><br /><span class="line"><span class="number">15</span>:                                 : <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(queues)),</span><br /><span class="line"><span class="number">16</span>:                 <span class="keyword">new</span> NamedThreadFactory(name, <span class="keyword">true</span>), <span class="keyword">new</span> AbortPolicyWithReport(name, url));</span><br /><span class="line"><span class="number">17</span>:     }</span><br /><span class="line"><span class="number">18</span>: </span><br /><span class="line"><span class="number">19</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>第 5 至 10 行：获得线程名、线程数、队列数。目前只有服务提供者使用，配置方式如下：</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>&gt;</span></span><br />    <br /><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"threadname"</span> <span class="attr">value</span>=<span class="string">"shuaiqi"</span> /&gt;</span></span><br /><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"threads"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br /><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"queues"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br /><br /><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<ul>
<li>第 11 至 16 行：创建执行器 ThreadPoolExecutor 对象。
<ul>
<li>根据不同的队列数，使用不同的队列实现：
<ul>
<li>第 13 行：&nbsp;<code>queues == 0</code>&nbsp;， SynchronousQueue 对象。</li>
<li>第 14 行：<code>queues &lt; 0</code>&nbsp;， LinkedBlockingQueue 对象。</li>
<li>第 15 行：<code>queues &gt; 0</code>&nbsp;，带队列数的 LinkedBlockingQueue 对象。</li>
</ul>
</li>
<li>推荐阅读：
<ul>
<li><a href="http://ifeve.com/java-synchronousqueue/" target="_blank" rel="external nofollow noopener noreferrer">《Java并发包中的同步队列SynchronousQueue实现原理》</a></li>
<li><a href="https://fangjian0423.github.io/2016/05/10/java-arrayblockingqueue-linkedblockingqueue-analysis/" target="_blank" rel="external nofollow noopener noreferrer">《Java阻塞队列ArrayBlockingQueue和LinkedBlockingQueue实现原理分析》</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-threadPool" target="_blank" rel="external nofollow noopener noreferrer">《聊聊并发（三）&mdash;&mdash;JAVA线程池的分析和使用》</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-blocking-queue" target="_blank" rel="external nofollow noopener noreferrer">《聊聊并发（七）&mdash;&mdash;Java中的阻塞队列》</a></li>
</ul>
</li>
<li>第 16 行：创建&nbsp;<a href="https://github.com/apache/incubator-dubbo/blob/bb8884e04433677d6abc6f05c6ad9d39e3dcf236/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/NamedThreadFactory.java" target="_blank" rel="external nofollow noopener noreferrer">NamedThreadFactory</a>&nbsp;对象，用于生成<strong>线程名</strong>。</li>
<li>第 16 行：创建 AbortPolicyWithReport 对象，用于<strong>当任务添加到线程池中被拒绝时</strong>。</li>
</ul>
</li>
</ul>
<h2 id="2-2-CachedThreadPool">2.2 CachedThreadPool</h2>
<p><code>com.alibaba.dubbo.common.threadpool.support.cached.CachedThreadPool</code>&nbsp;，实现 ThreadPool 接口，缓存线程池，空闲一定时长，自动删除，需要时重建。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>{</span><br /><span class="line"> <span class="number">2</span>: </span><br /><span class="line"> <span class="number">3</span>:     <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line"> <span class="number">5</span>:         <span class="comment">// 线程池名</span></span><br /><span class="line"> <span class="number">6</span>:         String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br /><span class="line"> <span class="number">7</span>:         <span class="comment">// 核心线程数</span></span><br /><span class="line"> <span class="number">8</span>:         <span class="keyword">int</span> cores = url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS);</span><br /><span class="line"> <span class="number">9</span>:         <span class="comment">// 最大线程数</span></span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">int</span> threads = url.getParameter(Constants.THREADS_KEY, Integer.MAX_VALUE);</span><br /><span class="line"><span class="number">11</span>:         <span class="comment">// 队列数</span></span><br /><span class="line"><span class="number">12</span>:         <span class="keyword">int</span> queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br /><span class="line"><span class="number">13</span>:         <span class="comment">// 线程存活时长</span></span><br /><span class="line"><span class="number">14</span>:         <span class="keyword">int</span> alive = url.getParameter(Constants.ALIVE_KEY, Constants.DEFAULT_ALIVE);</span><br /><span class="line"><span class="number">15</span>:         <span class="comment">// 创建执行器</span></span><br /><span class="line"><span class="number">16</span>:         <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(cores, threads, alive, TimeUnit.MILLISECONDS,</span><br /><span class="line"><span class="number">17</span>:                 queues == <span class="number">0</span> ? <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;() :</span><br /><span class="line"><span class="number">18</span>:                         (queues &lt; <span class="number">0</span> ? <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()</span><br /><span class="line"><span class="number">19</span>:                                 : <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(queues)),</span><br /><span class="line"><span class="number">20</span>:                 <span class="keyword">new</span> NamedThreadFactory(name, <span class="keyword">true</span>), <span class="keyword">new</span> AbortPolicyWithReport(name, url));</span><br /><span class="line"><span class="number">21</span>:     }</span><br /><span class="line"><span class="number">22</span>: </span><br /><span class="line"><span class="number">23</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 5 至 14 行：获得线程名、核心线程数、最大线程数、队列数、线程存活时长。
<ul>
<li>🙂 配置方式和 FixedThreadPool 类似，使用&nbsp;<code>&lt;dubbo:parameter /&gt;</code>&nbsp;配置。</li>
</ul>
</li>
<li>第 16 至 20 行：创建执行器 ThreadPoolExecutor 对象。
<ul>
<li>🙂 和 FixedThreadPool 相对类似。</li>
</ul>
</li>
</ul>
<h2 id="2-3-LimitedThreadPool">2.3 LimitedThreadPool</h2>
<p><code>com.alibaba.dubbo.common.threadpool.support.limited.LimitedThreadPool</code>&nbsp;，实现 ThreadPool 接口，可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedThreadPool</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>{</span><br /><span class="line"> <span class="number">2</span>: </span><br /><span class="line"> <span class="number">3</span>:     <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line"> <span class="number">5</span>:         <span class="comment">// 线程名</span></span><br /><span class="line"> <span class="number">6</span>:         String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br /><span class="line"> <span class="number">7</span>:         <span class="comment">// 核心线程数</span></span><br /><span class="line"> <span class="number">8</span>:         <span class="keyword">int</span> cores = url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS);</span><br /><span class="line"> <span class="number">9</span>:         <span class="comment">// 最大线程数</span></span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">int</span> threads = url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS);</span><br /><span class="line"><span class="number">11</span>:         <span class="comment">// 队列数</span></span><br /><span class="line"><span class="number">12</span>:         <span class="keyword">int</span> queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br /><span class="line"><span class="number">13</span>:         <span class="comment">// 创建执行器</span></span><br /><span class="line"><span class="number">14</span>:         <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(cores, threads, Long.MAX_VALUE, TimeUnit.MILLISECONDS,</span><br /><span class="line"><span class="number">15</span>:                 queues == <span class="number">0</span> ? <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;() :</span><br /><span class="line"><span class="number">16</span>:                         (queues &lt; <span class="number">0</span> ? <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()</span><br /><span class="line"><span class="number">17</span>:                                 : <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(queues)),</span><br /><span class="line"><span class="number">18</span>:                 <span class="keyword">new</span> NamedThreadFactory(name, <span class="keyword">true</span>), <span class="keyword">new</span> AbortPolicyWithReport(name, url));</span><br /><span class="line"><span class="number">19</span>:     }</span><br /><span class="line"><span class="number">20</span>: </span><br /><span class="line"><span class="number">21</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>和 CachedThreadPool 实现是基本一致的，差异点在&nbsp;<code>alive == Integer.MAX_VALUE</code>&nbsp;，<strong>空闲时间无限大</strong>，即不会自动删除。</li>
</ul>
<h1 id="3-AbortPolicyWithReport">3. AbortPolicyWithReport</h1>
<p><code>com.alibaba.dubbo.common.threadpool.support.AbortPolicyWithReport</code>&nbsp;，实现&nbsp;<code>java.util.concurrent.ThreadPoolExecutor.AbortPolicy</code>&nbsp;，拒绝策略实现类。<strong>打印 JStack ，分析线程状态</strong>。</p>
<h2 id="3-1-属性">3.1 属性</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 线程名</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String threadName;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * URL 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 最后打印时间</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastPrintTime = <span class="number">0</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 信号量，大小为 1 。</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Semaphore guard = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbortPolicyWithReport</span><span class="params">(String threadName, URL url)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>.threadName = threadName;</span><br /><span class="line">    <span class="keyword">this</span>.url = url;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="3-2-rejectedExecution">3.2 rejectedExecution</h2>
<p><code>#rejectedExecution(Runnable, ThreadPoolExecutor)</code>&nbsp;<strong>实现</strong>方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 打印告警日志</span></span><br /><span class="line"> <span class="number">4</span>:     String msg = String.format(<span class="string">"Thread pool is EXHAUSTED!"</span> +</span><br /><span class="line"> <span class="number">5</span>:                     <span class="string">" Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: %d),"</span> +</span><br /><span class="line"> <span class="number">6</span>:                     <span class="string">" Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!"</span>,</span><br /><span class="line"> <span class="number">7</span>:             threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(), e.getLargestPoolSize(),</span><br /><span class="line"> <span class="number">8</span>:             e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),</span><br /><span class="line"> <span class="number">9</span>:             url.getProtocol(), url.getIp(), url.getPort());</span><br /><span class="line"><span class="number">10</span>:     logger.warn(msg);</span><br /><span class="line"><span class="number">11</span>:     <span class="comment">// 打印 JStack ，分析线程状态。</span></span><br /><span class="line"><span class="number">12</span>:     dumpJStack();</span><br /><span class="line"><span class="number">13</span>:     <span class="comment">// 抛出 RejectedExecutionException 异常</span></span><br /><span class="line"><span class="number">14</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(msg);</span><br /><span class="line"><span class="number">15</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 至 10 行：打印<strong>告警日志</strong>。</li>
<li>第 12 行：调用&nbsp;<code>#dumpJStack()</code>&nbsp;方法，打印&nbsp;<strong>JStack</strong>&nbsp;，分析线程状态。</li>
<li>第 14 行：抛出 RejectedExecutionException 异常。</li>
</ul>
<h2 id="3-3-dumpJStack">3.3 dumpJStack</h2>
<p><code>#dumpJStack()</code>&nbsp;方法，打印 JStack。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpJStack</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="keyword">long</span> now = System.currentTimeMillis();</span><br /><span class="line"> <span class="number">3</span>: </span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">// 每 10 分钟，打印一次。</span></span><br /><span class="line"> <span class="number">5</span>:     <span class="comment">// dump every 10 minutes</span></span><br /><span class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (now - lastPrintTime &lt; <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>) {</span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">return</span>;</span><br /><span class="line"> <span class="number">8</span>:     }</span><br /><span class="line"> <span class="number">9</span>: </span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// 获得信号量</span></span><br /><span class="line"><span class="number">11</span>:     <span class="keyword">if</span> (!guard.tryAcquire()) {</span><br /><span class="line"><span class="number">12</span>:         <span class="keyword">return</span>;</span><br /><span class="line"><span class="number">13</span>:     }</span><br /><span class="line"><span class="number">14</span>: </span><br /><span class="line"><span class="number">15</span>:     <span class="comment">// 创建线程池，后台执行打印 JStack</span></span><br /><span class="line"><span class="number">16</span>:     Executors.newSingleThreadExecutor().execute(<span class="keyword">new</span> Runnable() {</span><br /><span class="line"><span class="number">17</span>:         <span class="meta">@Override</span></span><br /><span class="line"><span class="number">18</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br /><span class="line"><span class="number">19</span>: </span><br /><span class="line"><span class="number">20</span>:             <span class="comment">// 获得系统</span></span><br /><span class="line"><span class="number">21</span>:             String OS = System.getProperty(<span class="string">"os.name"</span>).toLowerCase();</span><br /><span class="line"><span class="number">22</span>:             <span class="comment">// 获得路径</span></span><br /><span class="line"><span class="number">23</span>:             String dumpPath = url.getParameter(Constants.DUMP_DIRECTORY, System.getProperty(<span class="string">"user.home"</span>));</span><br /><span class="line"><span class="number">24</span>:             SimpleDateFormat sdf;</span><br /><span class="line"><span class="number">25</span>:             <span class="comment">// window system don't support ":" in file name</span></span><br /><span class="line"><span class="number">26</span>:             <span class="keyword">if</span>(OS.contains(<span class="string">"win"</span>)){</span><br /><span class="line"><span class="number">27</span>:                 sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd_HH-mm-ss"</span>);</span><br /><span class="line"><span class="number">28</span>:             }<span class="keyword">else</span> {</span><br /><span class="line"><span class="number">29</span>:                 sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd_HH:mm:ss"</span>);</span><br /><span class="line"><span class="number">30</span>:             }</span><br /><span class="line"><span class="number">31</span>:             String dateStr = sdf.format(<span class="keyword">new</span> Date());</span><br /><span class="line"><span class="number">32</span>:             <span class="comment">// 获得输出流</span></span><br /><span class="line"><span class="number">33</span>:             FileOutputStream jstackStream = <span class="keyword">null</span>;</span><br /><span class="line"><span class="number">34</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">35</span>:                 jstackStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(dumpPath, <span class="string">"Dubbo_JStack.log"</span> + <span class="string">"."</span> + dateStr));</span><br /><span class="line"><span class="number">36</span>:                 <span class="comment">// 打印 JStack</span></span><br /><span class="line"><span class="number">37</span>:                 JVMUtil.jstack(jstackStream);</span><br /><span class="line"><span class="number">38</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">39</span>:                 logger.error(<span class="string">"dump jstack error"</span>, t);</span><br /><span class="line"><span class="number">40</span>:             } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">41</span>:                 <span class="comment">// 释放信号量</span></span><br /><span class="line"><span class="number">42</span>:                 guard.release();</span><br /><span class="line"><span class="number">43</span>:                 <span class="comment">// 释放输出流</span></span><br /><span class="line"><span class="number">44</span>:                 <span class="keyword">if</span> (jstackStream != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">45</span>:                     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">46</span>:                         jstackStream.flush();</span><br /><span class="line"><span class="number">47</span>:                         jstackStream.close();</span><br /><span class="line"><span class="number">48</span>:                     } <span class="keyword">catch</span> (IOException e) {</span><br /><span class="line"><span class="number">49</span>:                     }</span><br /><span class="line"><span class="number">50</span>:                 }</span><br /><span class="line"><span class="number">51</span>:             }</span><br /><span class="line"><span class="number">52</span>:             <span class="comment">// 记录最后打印时间</span></span><br /><span class="line"><span class="number">53</span>:             lastPrintTime = System.currentTimeMillis();</span><br /><span class="line"><span class="number">54</span>:         }</span><br /><span class="line"><span class="number">55</span>:     });</span><br /><span class="line"><span class="number">56</span>: </span><br /><span class="line"><span class="number">57</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 2 至 8 行：每 10 分钟，<strong>只</strong>打印一次。</li>
<li>第 10 至 13 行：获得信号量。保证，同一时间，<strong>有且仅有</strong>一个线程执行打印。</li>
<li>第 15 至 54 行：创建线程池，<strong>后台</strong>执行打印 JStack 。
<ul>
<li>第 20 至 31 行：获得路径。</li>
<li>第 32 至 35 行：获得文件输出流。</li>
<li>第 37 行：调用&nbsp;<code>JVMUtil#jstack(OutputStream)</code>&nbsp;方法，打印 JStack 。</li>
<li>第 42 行：释放信号量。</li>
<li>第 44 至 50 行：释放输出流。</li>
<li>第 53 行：记录最后打印时间。</li>
</ul>
</li>
</ul>
<h1 id="4-JVMUtil">4. JVMUtil</h1>
<p><a href="https://github.com/apache/incubator-dubbo/blob/bb8884e04433677d6abc6f05c6ad9d39e3dcf236/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/JVMUtil.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.common.utils.JVMUtil</code></a>&nbsp;，JVM 工具类。目前，仅有 JStack 功能，胖友可以点击链接，自己查看下代码。</p>
<p>如下是一个 JStack 日志的示例：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="number">123312</span>:tmp yunai$ cat Dubbo_JStack.log.2018-<span class="number">03</span>-<span class="number">27_18</span>\:<span class="number">57</span>\:<span class="number">32</span></span><br /><span class="line"><span class="string">"pool-2-thread-1"</span> Id=<span class="number">11</span> RUNNABLE</span><br /><span class="line">	at sun.management.ThreadImpl.dumpThreads0(Native Method)</span><br /><span class="line">	at sun.management.ThreadImpl.dumpAllThreads(ThreadImpl.java:<span class="number">454</span>)</span><br /><span class="line">	at com.alibaba.dubbo.common.utils.JVMUtil.jstack(JVMUtil.java:<span class="number">34</span>)</span><br /><span class="line">	at com.alibaba.dubbo.common.threadpool.support.AbortPolicyWithReport$<span class="number">1</span>.run(AbortPolicyWithReport.java:<span class="number">122</span>)</span><br /><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</span><br /><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br /><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br /><br /><span class="line">	Number of locked synchronizers = <span class="number">1</span></span><br /><span class="line">	- java.util.concurrent.ThreadPoolExecutor$Worker@<span class="number">5</span>cbc508c</span><br /><br /><span class="line"><span class="string">"Monitor Ctrl-Break"</span> Id=<span class="number">5</span> RUNNABLE (in <span class="keyword">native</span>)</span><br /><span class="line">	at java.net.SocketInputStream.socketRead0(Native Method)</span><br /><span class="line">	at java.net.SocketInputStream.socketRead(SocketInputStream.java:<span class="number">116</span>)</span><br /><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">171</span>)</span><br /><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">141</span>)</span><br /><span class="line">	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:<span class="number">284</span>)</span><br /><span class="line">	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:<span class="number">326</span>)</span><br /><span class="line">	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:<span class="number">178</span>)</span><br /><span class="line">	-  locked java.io.InputStreamReader@<span class="number">5</span>c7efb52</span><br /><span class="line">	at java.io.InputStreamReader.read(InputStreamReader.java:<span class="number">184</span>)</span><br /><span class="line">	at java.io.BufferedReader.fill(BufferedReader.java:<span class="number">161</span>)</span><br /><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:<span class="number">324</span>)</span><br /><span class="line">	-  locked java.io.InputStreamReader@<span class="number">5</span>c7efb52</span><br /><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:<span class="number">389</span>)</span><br /><span class="line">	at com.intellij.rt.execution.application.AppMainV2$<span class="number">1</span>.run(AppMainV2.java:<span class="number">64</span>)</span><br /><br /><span class="line"><span class="string">"Signal Dispatcher"</span> Id=<span class="number">4</span> RUNNABLE</span><br /><br /><span class="line"><span class="string">"Finalizer"</span> Id=<span class="number">3</span> WAITING on java.lang.ref.ReferenceQueue$Lock@<span class="number">197</span>c6eb9</span><br /><span class="line">	at java.lang.Object.wait(Native Method)</span><br /><span class="line">	-  waiting on java.lang.ref.ReferenceQueue$Lock@<span class="number">197</span>c6eb9</span><br /><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">143</span>)</span><br /><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">164</span>)</span><br /><span class="line">	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class="number">209</span>)</span><br /><br /><span class="line"><span class="string">"Reference Handler"</span> Id=<span class="number">2</span> WAITING on java.lang.ref.Reference$Lock@<span class="number">7</span>b19fa34</span><br /><span class="line">	at java.lang.Object.wait(Native Method)</span><br /><span class="line">	-  waiting on java.lang.ref.Reference$Lock@<span class="number">7</span>b19fa34</span><br /><span class="line">	at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br /><span class="line">	at java.lang.ref.Reference.tryHandlePending(Reference.java:<span class="number">191</span>)</span><br /><span class="line">	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">153</span>)</span><br /><br /><span class="line"><span class="string">"main"</span> Id=<span class="number">1</span> TIMED_WAITING</span><br /><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br /><span class="line">	at com.alibaba.dubbo.common.threadpool.AbortPolicyWithReportTest.jStackDumpTest(AbortPolicyWithReportTest.java:<span class="number">44</span>)</span><br /><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br /><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br /><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br /><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br /><span class="line">	at org.junit.runners.model.FrameworkMethod$<span class="number">1</span>.runReflectiveCall(FrameworkMethod.java:<span class="number">50</span>)</span><br /><span class="line">	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:<span class="number">12</span>)</span><br /><span class="line">	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:<span class="number">47</span>)</span><br /><span class="line">	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:<span class="number">17</span>)</span><br /><span class="line">	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:<span class="number">325</span>)</span><br /><span class="line">	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:<span class="number">78</span>)</span><br /><span class="line">	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:<span class="number">57</span>)</span><br /><span class="line">	at org.junit.runners.ParentRunner$<span class="number">3</span>.run(ParentRunner.java:<span class="number">290</span>)</span><br /><span class="line">	at org.junit.runners.ParentRunner$<span class="number">1</span>.schedule(ParentRunner.java:<span class="number">71</span>)</span><br /><span class="line">	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:<span class="number">288</span>)</span><br /><span class="line">	at org.junit.runners.ParentRunner.access$<span class="number">000</span>(ParentRunner.java:<span class="number">58</span>)</span><br /><span class="line">	at org.junit.runners.ParentRunner$<span class="number">2</span>.evaluate(ParentRunner.java:<span class="number">268</span>)</span><br /><span class="line">	at org.junit.runners.ParentRunner.run(ParentRunner.java:<span class="number">363</span>)</span><br /><span class="line">	at org.junit.runner.JUnitCore.run(JUnitCore.java:<span class="number">137</span>)</span><br /><span class="line">	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:<span class="number">68</span>)</span><br /><span class="line">	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:<span class="number">47</span>)</span><br /><span class="line">	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:<span class="number">242</span>)</span><br /><span class="line">	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:<span class="number">70</span>)</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p>另外，胖友可以看看&nbsp;<a href="https://www.jianshu.com/p/6690f7e92f27" target="_blank" rel="external nofollow noopener noreferrer">《如何使用jstack分析线程状态》</a>&nbsp;文章。</p>
</div>