<header class="article-header">
<h1 class="article-title">服务暴露（一）之本地暴露（Injvm）</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>Dubbo 服务暴露有两种方式</p>
<ul>
<li>
<p>本地暴露，JVM 本地调用。配置如下：</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"local"</span> /&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>远程暴露，网络远程通信。配置如下：</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"remote"</span> /&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>【可以不算】不暴露，配置如下：</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"none"</span> /&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<p>在不配置&nbsp;<code>scope</code>&nbsp;的情况下，<strong>默认两种方式都暴露</strong>。因为，Dubbo 自身无法确认应用中，是否存在<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-call.html" target="_blank" rel="external nofollow noopener noreferrer">本地引用</a>的情况。<br />大多数情况下，我们不需要配置&nbsp;<code>scope</code>&nbsp;。如果胖友可以明确服务器消费引用服务的方式，也可以进行设置。</p>
<p>我们知道 Dubbo 提供了多种协议( Protocol )实现。</p>
<ul>
<li><strong>本文</strong>仅分享本地暴露，该方式仅使用 Injvm 协议实现，具体代码在&nbsp;<code>dubbo-rpc-injvm</code>&nbsp;模块中。</li>
<li><strong>下几篇</strong>会分享远程暴露，该方式有多种协议实现，例如 Dubbo ( 默认协议 )、Hessian 、Rest 等等。我们会每个协议对应一篇文章，进行分享。</li>
</ul>
<h1 id="2-doExportUrls">2. doExportUrls</h1>
<p>本地暴露服务的顺序图如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_03_07/03.png" alt="本地暴露顺序图" /></p>
<p>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-api-2/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; API 配置（二）之服务提供者》</a>&nbsp;一文中，我们看到&nbsp;<code>ServiceConfig#export()</code>&nbsp;方法中，会在配置初始化完成后，调用顺序图的<strong>起点</strong>&nbsp;<code>#doExportUrls()</code>&nbsp;方法，开始暴露服务。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 注册中心配置数组</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">protected</span> List&lt;ProtocolConfig&gt; protocols;</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  2:  * 暴露 Dubbo URL</span></span><br /><span class="line"><span class="comment">  3:  */</span></span><br /><span class="line">  <span class="number">4</span>: <span class="meta">@SuppressWarnings</span>({<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>})</span><br /><span class="line">  <span class="number">5</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>{</span><br /><span class="line">  <span class="number">6</span>:     <span class="comment">// 加载注册中心 URL 数组</span></span><br /><span class="line">  <span class="number">7</span>:     List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br /><span class="line">  <span class="number">8</span>:     <span class="comment">// 循环 `protocols` ，向逐个注册中心分组暴露服务。</span></span><br /><span class="line">  <span class="number">9</span>:     <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) {</span><br /><span class="line"> <span class="number">10</span>:         doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br /><span class="line"> <span class="number">11</span>:     }</span><br /><span class="line"> <span class="number">12</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 7 行：调用&nbsp;<code>#loadRegistries(provider)</code>&nbsp;方法，加载注册中心的 com.alibaba.dubbo.common.URL` 数组。
<ul>
<li>🙂 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/">「2.1 loadRegistries」</a>&nbsp;详细解析。</li>
</ul>
</li>
<li>第 8 至 11 行：循环&nbsp;<code>protocols</code>&nbsp;，调用&nbsp;<code>#doExportUrlsFor1Protocol(protocolConfig, registryURLs)</code>&nbsp;方法，使用<strong>对应的协议</strong>，逐个向<strong>注册中心分组</strong>暴露服务。在这个方法中，包含了本地和远程两种暴露方式。在下文中，我们会看到，本地暴露不会向注册中心注册服务，<strong>因为仅仅用于 JVM 内部本地调用，内存中已经有相关信息</strong>。
<ul>
<li>🙂 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/">「2.2 doExportUrlsFor1Protocol」</a>&nbsp;详细解析。</li>
</ul>
</li>
</ul>
<h2 id="2-1-loadRegistries">2.1 loadRegistries</h2>
<blockquote>
<p>友情提示，实际这个方法，放在服务的<strong>远程暴露</strong>一文分享较为合适。<br />因为，<strong>本地暴露</strong>无需向注册中心注册。<br />所以，该方法也可以放到<strong>远程暴露</strong>一文在看。</p>
</blockquote>
<p><code>#loadRegistries(provider)</code>&nbsp;方法，加载注册中心&nbsp;<code>com.alibaba.dubbo.common.URL</code>&nbsp;数组。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 加载注册中心 URL 数组</span></span><br /><span class="line"><span class="comment"> 3:  *</span></span><br /><span class="line"><span class="comment"> 4:  * <span class="doctag">@param</span> provider 是否是服务提供者</span></span><br /><span class="line"><span class="comment"> 5:  * <span class="doctag">@return</span> URL 数组</span></span><br /><span class="line"><span class="comment"> 6:  */</span></span><br /><span class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">protected</span> List&lt;URL&gt; <span class="title">loadRegistries</span><span class="params">(<span class="keyword">boolean</span> provider)</span> </span>{</span><br /><span class="line"> <span class="number">8</span>:     <span class="comment">// 校验 RegistryConfig 配置数组。</span></span><br /><span class="line"> <span class="number">9</span>:     checkRegistry();</span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// 创建 注册中心 URL 数组</span></span><br /><span class="line"><span class="number">11</span>:     List&lt;URL&gt; registryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br /><span class="line"><span class="number">12</span>:     <span class="keyword">if</span> (registries != <span class="keyword">null</span> &amp;&amp; !registries.isEmpty()) {</span><br /><span class="line"><span class="number">13</span>:         <span class="keyword">for</span> (RegistryConfig config : registries) {</span><br /><span class="line"><span class="number">14</span>:             <span class="comment">// 获得注册中心的地址</span></span><br /><span class="line"><span class="number">15</span>:             String address = config.getAddress();</span><br /><span class="line"><span class="number">16</span>:             <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) {</span><br /><span class="line"><span class="number">17</span>:                 address = Constants.ANYHOST_VALUE;</span><br /><span class="line"><span class="number">18</span>:             }</span><br /><span class="line"><span class="number">19</span>:             String sysaddress = System.getProperty(<span class="string">"dubbo.registry.address"</span>); <span class="comment">// 从启动参数读取</span></span><br /><span class="line"><span class="number">20</span>:             <span class="keyword">if</span> (sysaddress != <span class="keyword">null</span> &amp;&amp; sysaddress.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">21</span>:                 address = sysaddress;</span><br /><span class="line"><span class="number">22</span>:             }</span><br /><span class="line"><span class="number">23</span>:             <span class="comment">// 有效的地址</span></span><br /><span class="line"><span class="number">24</span>:             <span class="keyword">if</span> (address.length() &gt; <span class="number">0</span></span><br /><span class="line"><span class="number">25</span>:                     &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {</span><br /><span class="line"><span class="number">26</span>:                 Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br /><span class="line"><span class="number">27</span>:                 <span class="comment">// 将各种配置对象，添加到 `map` 集合中。</span></span><br /><span class="line"><span class="number">28</span>:                 appendParameters(map, application);</span><br /><span class="line"><span class="number">29</span>:                 appendParameters(map, config);</span><br /><span class="line"><span class="number">30</span>:                 <span class="comment">// 添加 `path` `dubbo` `timestamp` `pid` 到 `map` 集合中。</span></span><br /><span class="line"><span class="number">31</span>:                 map.put(<span class="string">"path"</span>, RegistryService.class.getName());</span><br /><span class="line"><span class="number">32</span>:                 map.put(<span class="string">"dubbo"</span>, Version.getVersion());</span><br /><span class="line"><span class="number">33</span>:                 map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br /><span class="line"><span class="number">34</span>:                 <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">35</span>:                     map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br /><span class="line"><span class="number">36</span>:                 }</span><br /><span class="line"><span class="number">37</span>:                 <span class="comment">// 若不存在 `protocol` 参数，默认 "dubbo" 添加到 `map` 集合中。</span></span><br /><span class="line"><span class="number">38</span>:                 <span class="keyword">if</span> (!map.containsKey(<span class="string">"protocol"</span>)) {</span><br /><span class="line"><span class="number">39</span>:                     <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(<span class="string">"remote"</span>)) { <span class="comment">// "remote"</span></span><br /><span class="line"><span class="number">40</span>:                         map.put(<span class="string">"protocol"</span>, <span class="string">"remote"</span>);</span><br /><span class="line"><span class="number">41</span>:                     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">42</span>:                         map.put(<span class="string">"protocol"</span>, <span class="string">"dubbo"</span>);</span><br /><span class="line"><span class="number">43</span>:                     }</span><br /><span class="line"><span class="number">44</span>:                 }</span><br /><span class="line"><span class="number">45</span>:                 <span class="comment">// 解析地址，创建 Dubbo URL 数组。（数组大小可以为一）</span></span><br /><span class="line"><span class="number">46</span>:                 List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span><br /><span class="line"><span class="number">47</span>:                 <span class="comment">// 循环 `url` ，设置 "registry" 和 "protocol" 属性。</span></span><br /><span class="line"><span class="number">48</span>:                 <span class="keyword">for</span> (URL url : urls) {</span><br /><span class="line"><span class="number">49</span>:                     <span class="comment">// 设置 `registry=${protocol}` 和 `protocol=registry` 到 URL</span></span><br /><span class="line"><span class="number">50</span>:                     url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());</span><br /><span class="line"><span class="number">51</span>:                     url = url.setProtocol(Constants.REGISTRY_PROTOCOL);</span><br /><span class="line"><span class="number">52</span>:                     <span class="comment">// 添加到结果</span></span><br /><span class="line"><span class="number">53</span>:                     <span class="keyword">if</span> ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) <span class="comment">// 服务提供者 &amp;&amp; 注册</span></span><br /><span class="line"><span class="number">54</span>:                             || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, <span class="keyword">true</span>))) { <span class="comment">// 服务消费者 &amp;&amp; 订阅</span></span><br /><span class="line"><span class="number">55</span>:                         registryList.add(url);</span><br /><span class="line"><span class="number">56</span>:                     }</span><br /><span class="line"><span class="number">57</span>:                 }</span><br /><span class="line"><span class="number">58</span>:             }</span><br /><span class="line"><span class="number">59</span>:         }</span><br /><span class="line"><span class="number">60</span>:     }</span><br /><span class="line"><span class="number">61</span>:     <span class="keyword">return</span> registryList;</span><br /><span class="line"><span class="number">62</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 9 行：调用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/9d38b6f9f95798755141d6140e311e8fd51fecc1/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/AbstractInterfaceConfig.java#L122-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>#checkRegistry()</code></a>&nbsp;方法，校验 RegistryConfig 配置。
<ul>
<li>🙂 直接点击方法查看，较为简单，已经添加详细注释。</li>
</ul>
</li>
<li>第 11 行：<strong>创建</strong>注册中心 URL 数组。</li>
<li>第 13 行：<strong>循环</strong>注册中心配置对象数组&nbsp;<code>registries</code>&nbsp;。</li>
<li>第 14 至 22 行：获得注册中心的地址&nbsp;<code>address</code>&nbsp;。
<ul>
<li>第 19 至 22 行：从启动参数&nbsp;<code>dubbo.registry.address</code>&nbsp;读取，若存在，<strong>最高优先级</strong>，进行覆盖。</li>
</ul>
</li>
<li>第 24 至 25 行：地址&nbsp;<code>address</code>&nbsp;是有效地址，包括&nbsp;<code>address != N/A</code>&nbsp;。
<ul>
<li><code>"N/A"</code>&nbsp;代表不配置注册中心。</li>
</ul>
</li>
<li>第 26 行：创建参数集合&nbsp;<code>map</code>&nbsp;。</li>
<li>第 28 至 29 行：调用&nbsp;<code>#appendParameters(map, config)</code>&nbsp;方法，将各种配置对象，添加到&nbsp;<code>map</code>&nbsp;集合中。
<ul>
<li>🙂 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-api-1/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; API 配置（一）之应用》「3.1 AbstractConfig」</a>&nbsp;已经详细解析。</li>
<li><a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/RegistryConfig.java#L121-L124" target="_blank" rel="external nofollow noopener noreferrer"><code>RegistryConfig#getAddress()</code></a>&nbsp;上有&nbsp;<code>@Parameter(excluded = true)</code>&nbsp;，因此&nbsp;<code>Registry.address</code>属性不会添加到&nbsp;<code>map</code>&nbsp;中。</li>
</ul>
</li>
<li>第 30 至 36 行：添加&nbsp;<code>path</code>&nbsp;<code>dubbo</code>&nbsp;<code>timestamp</code>&nbsp;<code>pid</code>&nbsp;到&nbsp;<code>map</code>&nbsp;集合中。</li>
<li>第 37 至 44 行：若不存在&nbsp;<code>protocol</code>&nbsp;参数，缺省默认为 &ldquo;dubbo&rdquo; ，并添加到&nbsp;<code>map</code>&nbsp;集合中。
<ul>
<li>第 39 至 40 行：<strong>可以忽略</strong>。因为，<code>remote</code>&nbsp;这个拓展实现已经不存在。</li>
</ul>
</li>
<li>第 46 行：调用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/UrlUtils.java#L147-L174" target="_blank" rel="external nofollow noopener noreferrer"><code>UrlUtils#parseURLs(address, map)</code></a>&nbsp;方法，解析&nbsp;<code>address</code>&nbsp;，创建 Dubbo URL 数组（数组大小可以为一）。
<ul>
<li>🙂 已经添加了代码注释，胖友点击链接查看。</li>
<li><code>address</code>&nbsp;可以使用&nbsp;<code>"|"</code>&nbsp;或者&nbsp;<code>";"</code>&nbsp;作为分隔符，设置多个注册中心<strong>分组</strong>。<strong>注意</strong>，一个注册中心集群是一个分组，而不是多个。</li>
<li>这个方法从名字上很难看出具体的含义，看下图的<strong>注释</strong>，相信胖友能理解。<img src="http://static2.iocoder.cn/images/Dubbo/2018_03_07/01.png" alt="&#96;UrlUtils#parseURLs(address, map)&#96;" /></li>
</ul>
</li>
<li>第 47 至 57 行：循环&nbsp;<code>urls</code>&nbsp;，设置 &ldquo;registry&rdquo; 和 &ldquo;protocol&rdquo; 属性。
<ul>
<li>第 49 至 51 行：设置&nbsp;<code>registry=${protocol}</code>&nbsp;和&nbsp;<code>protocol=registry</code>&nbsp;到 URL 。</li>
<li>第 53 行：若是服务<strong>提供者</strong>，判断是否<strong>只订阅不注册</strong>。如果是，<strong>不添加</strong>结果到&nbsp;<code>registryList</code>&nbsp;中。对应&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/subscribe-only.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 只订阅》</a>&nbsp;文档。</li>
<li>第 54 行：若是服务<strong>消费者</strong>，判断是否<strong>只注册不订阅</strong>。如果是，<strong>不添加</strong>到结果&nbsp;<code>registryList</code>&nbsp;。对应&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/registry-only.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 只注册》</a>&nbsp;文档。</li>
<li>第 53 至 56 行：添加到结果&nbsp;<code>registryList</code>&nbsp;。</li>
</ul>
</li>
<li>为了胖友更加容易理解，我们举个例子。<img src="http://static2.iocoder.cn/images/Dubbo/2018_03_07/02.png" alt="数据流向" /></li>
</ul>
<h2 id="2-2-doExportUrlsFor1Protocol">2.2 doExportUrlsFor1Protocol</h2>
<p><code>#doExportUrlsFor1Protocol(protocolConfig, registryURLs)</code>&nbsp;方法，基于单个协议，暴露服务。<strong>简化</strong>代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 基于单个协议，暴露服务</span></span><br /><span class="line"><span class="comment"> 3:  *</span></span><br /><span class="line"><span class="comment"> 4:  * <span class="doctag">@param</span> protocolConfig 协议配置对象</span></span><br /><span class="line"><span class="comment"> 5:  * <span class="doctag">@param</span> registryURLs 注册中心链接对象数组</span></span><br /><span class="line"><span class="comment"> 6:  */</span></span><br /><span class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>{</span><br /><span class="line"> <span class="number">8</span>:     <span class="comment">// ... 【省略】 创建服务 URL 对象</span></span><br /><span class="line"> <span class="number">9</span>: </span><br /><span class="line"><span class="number">10</span>:     String scope = url.getParameter(Constants.SCOPE_KEY);</span><br /><span class="line"><span class="number">11</span>:     <span class="comment">// don't export when none is configured</span></span><br /><span class="line"><span class="number">12</span>:     <span class="keyword">if</span> (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {</span><br /><span class="line"><span class="number">13</span>: </span><br /><span class="line"><span class="number">14</span>:         <span class="comment">// export to local if the config is not remote (export to remote only when config is remote)</span></span><br /><span class="line"><span class="number">15</span>:         <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {</span><br /><span class="line"><span class="number">16</span>:             exportLocal(url);</span><br /><span class="line"><span class="number">17</span>:         }</span><br /><span class="line"><span class="number">18</span>:         <span class="comment">// export to remote if the config is not local (export to local only when config is local)</span></span><br /><span class="line"><span class="number">19</span>:         <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {</span><br /><span class="line"><span class="number">20</span>:             <span class="comment">// ... 【省略】远程暴露 </span></span><br /><span class="line"><span class="number">21</span>:         }</span><br /><span class="line"><span class="number">22</span>:     }</span><br /><span class="line"><span class="number">23</span>:     <span class="keyword">this</span>.urls.add(url);</span><br /><span class="line"><span class="number">24</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 8 行：【省略代码】创建服务 URL 对象。
<ul>
<li>🙂 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-api-2/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; API 配置（二）之服务提供者》「8. ServiceConfig」</a>&nbsp;有详细解析。</li>
</ul>
</li>
<li>第 15 至 17 行：当非&nbsp;<code>"remote"</code>&nbsp;时，调用&nbsp;<code>#exportLocal(url)</code>&nbsp;方法，本地暴露服务。
<ul>
<li>🙂 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/">「2.2.1 exportLocal」</a>&nbsp;详细解析。</li>
</ul>
</li>
<li>第 19 至 21 行：【省略代码】非&nbsp;<code>"local"</code>&nbsp;时，远程暴露服务。在下一篇文章，详细分享。</li>
</ul>
<h3 id="2-2-1-exportLocal">2.2.1 exportLocal</h3>
<p><code>#exportLocal(url)</code>&nbsp;方法，本地暴露服务。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 自适应 Protocol 实现对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 自适应 ProxyFactory 实现对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #interfaceName} 对应的接口类</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 非配置</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Service 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="comment">// reference to interface impl</span></span><br /><span class="line"><span class="keyword">private</span> T ref;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 服务配置暴露的 Exporter 。</span></span><br /><span class="line"><span class="comment"> * URL ：Exporter 不一定是 1：1 的关系。</span></span><br /><span class="line"><span class="comment"> * 例如 {<span class="doctag">@link</span> #scope} 未设置时，会暴露 Local + Remote 两个，也就是 URL ：Exporter = 1：2</span></span><br /><span class="line"><span class="comment"> *      {<span class="doctag">@link</span> #scope} 设置为空时，不会暴露，也就是 URL ：Exporter = 1：0</span></span><br /><span class="line"><span class="comment"> *      {<span class="doctag">@link</span> #scope} 设置为 Local 或 Remote 任一时，会暴露 Local 或 Remote 一个，也就是 URL ：Exporter = 1：1</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 非配置。</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;();</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  2:  * 本地暴露服务</span></span><br /><span class="line"><span class="comment">  3:  *</span></span><br /><span class="line"><span class="comment">  4:  * <span class="doctag">@param</span> url 注册中心 URL</span></span><br /><span class="line"><span class="comment">  5:  */</span></span><br /><span class="line">  <span class="number">6</span>: <span class="meta">@SuppressWarnings</span>({<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>})</span><br /><span class="line">  <span class="number">7</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">  <span class="number">8</span>:     <span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {</span><br /><span class="line">  <span class="number">9</span>:         <span class="comment">// 创建本地 Dubbo URL</span></span><br /><span class="line"> <span class="number">10</span>:         URL local = URL.valueOf(url.toFullString())</span><br /><span class="line"> <span class="number">11</span>:                 .setProtocol(Constants.LOCAL_PROTOCOL) <span class="comment">// injvm</span></span><br /><span class="line"> <span class="number">12</span>:                 .setHost(LOCALHOST) <span class="comment">// 本地</span></span><br /><span class="line"> <span class="number">13</span>:                 .setPort(<span class="number">0</span>); <span class="comment">// 端口=0</span></span><br /><span class="line"> <span class="number">14</span>:         <span class="comment">// 添加服务的真实类名，例如 DemoServiceImpl ，仅用于 RestProtocol 中。</span></span><br /><span class="line"> <span class="number">15</span>:         ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br /><span class="line"> <span class="number">16</span>:         <span class="comment">// 使用 ProxyFactory 创建 Invoker 对象</span></span><br /><span class="line"> <span class="number">17</span>:         <span class="comment">// 使用 Protocol 暴露 Invoker 对象</span></span><br /><span class="line"> <span class="number">18</span>:         Exporter&lt;?&gt; exporter = protocol.export(proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br /><span class="line"> <span class="number">19</span>:         <span class="comment">// 添加到 `exporters`</span></span><br /><span class="line"> <span class="number">20</span>:         exporters.add(exporter);</span><br /><span class="line"> <span class="number">21</span>:         logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to local registry"</span>);</span><br /><span class="line"> <span class="number">22</span>:     }</span><br /><span class="line"> <span class="number">23</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>protocol</code>&nbsp;<strong>静态</strong>属性，自适应 Protocol 实现对象。
<ul>
<li>不熟悉的胖友，请看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 拓展机制 SPI》</a>&nbsp;文章。</li>
</ul>
</li>
<li><code>proxyFactory</code>&nbsp;<strong>静态</strong>属性，自适应 ProxyFactory 实现对象。</li>
<li><code>interfaceClass</code>&nbsp;属性，Service 接口。</li>
<li><code>ref</code>&nbsp;属性，Service 对象。</li>
<li><code>exporters</code>&nbsp;属性，Exporter 集合。</li>
<li>========== 分割线 ==========</li>
<li>第 9 至 13 行：基于原有&nbsp;<code>url</code>&nbsp;，创建<strong>新的</strong>服务的本地 Dubbo URL 对象，并设置属性&nbsp;<code>protocol=injvm</code><code>host=127.0.0.1</code>&nbsp;<code>port=0</code>&nbsp;。因为&nbsp;<code>url</code>&nbsp;在后面远程暴露服务会使用，所以要新创建。</li>
<li>第 15 行：添加服务的真实类名，例如 DemoServiceImpl ，仅用于 RestProtocol 中。</li>
<li>第 18 行：调用&nbsp;<code>ProxyFactory#getInvoker(proxy, type, url)</code>&nbsp;方法，创建 Invoker 对象。该 Invoker 对象，执行&nbsp;<code>#invoke(invocation)</code>&nbsp;方法时，内部会调用 Service 对象(&nbsp;<code>ref</code>&nbsp;)对应的调用方法。
<ul>
<li>🙂 详细的实现，后面单独写文章分享。</li>
</ul>
</li>
<li>第 18 行：调用&nbsp;<code>Protocol#export(invoker)</code>&nbsp;方法，暴露服务。
<ul>
<li>此处 Dubbo SPI&nbsp;<strong>自适应</strong>的特性的<strong>好处</strong>就出来了，可以<strong>自动</strong>根据 URL 参数，获得对应的拓展实现。例如，<code>invoker</code>传入后，根据&nbsp;<code>invoker.url</code>&nbsp;自动获得对应 Protocol 拓展实现为 InjvmProtocol 。</li>
<li>实际上，Protocol 有两个 Wrapper 拓展实现类： ProtocolFilterWrapper、ProtocolListenerWrapper 。所以，<code>#export(...)</code>&nbsp;方法的调用顺序是：<strong>Protocol$Adaptive =&gt; ProtocolFilterWrapper =&gt; ProtocolListenerWrapper =&gt; InjvmProtocol</strong>&nbsp;。</li>
<li>🙂 详细的调用，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/">「3. Protocol」</a>&nbsp;在解析。</li>
</ul>
</li>
<li>第 20 行：添加到&nbsp;<code>exporters</code>&nbsp;集合中。</li>
</ul>
<h1 id="3-Protocol">3. Protocol</h1>
<p>Protocol&nbsp;<strong>接口</strong>，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/">《精尽 Dubbo 源码分析 &mdash;&mdash; 核心流程一览》「4.6 Protocol」</a>&nbsp;有详细解析。</p>
<p>本文涉及的 Protocol 类图如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_03_07/04.png" alt="Protocol 类图" /></p>
<h2 id="3-1-Protocol-Adaptive">3.1 Protocol$Adaptive</h2>
<p>代码类似下图，笔者偷懒，就不去重新生成啦。</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_03_04/05.png" alt="自适应拓展的代码实现的字符串生成例子" /></p>
<h2 id="3-2-ProtocolFilterWrapper">3.2 ProtocolFilterWrapper</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</code></a>&nbsp;，实现 Protocol 接口，Protocol 的 Wrapper 拓展实现类，用于给 Invoker 增加过滤链。</p>
<h3 id="3-2-1-export">3.2.1 export</h3>
<p>本文涉及的&nbsp;<code>#export(invoker)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"><span class="number">2</span>:     <span class="comment">// 注册中心</span></span><br /><span class="line"><span class="number">3</span>:     <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {</span><br /><span class="line"><span class="number">4</span>:         <span class="keyword">return</span> protocol.export(invoker);</span><br /><span class="line"><span class="number">5</span>:     }</span><br /><span class="line"><span class="number">6</span>:     <span class="comment">// 建立带有 Filter 过滤链的 Invoker ，再暴露服务。</span></span><br /><span class="line"><span class="number">7</span>:     <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br /><span class="line"><span class="number">8</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 2 至 5 行：当&nbsp;<code>invoker.url.protocl = registry</code>&nbsp;，跳过，本地暴露服务不会符合这个判断。在远程暴露服务会符合暴露该判断，所以下一篇文章分享。</li>
<li>第 7 行：调用&nbsp;<code>#buildInvokerChain(invoker, key, group)</code>&nbsp;方法，创建带有 Filter 过滤链的 Invoker 对象。
<ul>
<li>🙂 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/">「3.2.2 buildInvokerChain」</a>&nbsp;详细解析。</li>
</ul>
</li>
<li>第 7 行：调用&nbsp;<code>protocol#export(invoker)</code>&nbsp;方法，继续暴露服务。</li>
</ul>
<h3 id="3-2-2-buildInvokerChain">3.2.2 buildInvokerChain</h3>
<p><code>#buildInvokerChain(invoker, key, group)</code>&nbsp;方法，创建带 Filter 链的 Invoker 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 创建带 Filter 链的 Invoker 对象</span></span><br /><span class="line"><span class="comment"> 3:  *</span></span><br /><span class="line"><span class="comment"> 4:  * <span class="doctag">@param</span> invoker Invoker 对象</span></span><br /><span class="line"><span class="comment"> 5:  * <span class="doctag">@param</span> key 获取 URL 参数名</span></span><br /><span class="line"><span class="comment"> 6:  * <span class="doctag">@param</span> group 分组</span></span><br /><span class="line"><span class="comment"> 7:  * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br /><span class="line"><span class="comment"> 8:  * <span class="doctag">@return</span> Invoker 对象</span></span><br /><span class="line"><span class="comment"> 9:  */</span></span><br /><span class="line"><span class="number">10</span>: <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>{</span><br /><span class="line"><span class="number">11</span>:     Invoker&lt;T&gt; last = invoker;</span><br /><span class="line"><span class="number">12</span>:     <span class="comment">// 获得过滤器数组</span></span><br /><span class="line"><span class="number">13</span>:     List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br /><span class="line"><span class="number">14</span>:     <span class="comment">// 倒序循环 Filter ，创建带 Filter 链的 Invoker 对象</span></span><br /><span class="line"><span class="number">15</span>:     <span class="keyword">if</span> (!filters.isEmpty()) {</span><br /><span class="line"><span class="number">16</span>:         <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br /><span class="line"><span class="number">17</span>:             <span class="keyword">final</span> Filter filter = filters.get(i);</span><br /><span class="line"><span class="number">18</span>:             <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br /><span class="line"><span class="number">19</span>:             last = <span class="keyword">new</span> Invoker&lt;T&gt;() {</span><br /><span class="line"><span class="number">20</span>: </span><br /><span class="line"><span class="number">21</span>:                 <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>{</span><br /><span class="line"><span class="number">22</span>:                     <span class="keyword">return</span> invoker.getInterface();</span><br /><span class="line"><span class="number">23</span>:                 }</span><br /><span class="line"><span class="number">24</span>: </span><br /><span class="line"><span class="number">25</span>:                 <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>{</span><br /><span class="line"><span class="number">26</span>:                     <span class="keyword">return</span> invoker.getUrl();</span><br /><span class="line"><span class="number">27</span>:                 }</span><br /><span class="line"><span class="number">28</span>: </span><br /><span class="line"><span class="number">29</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>{</span><br /><span class="line"><span class="number">30</span>:                     <span class="keyword">return</span> invoker.isAvailable();</span><br /><span class="line"><span class="number">31</span>:                 }</span><br /><span class="line"><span class="number">32</span>: </span><br /><span class="line"><span class="number">33</span>:                 <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"><span class="number">34</span>:                     <span class="keyword">return</span> filter.invoke(next, invocation);</span><br /><span class="line"><span class="number">35</span>:                 }</span><br /><span class="line"><span class="number">36</span>: </span><br /><span class="line"><span class="number">37</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line"><span class="number">38</span>:                     invoker.destroy();</span><br /><span class="line"><span class="number">39</span>:                 }</span><br /><span class="line"><span class="number">40</span>: </span><br /><span class="line"><span class="number">41</span>:                 <span class="meta">@Override</span></span><br /><span class="line"><span class="number">42</span>:                 <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br /><span class="line"><span class="number">43</span>:                     <span class="keyword">return</span> invoker.toString();</span><br /><span class="line"><span class="number">44</span>:                 }</span><br /><span class="line"><span class="number">45</span>:             };</span><br /><span class="line"><span class="number">46</span>:         }</span><br /><span class="line"><span class="number">47</span>:     }</span><br /><span class="line"><span class="number">48</span>:     <span class="keyword">return</span> last;</span><br /><span class="line"><span class="number">49</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>key</code>&nbsp;属性，获得 URL 参数名。</p>
<ul>
<li>该参数用于获得 ServiceConfig 或 ReferenceConfig 配置的自定义过滤器。</li>
<li>
<p>以 ServiceConfig 举例子，例如&nbsp;<code>url = injvm://127.0.0.1/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;bind.ip=192.168.3.17&amp;bind.port=20880&amp;default.delay=-1&amp;default.retries=0&amp;default.service.filter=demo&amp;delay=-1&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=81844&amp;qos.port=22222&amp;service.filter=demo&amp;side=provider&amp;timestamp=1520682156043</code>&nbsp;中，<strong><code>service.filter=demo</code></strong>，这是笔者配置自定义的 DemoFilter 过滤器。</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> <span class="attr">filter</span>=<span class="string">"demo"</span> /&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>x</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>group</code>&nbsp;属性，分组。</p>
<ul>
<li>在暴露服务时，<code>group = provider</code>&nbsp;。</li>
<li>在引用服务时，<code>group = consumer</code>&nbsp;。</li>
</ul>
</li>
<li>========== 分割线 ==========</li>
<li>第 13 行：调用&nbsp;<code>ExtensionLoader#getActivateExtension(url, key, group)</code>&nbsp;方法，获得过滤器数组。
<ul>
<li>🙂 不熟悉的胖友，请看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 拓展机制 SPI》</a>&nbsp;文章。</li>
<li>继续以上面的例子为基础，<code>filters</code>&nbsp;为：
<ul>
<li>EchoFilter</li>
<li>ClassLoaderFilter</li>
<li>GenericFilter</li>
<li>ContextFilter</li>
<li>TraceFilter</li>
<li>TimeoutFilter</li>
<li>MonitorFilter</li>
<li>ExceptionFilter</li>
<li>DemoFilter 【自定义】</li>
</ul>
</li>
</ul>
</li>
<li>第 15 至 47 行：<strong>倒序</strong>循环 Filter ，创建带 Filter 链的 Invoker 对象。因为是通过<strong>嵌套</strong>声明匿名类循环调用的方式，所以要倒序。胖友可以手工模拟下这个过程。通过这样的方式，实际过滤的顺序，还是我们上面看到的<strong>正序</strong>。</li>
</ul>
<h2 id="3-3-ProtocolListenerWrapper">3.3 ProtocolListenerWrapper</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/ProtocolListenerWrapper.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper</code></a>&nbsp;，实现 Protocol 接口，Protocol 的 Wrapper 拓展实现类，用于给 Exporter 增加 ExporterListener ，监听 Exporter 暴露完成和取消暴露完成。</p>
<h3 id="3-3-1-export">3.3.1 export</h3>
<p>本文涉及的&nbsp;<code>#export(invoker)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="comment">// 注册中心</span></span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {</span><br /><span class="line"> <span class="number">4</span>:         <span class="keyword">return</span> protocol.export(invoker);</span><br /><span class="line"> <span class="number">5</span>:     }</span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// 暴露服务，创建 Exporter 对象</span></span><br /><span class="line"> <span class="number">7</span>:     Exporter&lt;T&gt; exporter = protocol.export(invoker);</span><br /><span class="line"> <span class="number">8</span>:     <span class="comment">// 获得 ExporterListener 数组</span></span><br /><span class="line"> <span class="number">9</span>:     List&lt;ExporterListener&gt; listeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class).getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY));</span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// 创建带 ExporterListener 的 Exporter 对象</span></span><br /><span class="line"><span class="number">11</span>:     <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(exporter, listeners);</span><br /><span class="line"><span class="number">12</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 2 至 5 行：当&nbsp;<code>invoker.url.protocl = registry</code>&nbsp;，跳过，本地暴露服务不会符合这个判断。在远程暴露服务会符合暴露该判断，所以下一篇文章分享。</li>
<li>第 7 行：调用&nbsp;<code>InjvmProtocol#export(invoker)</code>&nbsp;方法，暴露本地服务，创建 InjvmExporter 对象。
<ul>
<li>🙂 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/">「4.2 InjvmExporter」</a>&nbsp;详细解析。</li>
</ul>
</li>
<li>第 9 行：调用&nbsp;<code>ExtensionLoader#getActivateExtension(url, key, group)</code>&nbsp;方法，获得监听器数组。
<ul>
<li>🙂 不熟悉的胖友，请看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 拓展机制 SPI》</a>&nbsp;文章。</li>
<li>继续以上面的例子为基础，<code>listeners</code>&nbsp;为<strong>空</strong>。胖友可以自行实现 ExporterListener ，并进行配置&nbsp;<code>@Activate</code>注解，或者 XML 中&nbsp;<code>listener</code>&nbsp;属性。</li>
</ul>
</li>
<li>第 11 行：创建带 ExporterListener 的 ListenerExporterWrapper 对象。在这个过程中，会执行&nbsp;<code>ExporterListener#exported(exporter)</code>&nbsp;方法。
<ul>
<li>🙂 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/">「4.3 ListenerExporterWrapper」</a>&nbsp;详细解析。</li>
</ul>
</li>
</ul>
<h2 id="3-4-AbstractProtocol">3.4 AbstractProtocol</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractProtocol.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.AbstractProtocol</code></a>&nbsp;，实现 Protocol 接口，协议抽象类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Exporter 集合</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * key: 服务键 {<span class="doctag">@link</span> #serviceKey(URL)} 或 {<span class="doctag">@link</span> URL#getServiceKey()} 。</span></span><br /><span class="line"><span class="comment">     *      不同协议会不同</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Exporter&lt;?&gt;&gt;();</span><br />    <br /><span class="line">    <span class="comment">// ... 省略和本文无关的方法与属性</span></span><br />    <br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>exporterMap</code>&nbsp;属性，Exporter 集合。<strong>该集合拥有该协议中，所有暴露中的 Exporter 对象</strong>。其中&nbsp;<code>key</code>&nbsp;为服务键。不同协议的实现，生成的方式<strong>略有差距</strong>。例如：
<ul>
<li>InjvmProtocol 使用&nbsp;<code>URL#getServiceKey()</code>&nbsp;方法</li>
<li>DubboProtocol 使用&nbsp;<code>#serviceKey(URL)</code>&nbsp;方法。</li>
<li>差别主要在于是否包含&nbsp;<code>port</code>&nbsp;。实际上，也是<strong>一致的</strong>。因为 InjvmProtocol 统一&nbsp;<code>port=0</code>&nbsp;。</li>
</ul>
</li>
<li>该类中，<strong>省略和本文无关的方法与属性</strong>。</li>
</ul>
<h2 id="3-5-InjvmProtocol">3.5 InjvmProtocol</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol</code></a>&nbsp;，实现 AbstractProtocol 抽象类，Injvm 协议实现类。</p>
<h3 id="3-5-1-属性">3.5.1 属性</h3>
<p>属性相关，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 协议名</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = Constants.LOCAL_PROTOCOL;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 默认端口</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">0</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 单例。在 Dubbo SPI 中，被初始化，有且仅有一次。</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InjvmProtocol INSTANCE;</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InjvmProtocol</span><span class="params">()</span> </span>{</span><br /><span class="line">    INSTANCE = <span class="keyword">this</span>;</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InjvmProtocol <span class="title">getInjvmProtocol</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) {</span><br /><span class="line">        ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(InjvmProtocol.NAME); <span class="comment">// load</span></span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>NAME</code>&nbsp;<strong>静态</strong>属性，<code>injvm</code>&nbsp;，协议名。</li>
<li><code>DEFAULT_PORT</code>&nbsp;<strong>静态</strong>属性，默认端口为 0 。</li>
<li><code>INSTANCE</code>&nbsp;<strong>静态</strong>属性，单例。通过 Dubbo SPI 加载创建，有且仅有一次。
<ul>
<li><code>#getInjvmProtocol()</code>&nbsp;<strong>静态</strong>方法，获得单例。</li>
</ul>
</li>
</ul>
<h3 id="3-5-2-export">3.5.2 export</h3>
<p>本文涉及的&nbsp;<code>#export(invoker)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>创建 InjvmExporter 对象。</li>
</ul>
<h1 id="4-Exporter">4. Exporter</h1>
<p>Exporter&nbsp;<strong>接口</strong>，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/">《精尽 Dubbo 源码分析 &mdash;&mdash; 核心流程一览》「4.7 Exporter」</a>&nbsp;有详细解析。</p>
<p>本文涉及的 Exporter 类图如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_03_07/05.png" alt="Exporter 类图" /></p>
<h2 id="4-1-AbstractExporter">4.1 AbstractExporter</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractExporter.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.AbstractExporter</code></a>&nbsp;，实现 Exporter 接口，Exporter 抽象类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Exporter</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Invoker 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;T&gt; invoker;</span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 是否取消暴露服务</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unexported = <span class="keyword">false</span>;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractExporter</span><span class="params">(Invoker&lt;T&gt; invoker)</span> </span>{</span><br /><span class="line">        <span class="keyword">if</span> (invoker == <span class="keyword">null</span>)</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"service invoker == null"</span>);</span><br /><span class="line">        <span class="keyword">if</span> (invoker.getInterface() == <span class="keyword">null</span>)</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"service type == null"</span>);</span><br /><span class="line">        <span class="keyword">if</span> (invoker.getUrl() == <span class="keyword">null</span>)</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"service url == null"</span>);</span><br /><span class="line">        <span class="keyword">this</span>.invoker = invoker;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> invoker;</span><br /><span class="line">    }</span><br />    <br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">if</span> (unexported) {</span><br /><span class="line">            <span class="keyword">return</span>;</span><br /><span class="line">        }</span><br /><span class="line">        unexported = <span class="keyword">true</span>;</span><br /><span class="line">        getInvoker().destroy();</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> getInvoker().toString();</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>invoker</code>&nbsp;属性，Invoker 对象。
<ul>
<li><code>#getInvoker()</code>&nbsp;方法，获得 Invoker 对象。</li>
</ul>
</li>
<li><code>unexported</code>&nbsp;属性，是否取消暴露服务。
<ul>
<li><code>#unexport()</code>&nbsp;方法，取消暴露服务。</li>
</ul>
</li>
</ul>
<h2 id="4-2-InjvmExporter">4.2 InjvmExporter</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmExporter.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol</code></a>&nbsp;，实现 AbstractExporter 抽象类，Injvm Exporter 实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InjvmExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractExporter</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 服务键</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Exporter 集合</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * key: 服务键</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 该值实际就是 {<span class="doctag">@link</span> com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap}</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br /><br /><span class="line">    InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) {</span><br /><span class="line">        <span class="keyword">super</span>(invoker);</span><br /><span class="line">        <span class="keyword">this</span>.key = key;</span><br /><span class="line">        <span class="keyword">this</span>.exporterMap = exporterMap;</span><br /><span class="line">        <span class="comment">// 添加到 Exporter 集合</span></span><br /><span class="line">        exporterMap.put(key, <span class="keyword">this</span>);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">super</span>.unexport();</span><br /><span class="line">        <span class="comment">// 移除出 Exporter 集合</span></span><br /><span class="line">        exporterMap.remove(key);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>key</code>&nbsp;属性，服务键。</li>
<li><code>exporterMap</code>&nbsp;属性，Exporter 集合。在上文&nbsp;<code>InjvmProtocol#export(invoker)</code>&nbsp;方法中，我们可以看到，该属性就是&nbsp;<code>AbstractProtocol.exporterMap</code>&nbsp;属性。
<ul>
<li><strong>构造方法</strong>，<strong>发起</strong>暴露，将自己添加到&nbsp;<code>exporterMap</code>&nbsp;中。</li>
<li><code>#unexport()</code>&nbsp;方法，<strong>取消</strong>暴露，将自己移除出&nbsp;<code>exporterMap</code>&nbsp;中。</li>
</ul>
</li>
</ul>
<h2 id="4-3-ListenerExporterWrapper">4.3 ListenerExporterWrapper</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/listener/ListenerExporterWrapper.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.listener.ListenerExporterWrapper</code></a>&nbsp;，实现 Exporter 接口，具有监听器功能的 Exporter 包装器。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerExporterWrapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Exporter</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ListenerExporterWrapper.class);</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 真实的 Exporter 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exporter&lt;T&gt; exporter;</span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Exporter 监听器数组</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExporterListener&gt; listeners;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerExporterWrapper</span><span class="params">(Exporter&lt;T&gt; exporter, List&lt;ExporterListener&gt; listeners)</span> </span>{</span><br /><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"exporter == null"</span>);</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">this</span>.exporter = exporter;</span><br /><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br /><span class="line">        <span class="comment">// 执行监听器</span></span><br /><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) {</span><br /><span class="line">            RuntimeException exception = <span class="keyword">null</span>;</span><br /><span class="line">            <span class="keyword">for</span> (ExporterListener listener : listeners) {</span><br /><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) {</span><br /><span class="line">                    <span class="keyword">try</span> {</span><br /><span class="line">                        listener.exported(<span class="keyword">this</span>);</span><br /><span class="line">                    } <span class="keyword">catch</span> (RuntimeException t) {</span><br /><span class="line">                        logger.error(t.getMessage(), t);</span><br /><span class="line">                        exception = t;</span><br /><span class="line">                    }</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) {</span><br /><span class="line">                <span class="keyword">throw</span> exception;</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> exporter.getInvoker();</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            exporter.unexport();</span><br /><span class="line">        } <span class="keyword">finally</span> {</span><br /><span class="line">            <span class="comment">// 执行监听器</span></span><br /><span class="line">            <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) {</span><br /><span class="line">                RuntimeException exception = <span class="keyword">null</span>;</span><br /><span class="line">                <span class="keyword">for</span> (ExporterListener listener : listeners) {</span><br /><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) {</span><br /><span class="line">                        <span class="keyword">try</span> {</span><br /><span class="line">                            listener.unexported(<span class="keyword">this</span>);</span><br /><span class="line">                        } <span class="keyword">catch</span> (RuntimeException t) {</span><br /><span class="line">                            logger.error(t.getMessage(), t);</span><br /><span class="line">                            exception = t;</span><br /><span class="line">                        }</span><br /><span class="line">                    }</span><br /><span class="line">                }</span><br /><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) {</span><br /><span class="line">                    <span class="keyword">throw</span> exception;</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><strong>构造方法</strong>，循环&nbsp;<code>listeners</code>&nbsp;，执行&nbsp;<code>ExporterListener#exported(listener)</code>&nbsp;。若执行过程中发生异常 RuntimeException ，打印错误日志，继续执行，最终才抛出。</li>
<li><code>#unexport()</code>&nbsp;方法，循环&nbsp;<code>listeners</code>&nbsp;，执行&nbsp;<code>ExporterListener#unexported(listener)</code>&nbsp;。若执行过程中发生异常 RuntimeException ，打印错误日志，继续执行，最终才抛出。</li>
</ul>
<h1 id="5-ExporterListener">5. ExporterListener</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/6de0a069fcc870894e64ffd54a24e334b19dcb36/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/ExporterListener.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.ExporterListener</code></a>&nbsp;，Exporter 监听器。</p>
<p>代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@SPI</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExporterListener</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * The exporter exported.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 当服务暴露完成</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Protocol#export(Invoker)</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exported</span><span class="params">(Exporter&lt;?&gt; exporter)</span> <span class="keyword">throws</span> RpcException</span>;</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * The exporter unexported.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 当服务取消暴露完成</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Exporter#unexport()</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unexported</span><span class="params">(Exporter&lt;?&gt; exporter)</span></span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_03_01/17.png" alt="ExporterListener 子类" /></p>
<h2 id="5-1-ExporterListenerAdapter">5.1 ExporterListenerAdapter</h2>
<p><code>com.alibaba.dubbo.rpc.listener.ExporterListenerAdapter</code>&nbsp;，实现 ExporterListener 接口，ExporterListener 适配器抽象类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExporterListenerAdapter</span> <span class="keyword">implements</span> <span class="title">ExporterListener</span> </span>{</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exported</span><span class="params">(Exporter&lt;?&gt; exporter)</span> <span class="keyword">throws</span> RpcException </span>{ }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexported</span><span class="params">(Exporter&lt;?&gt; exporter)</span> <span class="keyword">throws</span> RpcException </span>{ }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</div>