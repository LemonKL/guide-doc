<header class="article-header">
<h1 class="article-title">服务引用（一）之本地引用（Injvm）</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>Dubbo 服务引用，<strong>和 Dubbo 服务暴露一样</strong>，<strong>也</strong>有两种方式：</p>
<ul>
<li>
<p>本地引用，JVM 本地调用。配置如下：</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">// 推荐</span><br /><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"local"</span> /&gt;</span></span><br /><span class="line">// 不推荐使用，准备废弃</span><br /><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">injvm</span>=<span class="string">"true"</span> /&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>远程暴露，网络远程通信。配置如下：</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"remote"</span> /&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<p>我们知道 Dubbo 提供了多种协议( Protocol )实现。</p>
<ul>
<li><strong>本文</strong>仅分享本地引用，该方式仅使用 Injvm 协议实现，具体代码在&nbsp;<code>dubbo-rpc-injvm</code>&nbsp;模块中。</li>
<li><strong>下几篇</strong>会分享远程引用，该方式有多种协议实现，例如 Dubbo ( 默认协议 )、Hessian 、Rest 等等。我们会每个协议对应一篇文章，进行分享。</li>
</ul>
<h1 id="2-createProxy">2. createProxy</h1>
<p>本地引用服务的顺序图如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_05_01/02.png" alt="本地引用顺序图" /></p>
<p>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-api-3/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; API 配置（三）之服务消费者》</a>&nbsp;一文中，我们看到&nbsp;<code>ReferenceConfig#init()</code>&nbsp;方法中，会在配置初始化完成后，调用顺序图的<strong>起点</strong>&nbsp;<code>#createProxy(map)</code>&nbsp;方法，开始引用服务。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 自适应 Protocol 实现对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 自适应 ProxyFactory 实现对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br />    <br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 直连服务提供者地址</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="comment">// url for peer-to-peer invocation</span></span><br /><span class="line"><span class="keyword">private</span> String url;</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>{</span><br /><span class="line">  <span class="number">2</span>:     URL tmpUrl = <span class="keyword">new</span> URL(<span class="string">"temp"</span>, <span class="string">"localhost"</span>, <span class="number">0</span>, map);</span><br /><span class="line">  <span class="number">3</span>:     <span class="comment">// 是否本地引用</span></span><br /><span class="line">  <span class="number">4</span>:     <span class="keyword">final</span> <span class="keyword">boolean</span> isJvmRefer;</span><br /><span class="line">  <span class="number">5</span>:     <span class="comment">// injvm 属性为空，不通过该属性判断</span></span><br /><span class="line">  <span class="number">6</span>:     <span class="keyword">if</span> (isInjvm() == <span class="keyword">null</span>) {</span><br /><span class="line">  <span class="number">7</span>:         <span class="comment">// 直连服务提供者，参见文档《直连提供者》http://dubbo.apache.org/zh-cn/docs/user/demos/explicit-target.html</span></span><br /><span class="line">  <span class="number">8</span>:         <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) { <span class="comment">// if a url is specified, don't do local reference</span></span><br /><span class="line">  <span class="number">9</span>:             isJvmRefer = <span class="keyword">false</span>;</span><br /><span class="line"> <span class="number">10</span>:         <span class="comment">// 通过 `tmpUrl` 判断，是否需要本地引用</span></span><br /><span class="line"> <span class="number">11</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) {</span><br /><span class="line"> <span class="number">12</span>:             <span class="comment">// by default, reference local service if there is</span></span><br /><span class="line"> <span class="number">13</span>:             isJvmRefer = <span class="keyword">true</span>;</span><br /><span class="line"> <span class="number">14</span>:         <span class="comment">// 默认不是</span></span><br /><span class="line"> <span class="number">15</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">16</span>:             isJvmRefer = <span class="keyword">false</span>;</span><br /><span class="line"> <span class="number">17</span>:         }</span><br /><span class="line"> <span class="number">18</span>:     <span class="comment">// 通过 injvm 属性。</span></span><br /><span class="line"> <span class="number">19</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">20</span>:         isJvmRefer = isInjvm();</span><br /><span class="line"> <span class="number">21</span>:     }</span><br /><span class="line"> <span class="number">22</span>: </span><br /><span class="line"> <span class="number">23</span>:     <span class="comment">// 本地引用</span></span><br /><span class="line"> <span class="number">24</span>:     <span class="keyword">if</span> (isJvmRefer) {</span><br /><span class="line"> <span class="number">25</span>:         <span class="comment">// 创建服务引用 URL 对象</span></span><br /><span class="line"> <span class="number">26</span>:         URL url = <span class="keyword">new</span> URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br /><span class="line"> <span class="number">27</span>:         <span class="comment">// 引用服务，返回 Invoker 对象</span></span><br /><span class="line"> <span class="number">28</span>:         invoker = refprotocol.refer(interfaceClass, url);</span><br /><span class="line"> <span class="number">29</span>:         <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line"> <span class="number">30</span>:             logger.info(<span class="string">"Using injvm service "</span> + interfaceClass.getName());</span><br /><span class="line"> <span class="number">31</span>:         }</span><br /><span class="line"> <span class="number">32</span>:     <span class="comment">// 正常流程，一般为远程引用</span></span><br /><span class="line"> <span class="number">33</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">34</span>:         <span class="comment">// ... 省略本文暂时不分享的服务远程引用 </span></span><br /><span class="line"> <span class="number">35</span>:         }</span><br /><span class="line"> <span class="number">36</span>:     }</span><br /><span class="line"> <span class="number">37</span>: </span><br /><span class="line"> <span class="number">38</span>:     <span class="comment">// 启动时检查</span></span><br /><span class="line"> <span class="number">39</span>:     Boolean c = check;</span><br /><span class="line"> <span class="number">40</span>:     <span class="keyword">if</span> (c == <span class="keyword">null</span> &amp;&amp; consumer != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">41</span>:         c = consumer.isCheck();</span><br /><span class="line"> <span class="number">42</span>:     }</span><br /><span class="line"> <span class="number">43</span>:     <span class="keyword">if</span> (c == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">44</span>:         c = <span class="keyword">true</span>; <span class="comment">// default true</span></span><br /><span class="line"> <span class="number">45</span>:     }</span><br /><span class="line"> <span class="number">46</span>:     <span class="keyword">if</span> (c &amp;&amp; !invoker.isAvailable()) {</span><br /><span class="line"> <span class="number">47</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to check the status of the service "</span> + interfaceName + <span class="string">". No provider available for the service "</span> + (group == <span class="keyword">null</span> ? <span class="string">""</span> : group + <span class="string">"/"</span>) + interfaceName + (version == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">":"</span> + version) + <span class="string">" from the url "</span> + invoker.getUrl() + <span class="string">" to the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion());</span><br /><span class="line"> <span class="number">48</span>:     }</span><br /><span class="line"> <span class="number">49</span>:     <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line"> <span class="number">50</span>:         logger.info(<span class="string">"Refer dubbo service "</span> + interfaceClass.getName() + <span class="string">" from url "</span> + invoker.getUrl());</span><br /><span class="line"> <span class="number">51</span>:     }</span><br /><span class="line"> <span class="number">52</span>: </span><br /><span class="line"> <span class="number">53</span>:     <span class="comment">// 创建 Service 代理对象</span></span><br /><span class="line"> <span class="number">54</span>:     <span class="comment">// create service proxy</span></span><br /><span class="line"> <span class="number">55</span>:     <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br /><span class="line"> <span class="number">56</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>map</code>&nbsp;方法参数，URL 参数集合，包含服务引用配置对象的配置项。</li>
<li>============ 分割线 ============</li>
<li>第 2 行：创建 URL 对象，重点在<strong>第四个参数</strong>，传入的是&nbsp;<code>map</code>&nbsp;，仅用于第 11 行，是否本地引用。
<ul>
<li><code>protocol = temp</code>&nbsp;的原因是，在第 11 行，已经直接使用了 InjvmProtocol ，而不需要通过该值去获取。</li>
</ul>
</li>
<li>第 4 行：是否本地引用变量&nbsp;<code>isJvmRefer</code>&nbsp;。</li>
<li>第 19 行 至 20 行：调用&nbsp;<code>#isInjvm()</code>&nbsp;方法，返回<strong>非空</strong>，说明配置了&nbsp;<code>injvm</code>&nbsp;配置项，直接使用配置项。</li>
<li>第 8 至 9 行：配置了&nbsp;<code>url</code>&nbsp;配置项，说明使用直连服务提供者的功能，则不使用本地使用。
<ul>
<li><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/explicit-target.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 直连提供者》</a></li>
</ul>
</li>
<li>
<p>第 11 至 13 行：调用&nbsp;<code>InjvmProtocol#isInjvmRefer(url)</code>&nbsp;方法，通过&nbsp;<code>tmpUrl</code>&nbsp;判断，是否需要本地引用。使用&nbsp;<code>tmpUrl</code>&nbsp;，相当于使用服务引用配置对象的配置项。该方法代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 是否本地引用</span></span><br /><span class="line"><span class="comment"> 3:  *</span></span><br /><span class="line"><span class="comment"> 4:  * <span class="doctag">@param</span> url URL</span></span><br /><span class="line"><span class="comment"> 5:  * <span class="doctag">@return</span> 是否</span></span><br /><span class="line"><span class="comment"> 6:  */</span></span><br /><span class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInjvmRefer</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line"> <span class="number">8</span>:     <span class="keyword">final</span> <span class="keyword">boolean</span> isJvmRefer;</span><br /><span class="line"> <span class="number">9</span>:     String scope = url.getParameter(Constants.SCOPE_KEY);</span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// Since injvm protocol is configured explicitly, we don't need to set any extra flag, use normal refer process.</span></span><br /><span class="line"><span class="number">11</span>:     <span class="comment">// 当 `protocol = injvm` 时，本身已经是 jvm 协议了，走正常流程就是了。</span></span><br /><span class="line"><span class="number">12</span>:     <span class="keyword">if</span> (Constants.LOCAL_PROTOCOL.toString().equals(url.getProtocol())) {</span><br /><span class="line"><span class="number">13</span>:         isJvmRefer = <span class="keyword">false</span>;</span><br /><span class="line"><span class="number">14</span>:     <span class="comment">// 当 `scope = local` 或者 `injvm = true` 时，本地引用</span></span><br /><span class="line"><span class="number">15</span>:     } <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SCOPE_LOCAL.equals(scope) || (url.getParameter(<span class="string">"injvm"</span>, <span class="keyword">false</span>))) {</span><br /><span class="line"><span class="number">16</span>:         <span class="comment">// if it's declared as local reference</span></span><br /><span class="line"><span class="number">17</span>:         <span class="comment">// 'scope=local' is equivalent to 'injvm=true', injvm will be deprecated in the future release</span></span><br /><span class="line"><span class="number">18</span>:         isJvmRefer = <span class="keyword">true</span>;</span><br /><span class="line"><span class="number">19</span>:     <span class="comment">// 当 `scope = remote` 时，远程引用</span></span><br /><span class="line"><span class="number">20</span>:     } <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SCOPE_REMOTE.equals(scope)) {</span><br /><span class="line"><span class="number">21</span>:         <span class="comment">// it's declared as remote reference</span></span><br /><span class="line"><span class="number">22</span>:         isJvmRefer = <span class="keyword">false</span>;</span><br /><span class="line"><span class="number">23</span>:     <span class="comment">// 当 `generic = true` 时，即使用泛化调用，远程引用。</span></span><br /><span class="line"><span class="number">24</span>:     } <span class="keyword">else</span> <span class="keyword">if</span> (url.getParameter(Constants.GENERIC_KEY, <span class="keyword">false</span>)) {</span><br /><span class="line"><span class="number">25</span>:         <span class="comment">// generic invocation is not local reference</span></span><br /><span class="line"><span class="number">26</span>:         isJvmRefer = <span class="keyword">false</span>;</span><br /><span class="line"><span class="number">27</span>:     <span class="comment">// 当本地已经有该 Exporter 时，本地引用</span></span><br /><span class="line"><span class="number">28</span>:     } <span class="keyword">else</span> <span class="keyword">if</span> (getExporter(exporterMap, url) != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">29</span>:         <span class="comment">// by default, go through local reference if there's the service exposed locally</span></span><br /><span class="line"><span class="number">30</span>:         isJvmRefer = <span class="keyword">true</span>;</span><br /><span class="line"><span class="number">31</span>:     <span class="comment">// 默认，远程引用</span></span><br /><span class="line"><span class="number">32</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">33</span>:         isJvmRefer = <span class="keyword">false</span>;</span><br /><span class="line"><span class="number">34</span>:     }</span><br /><span class="line"><span class="number">35</span>:     <span class="keyword">return</span> isJvmRefer;</span><br /><span class="line"><span class="number">36</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>============ 本地引用 ============
<ul>
<li>第 15 至 18 行：当&nbsp;<code>scope = local</code>&nbsp;或&nbsp;<code>injvm = true</code>&nbsp;时，本地引用。</li>
<li>第 27 至 30 行：调用&nbsp;<code>#getExporter(url)</code>&nbsp;方法，判断当本地已经有&nbsp;<code>url</code>&nbsp;对应的 InjvmExporter 时，<strong>直接</strong>引用。🙂 本地已有的服务，不必要使用远程服务，减少网络开销，提升性能。
<ul>
<li>🙂 代码比较简单，已经添加中文注释，胖友点击链接查看。</li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6f366fae76b4fc5fc4fb0352737b6e847a3a2b0b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java#L63-L94" target="_blank" rel="external nofollow noopener noreferrer"><code>InjvmProtocol#getExporter(url)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6f366fae76b4fc5fc4fb0352737b6e847a3a2b0b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/UrlUtils.java#L462-L491" target="_blank" rel="external nofollow noopener noreferrer"><code>UrlUtils#isServiceKeyMatch(pattern, value)</code></a></li>
</ul>
</li>
<li>============ 远程引用 ============</li>
<li>第 10 至 13 行：当&nbsp;<code>protocol = injvm</code>&nbsp;时，本身已经是 Injvm 协议了，走正常流程即可。<strong>这是最特殊的，下面会更好的理解</strong>。另外，因为&nbsp;<code>#isInjvmRefer(url)</code>&nbsp;方法，仅有在&nbsp;<code>#createProxy(map)</code>&nbsp;方法中调用，因此实际也不会触发该逻辑。</li>
<li>第 19 至 22 行：当&nbsp;<code>scope = remote</code>&nbsp;时，远程引用。</li>
<li>第 23 至 26 行：当&nbsp;<code>generic = true</code>&nbsp;时，即使用泛化调用，远程引用。
<ul>
<li><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/generic-reference.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 泛化调用》</a></li>
</ul>
</li>
<li>第 31 至 34 行：默认，远程引用。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第 23 至 31 行：<strong>本地引用</strong>。</p>
<ul>
<li>第 26 行：创建本地服务引用 URL 对象。</li>
<li>第 28 行：调用&nbsp;<code>Protocol#refer(interface, url)</code>&nbsp;方法，引用服务，返回 Invoker 对象。
<ul>
<li>此处 Dubbo SPI&nbsp;<strong>自适应</strong>的特性的<strong>好处</strong>就出来了，可以<strong>自动</strong>根据 URL 参数，获得对应的拓展实现。例如，<code>invoker</code>&nbsp;传入后，根据&nbsp;<code>invoker.url</code>&nbsp;自动获得对应 Protocol 拓展实现为 InjvmProtocol 。</li>
<li>实际上，Protocol 有两个 Wrapper 拓展实现类： ProtocolFilterWrapper、ProtocolListenerWrapper 。所以，<code>#refer(...)</code>&nbsp;方法的调用顺序是：<strong>Protocol$Adaptive =&gt; ProtocolFilterWrapper =&gt; ProtocolListenerWrapper =&gt; InjvmProtocol</strong>&nbsp;。</li>
<li>🙂 详细的调用，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/reference-refer-local/">「3. Protocol」</a>&nbsp;在解析。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第 32 至 36 行：正常流程，一般为<strong>远程引用</strong>。为什么是<strong>一般</strong>呢？如果我们配置&nbsp;<code>protocol = injvm</code>&nbsp;，实际走的是<strong>本地引用</strong>。例如：</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">protocol</span>=<span class="string">"injvm"</span> &gt;</span></span><br /><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>🌞 当然，笔者建议，如果真的是需要本地应用，建议配置&nbsp;<code>scope = local</code>&nbsp;。这样，会更加明确和清晰。</li>
</ul>
</li>
<li>
<p>第 38 至 51 行：若配置&nbsp;<code>check = true</code>&nbsp;配置项时，调用&nbsp;<code>Invoker#isAvailable()</code>&nbsp;方法，启动时检查。</p>
<ul>
<li>🙂 该方法在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/reference-refer-local/">「4.2 InjvmInvoker」</a>&nbsp;，详细分享。</li>
<li>🙂&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/preflight-check.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 启动时检查》</a></li>
</ul>
</li>
<li>第 55 行：调用&nbsp;<code>ProxyFactory#getProxy(invoker)</code>&nbsp;方法，创建 Service 代理对象。该 Service 代理对象的内部，会调用&nbsp;<code>Invoker#invoke(Invocation)</code>&nbsp;方法，进行 Dubbo 服务的调用。
<ul>
<li>🙂 详细的实现，后面单独写文章分享。</li>
</ul>
</li>
</ul>
<h1 id="3-Protocol">3. Protocol</h1>
<p><strong>服务引用与暴露的 Protocol 很多类似点</strong>，本文就不重复叙述了。</p>
<p>建议不熟悉的胖友，请点击&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 服务暴露（一）之本地暴露（Injvm）》「3. Protocol」</a>&nbsp;查看。</p>
<p>本文涉及的 Protocol 类图如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_05_01/04.png" alt="Protocol 类图" /></p>
<h2 id="3-1-ProtocolFilterWrapper">3.1 ProtocolFilterWrapper</h2>
<h3 id="3-1-1-refer">3.1.1 refer</h3>
<p>本文涉及的&nbsp;<code>#refer(type, url)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"><span class="number">2</span>:     <span class="comment">// 注册中心</span></span><br /><span class="line"><span class="number">3</span>:     <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {</span><br /><span class="line"><span class="number">4</span>:         <span class="keyword">return</span> protocol.refer(type, url);</span><br /><span class="line"><span class="number">5</span>:     }</span><br /><span class="line"><span class="number">6</span>:     <span class="comment">// 引用服务，返回 Invoker 对象</span></span><br /><span class="line"><span class="number">7</span>:     <span class="comment">// 给改 Invoker 对象，包装成带有 Filter 过滤链的 Invoker 对象</span></span><br /><span class="line"><span class="number">8</span>:     <span class="keyword">return</span> buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);</span><br /><span class="line"><span class="number">9</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 2 至 5 行：当&nbsp;<code>invoker.url.protocl = registry</code>&nbsp;，跳过，本地引用服务不会符合这个判断。在远程引用服务会符合暴露该判断，所以下一篇文章分享。</li>
<li>第 8 行：调用&nbsp;<code>protocol#refer(type, url)</code>&nbsp;方法，继续引用服务，最终返回 Invoker 。</li>
<li>第 8 行：在引用服务完成后，调用&nbsp;<code>#buildInvokerChain(invoker, key, group)</code>&nbsp;方法，创建带有 Filter 过滤链的 Invoker 对象。</li>
</ul>
<h3 id="3-1-2-buildInvokerChain">3.1.2 buildInvokerChain</h3>
<p>和&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-local/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 服务暴露（一）之本地暴露（Injvm）》「3.1.3 buildInvokerChain」</a>&nbsp;基本一致，<strong>默认情况下</strong>，获得的 Filter 数组如下：</p>
<ul>
<li>ConsumerContextFilter</li>
<li>FutureFilter</li>
<li>MonitorFilter</li>
</ul>
<p>当然，因为传入的参数&nbsp;<code>group</code>&nbsp;不同，如果胖友自定义了<strong>自动激活</strong>的 Filter 只出现在&nbsp;<code>group = consumer</code>，那么服务消费者就会多一个该 Filter 实现。</p>
<h2 id="3-2-ProtocolListenerWrapper">3.2 ProtocolListenerWrapper</h2>
<p>本文涉及的&nbsp;<code>#refer(type, url)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="comment">// 注册中心协议</span></span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {</span><br /><span class="line"> <span class="number">4</span>:         <span class="keyword">return</span> protocol.refer(type, url);</span><br /><span class="line"> <span class="number">5</span>:     }</span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// 引用服务</span></span><br /><span class="line"> <span class="number">7</span>:     Invoker&lt;T&gt; invoker = protocol.refer(type, url);</span><br /><span class="line"> <span class="number">8</span>:     <span class="comment">// 获得 InvokerListener 数组</span></span><br /><span class="line"> <span class="number">9</span>:     List&lt;InvokerListener&gt; listeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(InvokerListener.class).getActivateExtension(url, Constants.INVOKER_LISTENER_KEY));</span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// 创建 ListenerInvokerWrapper 对象</span></span><br /><span class="line"><span class="number">11</span>:     <span class="keyword">return</span> <span class="keyword">new</span> ListenerInvokerWrapper&lt;T&gt;(invoker, listeners);</span><br /><span class="line"><span class="number">12</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 2 至 5 行：当&nbsp;<code>invoker.url.protocl = registry</code>&nbsp;，跳过，本地引用服务不会符合这个判断。在远程引用服务会符合暴露该判断，所以下一篇文章分享。</li>
<li>第 7 行：调用&nbsp;<code>protocol#refer(type, url)</code>&nbsp;方法，继续引用服务，最终返回 Invoker 。</li>
<li>第 9 行：调用&nbsp;<code>ExtensionLoader#getActivateExtension(url, key, group)</code>&nbsp;方法，获得监听器数组。
<ul>
<li>🙂 不熟悉的胖友，请看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 拓展机制 SPI》</a>&nbsp;文章。</li>
<li>继续以上面的例子为基础，<code>listeners</code>&nbsp;为<strong>空</strong>。胖友可以自行实现 ExporterListener ，并进行配置&nbsp;<code>@Activate</code>注解，或者 XML 中&nbsp;<code>listener</code>&nbsp;属性。</li>
</ul>
</li>
<li>第 11 行：创建带 InvokerListener 的 ListenerInvokerWrapper 对象。在这个过程中，会执行&nbsp;<code>ExporterListener#referred(invoker)</code>&nbsp;方法。
<ul>
<li>🙂 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/reference-refer-local/">「4.3 ListenerInvokerWrapper」</a>&nbsp;详细解析。</li>
</ul>
</li>
</ul>
<h2 id="3-3-InjvmProtocol">3.3 InjvmProtocol</h2>
<p>本文涉及的&nbsp;<code>#refer(type, url)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjvmInvoker&lt;T&gt;(serviceType, url, url.getServiceKey(), exporterMap);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>创建 InjvmInvoker 对象。<strong>注意</strong>，传入的&nbsp;<code>exporterMap</code>&nbsp;参数，包含<strong>所有的</strong>&nbsp;InjvmExporter 对象。</li>
</ul>
<h1 id="4-Invoker">4. Invoker</h1>
<p>Exporter&nbsp;<strong>接口</strong>，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/reference-refer-local/">《精尽 Dubbo 源码分析 &mdash;&mdash; 核心流程一览》「4.1 Invoker」</a>&nbsp;有详细解析。</p>
<p>本文涉及的 Invoker 类图如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_05_01/05.png" alt="Invoker 类图" /></p>
<h2 id="4-1-AbstractInvoker">4.1 AbstractInvoker</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/6f366fae76b4fc5fc4fb0352737b6e847a3a2b0b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractInvoker.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.AbstractInvoker</code></a>&nbsp;，实现 Invoker 接口，抽象 Invoker 类，主要提供了 Invoker 的通用属性和&nbsp;<code>#invoke(Invocation)</code>&nbsp;方法的通用实现。</p>
<p>本文主要涉及到它的通用属性，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 接口类型</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 服务 URL</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 公用的隐式传参。在 {<span class="doctag">@link</span> #invoke(Invocation)} 方法中使用。</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; attachment;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否可用</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> available = <span class="keyword">true</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否销毁</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p>ps：<code>#invoke(Invocation)</code>&nbsp;方法，在后续的文章分享。</p>
<h2 id="4-2-InjvmInvoker">4.2 InjvmInvoker</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/6f366fae76b4fc5fc4fb0352737b6e847a3a2b0b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmInvoker.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.injvm.InjvmInvoker</code></a>&nbsp;，实现 AbstractInvoker 抽象类，Injvm Invoker 实现类。</p>
<h3 id="4-2-1-属性">4.2.1 属性</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 服务键</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Exporter 集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key: 服务键</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 该值实际就是 {<span class="doctag">@link</span> com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap}</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br /><br /><span class="line">InjvmInvoker(Class&lt;T&gt; type, URL url, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) {</span><br /><span class="line">    <span class="keyword">super</span>(type, url);</span><br /><span class="line">    <span class="keyword">this</span>.key = key;</span><br /><span class="line">    <span class="keyword">this</span>.exporterMap = exporterMap;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>key</code>&nbsp;属性，服务键。</li>
<li><code>exporterMap</code>&nbsp;属性，Exporter 集合。在&nbsp;<code>InjvmInvoker#invoke(invocation)</code>&nbsp;方法中，通过该 Invoker 的&nbsp;<code>key</code>&nbsp;属性，获得对应的 Exporter 对象。</li>
</ul>
<h3 id="4-2-2-isAvailable">4.2.2 isAvailable</h3>
<p><code>#isAvailable()</code>&nbsp;方法，是否可用。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 判断是否有 Exporter 对象</span></span><br /><span class="line">    InjvmExporter&lt;?&gt; exporter = (InjvmExporter&lt;?&gt;) exporterMap.get(key);</span><br /><span class="line">    <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br /><span class="line">    } <span class="keyword">else</span> {</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.isAvailable();</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>开启&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/preflight-check.html" target="_blank" rel="external nofollow noopener noreferrer">启动时检查</a>&nbsp;时，调用该方法，判断该 Invoker 对象，是否有对应的 Exporter 。若不存在，<strong>说明依赖服务不存在</strong>，检查不通过。</li>
</ul>
<h2 id="4-3-ListenerInvokerWrapper">4.3 ListenerInvokerWrapper</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/listener/ListenerInvokerWrapper.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.listener.ListenerInvokerWrapper</code></a>&nbsp;，实现 Invoker 接口，具有监听器功能的 Invoker 包装器。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerInvokerWrapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ListenerInvokerWrapper.class);</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 真实的 Invoker 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;T&gt; invoker;</span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Invoker 监听器数组</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;InvokerListener&gt; listeners;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerInvokerWrapper</span><span class="params">(Invoker&lt;T&gt; invoker, List&lt;InvokerListener&gt; listeners)</span> </span>{</span><br /><span class="line">        <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invoker == null"</span>);</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">this</span>.invoker = invoker;</span><br /><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br /><span class="line">        <span class="comment">// 执行监听器</span></span><br /><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) {</span><br /><span class="line">            <span class="keyword">for</span> (InvokerListener listener : listeners) {</span><br /><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) {</span><br /><span class="line">                    <span class="keyword">try</span> {</span><br /><span class="line">                        listener.referred(invoker);</span><br /><span class="line">                    } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">                        logger.error(t.getMessage(), t);</span><br /><span class="line">                    }</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> invoker.getInterface();</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> invoker.getUrl();</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> invoker.isAvailable();</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> getInterface() + <span class="string">" -&gt; "</span> + (getUrl() == <span class="keyword">null</span> ? <span class="string">" "</span> : getUrl().toString());</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            invoker.destroy();</span><br /><span class="line">        } <span class="keyword">finally</span> {</span><br /><span class="line">            <span class="comment">// 执行监听器</span></span><br /><span class="line">            <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) {</span><br /><span class="line">                <span class="keyword">for</span> (InvokerListener listener : listeners) {</span><br /><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) {</span><br /><span class="line">                        <span class="keyword">try</span> {</span><br /><span class="line">                            listener.destroyed(invoker);</span><br /><span class="line">                        } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">                            logger.error(t.getMessage(), t);</span><br /><span class="line">                        }</span><br /><span class="line">                    }</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><strong>构造方法</strong>，循环&nbsp;<code>listeners</code>&nbsp;，执行&nbsp;<code>InvokerListener#referred(invoker)</code>&nbsp;方法。😈 和 ListenerExporterWrapper 不同，若执行过程中发生异常 RuntimeException ，<strong>仅</strong>打印错误日志，继续执行，最终<strong>不</strong>抛出异常。</li>
<li><code>#unexport()</code>&nbsp;方法，循环&nbsp;<code>listeners</code>&nbsp;，执行&nbsp;<code>InvokerListener#destroyed(invoker)</code>&nbsp;。😈 和 ListenerExporterWrapper 不同，若执行过程中发生异常 RuntimeException ，<strong>仅</strong>打印错误日志，继续执行，最终<strong>不</strong>抛出异常。</li>
</ul>
<h1 id="5-InvokerListener">5. InvokerListener</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/6de0a069fcc870894e64ffd54a24e334b19dcb36/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/InvokerListener.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.InvokerListener</code></a>&nbsp;，Invoker 监听器。</p>
<p>代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@SPI</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvokerListener</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * The invoker referred</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 当服务引用完成</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Protocol#refer(Class, URL)</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">referred</span><span class="params">(Invoker&lt;?&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * The invoker destroyed.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 当服务销毁引用完成</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Invoker#destroy()</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroyed</span><span class="params">(Invoker&lt;?&gt; invoker)</span></span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_03_01/16.png" alt="InvokerListener 子类" /></p>
<h2 id="5-1-InvokerListenerAdapter">5.1 InvokerListenerAdapter</h2>
<p><code>com.alibaba.dubbo.rpc.listener.InvokerListenerAdapter</code>&nbsp;，实现 InvokerListener 接口，InvokerListener 适配器<strong>抽象类</strong>。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerListenerAdapter</span> <span class="keyword">implements</span> <span class="title">InvokerListener</span> </span>{</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">referred</span><span class="params">(Invoker&lt;?&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>{ }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyed</span><span class="params">(Invoker&lt;?&gt; invoker)</span> </span>{ }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="5-2-DeprecatedInvokerListener">5.2 DeprecatedInvokerListener</h2>
<p><code>com.alibaba.dubbo.rpc.listener.DeprecatedInvokerListener</code>&nbsp;，实现 InvokerListenerAdapter&nbsp;<strong>抽象类</strong>&nbsp;，引用废弃的服务时，打印错误日志提醒。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Activate</span>(Constants.DEPRECATED_KEY)</span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeprecatedInvokerListener</span> <span class="keyword">extends</span> <span class="title">InvokerListenerAdapter</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DeprecatedInvokerListener.class);</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">referred</span><span class="params">(Invoker&lt;?&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">if</span> (invoker.getUrl().getParameter(Constants.DEPRECATED_KEY, <span class="keyword">false</span>)) {</span><br /><span class="line">            LOGGER.error(<span class="string">"The service "</span> + invoker.getInterface().getName() + <span class="string">" is DEPRECATED! Declare from "</span> + invoker.getUrl());</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>@Activate(Constants.DEPRECATED_KEY)</code>&nbsp;注解，基于 Dubbo SPI Activate 机制加载。配置方式如下：</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> <span class="attr">deprecated</span>=<span class="string">"true"</span> /&gt;</span></span><br /><span class="line">    ```  </span><br /><span class="line">    * 通过设置 `"deprecated"` 为 `true` 来设置。</span><br /><span class="line">    * 该方式仅适用于**远程引用**服务。</span><br /> <br /><span class="line">* 在 `#referred(invoker)` 方法中，打印错误日志，例如：</span><br /><br /><span class="line">    ```Java</span><br /><span class="line">    [25/03/18 07:37:56:056 CST] main ERROR listener.DeprecatedInvokerListener:  [DUBBO] The service com.alibaba.dubbo.demo.DemoService is DEPRECATED! Declare from dubbo://192.168.3.17:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-consumer&amp;check=false&amp;compiler=jdk&amp;default.delay=-1&amp;default.retries=0&amp;delay=-1&amp;deprecated=true&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello,bye&amp;pid=45155&amp;qos.port=33333&amp;register.ip=192.168.3.17&amp;remote.timestamp=1521977820764&amp;service.filter=demo&amp;side=consumer&amp;timestamp=1521977854685, dubbo version: 2.0.0, current host: 192.168.3.17</span><br /><span class="line">    group:consumer</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<p>另外，<strong>本地引用</strong>服务的配置方式如下：</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">protocol</span>=<span class="string">"injvm"</span>&gt;</span></span><br /><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"deprecated"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br /><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>因为，本地引用服务时，不是使用服务提供者的 URL ，而是服务消费者的 URL 。</li>
</ul>
</div>