<header class="article-header">
<h1 class="article-title">动态编译（一）之 Javassist</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>在 Java 语言中，大多数情况下，我们已经编写好 Java 类，并编译成 Class 文件进行运行。但是在一些场景下，例如动态代理，需要运用到<strong>动态编译</strong>的技术。虽然我们也可以用反射的技术实现，但是相比来说，还是有一定的性能差距。</p>
<p>例如，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 拓展机制 SPI》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/compiler-javassist/">「4.5.4 createAdaptiveExtensionClassCode」</a>小节中，我们可以看到如下代码：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 自动生成自适应拓展的代码实现，并编译后返回该类。</span></span><br /><span class="line"><span class="comment"> 3:  *</span></span><br /><span class="line"><span class="comment"> 4:  * <span class="doctag">@return</span> 类</span></span><br /><span class="line"><span class="comment"> 5:  */</span></span><br /><span class="line"> <span class="number">6</span>: <span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() {</span><br /><span class="line"> <span class="number">7</span>:     <span class="comment">// 自动生成自适应拓展的代码实现的字符串</span></span><br /><span class="line"> <span class="number">8</span>:     String code = createAdaptiveExtensionClassCode();</span><br /><span class="line"> <span class="number">9</span>:     <span class="comment">// 编译代码，并返回该类</span></span><br /><span class="line"><span class="number">10</span>:     ClassLoader classLoader = findClassLoader();</span><br /><span class="line"><span class="number">11</span>:     com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br /><span class="line"><span class="number">12</span>:     <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br /><span class="line"><span class="number">13</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p>调用&nbsp;<code>Compiler#compile(code, classLoader)</code>&nbsp;方法，编译代码，并返回该类。Compiler 基于 Dubbo SPI 机制进行加载，目前有两种实现：</p>
<ul>
<li>
<p>JdkCompiler</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">compiler</span>=<span class="string">"jdk"</span> /&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>JavassistCompiler</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">compiler</span>=<span class="string">"javassist"</span> /&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<p><strong>缺省</strong>使用 JavassistCompiler 。</p>
<p>🙂 本文仅分享 JavassistCompiler 的实现。</p>
<hr />
<p>动态编译，在&nbsp;<code>dubbo-common</code>&nbsp;模块的&nbsp;<a href="https://github.com/YunaiV/dubbo/tree/ded892cb2f31e2847c18f773e16b16a6fbaf53d2/dubbo-common/src/main/java/com/alibaba/dubbo/common/compiler" target="_blank" rel="external nofollow noopener noreferrer"><code>compiler</code></a>&nbsp;包下实现，整体类结构如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_09_01/01.png" alt="类图" /></p>
<h1 id="2-Compiler">2. Compiler</h1>
<p><code>com.alibaba.dubbo.common.compiler.Compiler</code>&nbsp;，编辑器接口。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compiler</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Compile java source code.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 编译 Java 代码字符串</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> code        Java source code</span></span><br /><span class="line"><span class="comment">     *                    Java 代码字符串</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader classloader</span></span><br /><span class="line"><span class="comment">     *                    类加载器</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> Compiled class</span></span><br /><span class="line"><span class="comment">     *                    编译后的类</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    Class&lt;?&gt; compile(String code, ClassLoader classLoader);</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>@SPI("javassist")</code>&nbsp;注解，使用 Dubbo SPI 机制，默认拓展为 Javassist 。</li>
<li><code>code</code>&nbsp;参数，Java 代码字符串。如下是 ProxyFactory$Adaptive 的自适应拓展的代码实现的字符串生成<strong>例子</strong>：<img src="http://static2.iocoder.cn/images/Dubbo/2018_03_04/05.png" alt="自适应拓展的代码实现的字符串生成例子" /></li>
</ul>
<h1 id="3-AdaptiveCompiler">3. AdaptiveCompiler</h1>
<p><code>com.alibaba.dubbo.common.compiler.support.AdaptiveCompiler</code>&nbsp;，实现 Compiler 接口，自适应 Compiler 实现类。</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Adaptive</span></span><br /><span class="line"> <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveCompiler</span> <span class="keyword">implements</span> <span class="title">Compiler</span> </span>{</span><br /><span class="line"> <span class="number">3</span>: </span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 5:      * 默认编辑器的拓展名</span></span><br /><span class="line"><span class="comment"> 6:      */</span></span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> String DEFAULT_COMPILER;</span><br /><span class="line"> <span class="number">8</span>: </span><br /><span class="line"> <span class="number">9</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultCompiler</span><span class="params">(String compiler)</span> </span>{</span><br /><span class="line"><span class="number">10</span>:         DEFAULT_COMPILER = compiler;</span><br /><span class="line"><span class="number">11</span>:     }</span><br /><span class="line"><span class="number">12</span>: </span><br /><span class="line"><span class="number">13</span>:     <span class="meta">@Override</span> <span class="keyword">public</span> Class&lt;?&gt; compile(String code, ClassLoader classLoader) {</span><br /><span class="line"><span class="number">14</span>:         Compiler compiler;</span><br /><span class="line"><span class="number">15</span>:         <span class="comment">// 获得 Compiler 的 ExtensionLoader 对象。</span></span><br /><span class="line"><span class="number">16</span>:         ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler.class);</span><br /><span class="line"><span class="number">17</span>:         String name = DEFAULT_COMPILER; <span class="comment">// copy reference</span></span><br /><span class="line"><span class="number">18</span>:         <span class="comment">// 使用设置的拓展名，获得 Compiler 拓展对象</span></span><br /><span class="line"><span class="number">19</span>:         <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">20</span>:             compiler = loader.getExtension(name);</span><br /><span class="line"><span class="number">21</span>:         <span class="comment">// 获得默认的 Compiler 拓展对象</span></span><br /><span class="line"><span class="number">22</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">23</span>:             compiler = loader.getDefaultExtension();</span><br /><span class="line"><span class="number">24</span>:         }</span><br /><span class="line"><span class="number">25</span>:         <span class="comment">//</span></span><br /><span class="line"><span class="number">26</span>:         <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br /><span class="line"><span class="number">27</span>:     }</span><br /><span class="line"><span class="number">28</span>: </span><br /><span class="line"><span class="number">29</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>#setDefaultCompiler(compiler)</code>&nbsp;<strong>静态</strong>方法，设置默认编辑器的拓展名(&nbsp;<code>DEFAULT_COMPILER</code>&nbsp;)。该方法被&nbsp;<code>ApplicationConfig#setCompiler(compiler)</code>&nbsp;方法调用，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ApplicationConfig.java</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompiler</span><span class="params">(String compiler)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>.compiler = compiler;</span><br /><span class="line">    AdaptiveCompiler.setDefaultCompiler(compiler);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>在&nbsp;<code>&lt;dubbo:application compiler="" /&gt;</code>&nbsp;配置下，可触发该方法。</li>
</ul>
</li>
<li>
<p><code>#compile(code, classLoader)</code>&nbsp;<strong>实现</strong>方法：</p>
<ul>
<li>第 16 行：调用&nbsp;<code>ExtensionLoader#getExtensionLoader(Class&lt;?&gt; type)</code>&nbsp;方法，获得 Compiler 的 ExtensionLoader 对象。</li>
<li>第 17 行：声明&nbsp;<code>name</code>&nbsp;变量，引用&nbsp;<code>DEFAULT_COMPILER</code>&nbsp;的值。避免在【第 19 至 20 行】的代码过程中，值变了。</li>
<li>第 19 至 20 行：使用<strong>设置</strong>的拓展名，获得 Compiler 拓展对象。</li>
<li>第 22 至 24 行：获得默认的 Compiler 拓展对象。</li>
<li>第 26 行：调用真正的 Compiler 对象，动态编译代码。</li>
</ul>
</li>
</ul>
<h1 id="4-AbstractCompiler">4. AbstractCompiler</h1>
<p><code>com.alibaba.dubbo.common.compiler.support.AbstractCompiler</code>&nbsp;，实现 Compiler 接口，Compiler&nbsp;<strong>抽象类</strong>。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCompiler</span> <span class="keyword">implements</span> <span class="title">Compiler</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 正则 - 包名</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PACKAGE_PATTERN = Pattern.compile(<span class="string">"package\\s+([$_a-zA-Z][$_a-zA-Z0-9\\.]*);"</span>);</span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 正则 - 类名</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern CLASS_PATTERN = Pattern.compile(<span class="string">"class\\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\\s+"</span>);</span><br /><br /><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; compile(String code, ClassLoader classLoader) {</span><br /><span class="line">        <span class="comment">// 获得包名</span></span><br /><span class="line">        code = code.trim();</span><br /><span class="line">        Matcher matcher = PACKAGE_PATTERN.matcher(code);</span><br /><span class="line">        String pkg;</span><br /><span class="line">        <span class="keyword">if</span> (matcher.find()) {</span><br /><span class="line">            pkg = matcher.group(<span class="number">1</span>);</span><br /><span class="line">        } <span class="keyword">else</span> {</span><br /><span class="line">            pkg = <span class="string">""</span>;</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 获得类名</span></span><br /><span class="line">        matcher = CLASS_PATTERN.matcher(code);</span><br /><span class="line">        String cls;</span><br /><span class="line">        <span class="keyword">if</span> (matcher.find()) {</span><br /><span class="line">            cls = matcher.group(<span class="number">1</span>);</span><br /><span class="line">        } <span class="keyword">else</span> {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No such class name in "</span> + code);</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 获得完整类名</span></span><br /><span class="line">        String className = pkg != <span class="keyword">null</span> &amp;&amp; pkg.length() &gt; <span class="number">0</span> ? pkg + <span class="string">"."</span> + cls : cls;</span><br /><span class="line">        <span class="comment">// 加载类，若已经存在</span></span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="comment">// 加载成功，说明已存在</span></span><br /><span class="line">            <span class="keyword">return</span> Class.forName(className, <span class="keyword">true</span>, ClassHelper.getCallerClassLoader(getClass())); <span class="comment">// classloader 为调用方的</span></span><br /><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException e) { <span class="comment">// 类不存在，说明可能未编译过，进行编译</span></span><br /><span class="line">            <span class="comment">// 代码格式不正确</span></span><br /><span class="line">            <span class="keyword">if</span> (!code.endsWith(<span class="string">"}"</span>)) {</span><br /><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The java code not endsWith \"}\", code: \n"</span> + code + <span class="string">"\n"</span>);</span><br /><span class="line">            }</span><br /><span class="line">            <span class="comment">// 编译代码</span></span><br /><span class="line">            <span class="keyword">try</span> {</span><br /><span class="line">                <span class="keyword">return</span> doCompile(className, code);</span><br /><span class="line">            } <span class="keyword">catch</span> (RuntimeException t) {</span><br /><span class="line">                <span class="keyword">throw</span> t;</span><br /><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to compile class, cause: "</span> + t.getMessage() + <span class="string">", class: "</span> + className + <span class="string">", code: \n"</span> + code + <span class="string">"\n, stack: "</span> + ClassUtils.toString(t));</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 编译代码</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 类名</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 代码</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编译后的类</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable 发生异常</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt; doCompile(String name, String source) <span class="keyword">throws</span> Throwable;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>首先获得完整类名，后使用类加载器加载该类：
<ul>
<li>若成功，说明已经存在（可能已经编译过）。</li>
<li>若失败，进行编译。</li>
</ul>
</li>
<li>🙂 代码比较简单，胖友可以在看下注释。</li>
</ul>
<h1 id="5-JavassistCompiler">5. JavassistCompiler</h1>
<blockquote>
<p>Javassist 是一个开源的分析、编辑和创建 Java 字节码的类库。通过使用Javassist 对字节码操作可以实现动态 &rdquo;AOP&rdquo; 框架。</p>
<p>关于 Java 字节码的处理，目前有很多工具，如 bcel，asm( cglib只是对asm又封装了一层 )。不过这些都需要直接跟虚拟机指令打交道。</p>
<p>Javassist 的主要的优点，在于简单，而且快速，直接使用 Java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p>
</blockquote>
<ul>
<li>粗略一看，可能不够形象，下面我们通过看 JavassistCompiler 如何使用来理解理解。</li>
<li><a href="http://www.cnblogs.com/sunfie/p/5154246.html" target="_blank" rel="external nofollow noopener noreferrer">《Java学习之javassist》</a></li>
<li><a href="http://blog.csdn.net/qbg19881206/article/details/8993562" target="_blank" rel="external nofollow noopener noreferrer">《Javassist 字节码操作》</a></li>
</ul>
<p><code>com.alibaba.dubbo.common.compiler.support.JavassistCompiler</code>&nbsp;，实现 AbstractCompiler 抽象类，基于 Javassist 实现的 Compiler 。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">  <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistCompiler</span> <span class="keyword">extends</span> <span class="title">AbstractCompiler</span> </span>{</span><br /><span class="line">  <span class="number">2</span>: </span><br /><span class="line">  <span class="number">3</span>:     <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  4:      * 正则 - 匹配 import</span></span><br /><span class="line"><span class="comment">  5:      */</span></span><br /><span class="line">  <span class="number">6</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern IMPORT_PATTERN = Pattern.compile(<span class="string">"import\\s+([\\w\\.\\*]+);\n"</span>);</span><br /><span class="line">  <span class="number">7</span>:     <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  8:      * 正则 - 匹配 extends</span></span><br /><span class="line"><span class="comment">  9:      */</span></span><br /><span class="line"> <span class="number">10</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern EXTENDS_PATTERN = Pattern.compile(<span class="string">"\\s+extends\\s+([\\w\\.]+)[^\\{]*\\{\n"</span>);</span><br /><span class="line"> <span class="number">11</span>:     <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 12:      * 正则 - 匹配 implements</span></span><br /><span class="line"><span class="comment"> 13:      */</span></span><br /><span class="line"> <span class="number">14</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern IMPLEMENTS_PATTERN = Pattern.compile(<span class="string">"\\s+implements\\s+([\\w\\.]+)\\s*\\{\n"</span>);</span><br /><span class="line"> <span class="number">15</span>:     <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 16:      * 正则 - 匹配方法</span></span><br /><span class="line"><span class="comment"> 17:      */</span></span><br /><span class="line"> <span class="number">18</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern METHODS_PATTERN = Pattern.compile(<span class="string">"\n(private|public|protected)\\s+"</span>);</span><br /><span class="line"> <span class="number">19</span>:     <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 20:      * 正则 - 匹配变量</span></span><br /><span class="line"><span class="comment"> 21:      */</span></span><br /><span class="line"> <span class="number">22</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern FIELD_PATTERN = Pattern.compile(<span class="string">"[^\n]+=[^\n]+;"</span>);</span><br /><span class="line"> <span class="number">23</span>: </span><br /><span class="line"> <span class="number">24</span>:     <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">25</span>:     <span class="keyword">public</span> Class&lt;?&gt; doCompile(String name, String source) <span class="keyword">throws</span> Throwable {</span><br /><span class="line"> <span class="number">26</span>:         <span class="comment">// 获得类名</span></span><br /><span class="line"> <span class="number">27</span>:         <span class="keyword">int</span> i = name.lastIndexOf(<span class="string">'.'</span>);</span><br /><span class="line"> <span class="number">28</span>:         String className = i &lt; <span class="number">0</span> ? name : name.substring(i + <span class="number">1</span>);</span><br /><span class="line"> <span class="number">29</span>:         <span class="comment">// 创建 ClassPool 对象</span></span><br /><span class="line"> <span class="number">30</span>:         ClassPool pool = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br /><span class="line"> <span class="number">31</span>:         <span class="comment">// 设置类搜索路径</span></span><br /><span class="line"> <span class="number">32</span>:         pool.appendClassPath(<span class="keyword">new</span> LoaderClassPath(ClassHelper.getCallerClassLoader(getClass())));</span><br /><span class="line"> <span class="number">33</span>:         <span class="comment">// 匹配 import</span></span><br /><span class="line"> <span class="number">34</span>:         Matcher matcher = IMPORT_PATTERN.matcher(source);</span><br /><span class="line"> <span class="number">35</span>:         List&lt;String&gt; importPackages = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 引用的包名</span></span><br /><span class="line"> <span class="number">36</span>:         Map&lt;String, String&gt; fullNames = <span class="keyword">new</span> HashMap&lt;String, String&gt;(); <span class="comment">// 引用的类名</span></span><br /><span class="line"> <span class="number">37</span>:         <span class="keyword">while</span> (matcher.find()) {</span><br /><span class="line"> <span class="number">38</span>:             String pkg = matcher.group(<span class="number">1</span>);</span><br /><span class="line"> <span class="number">39</span>:             <span class="keyword">if</span> (pkg.endsWith(<span class="string">".*"</span>)) { <span class="comment">// 引用整个包下的类/接口</span></span><br /><span class="line"> <span class="number">40</span>:                 String pkgName = pkg.substring(<span class="number">0</span>, pkg.length() - <span class="number">2</span>);</span><br /><span class="line"> <span class="number">41</span>:                 pool.importPackage(pkgName);</span><br /><span class="line"> <span class="number">42</span>:                 importPackages.add(pkgName);</span><br /><span class="line"> <span class="number">43</span>:             } <span class="keyword">else</span> { <span class="comment">// 引用指定类/接口</span></span><br /><span class="line"> <span class="number">44</span>:                 <span class="keyword">int</span> pi = pkg.lastIndexOf(<span class="string">'.'</span>);</span><br /><span class="line"> <span class="number">45</span>:                 <span class="keyword">if</span> (pi &gt; <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">46</span>:                     String pkgName = pkg.substring(<span class="number">0</span>, pi);</span><br /><span class="line"> <span class="number">47</span>:                     pool.importPackage(pkgName);</span><br /><span class="line"> <span class="number">48</span>:                     importPackages.add(pkgName);</span><br /><span class="line"> <span class="number">49</span>:                     fullNames.put(pkg.substring(pi + <span class="number">1</span>), pkg); <span class="comment">// 类名</span></span><br /><span class="line"> <span class="number">50</span>:                 }</span><br /><span class="line"> <span class="number">51</span>:             }</span><br /><span class="line"> <span class="number">52</span>:         }</span><br /><span class="line"> <span class="number">53</span>:         String[] packages = importPackages.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br /><span class="line"> <span class="number">54</span>:         <span class="comment">// 匹配 extends</span></span><br /><span class="line"> <span class="number">55</span>:         matcher = EXTENDS_PATTERN.matcher(source);</span><br /><span class="line"> <span class="number">56</span>:         CtClass cls;</span><br /><span class="line"> <span class="number">57</span>:         <span class="keyword">if</span> (matcher.find()) {</span><br /><span class="line"> <span class="number">58</span>:             String extend = matcher.group(<span class="number">1</span>).trim();</span><br /><span class="line"> <span class="number">59</span>:             String extendClass;</span><br /><span class="line"> <span class="number">60</span>:             <span class="keyword">if</span> (extend.contains(<span class="string">"."</span>)) { <span class="comment">// 内嵌的类，例如：extends A.B</span></span><br /><span class="line"> <span class="number">61</span>:                 extendClass = extend;</span><br /><span class="line"> <span class="number">62</span>:             } <span class="keyword">else</span> <span class="keyword">if</span> (fullNames.containsKey(extend)) { <span class="comment">// 指定引用的类</span></span><br /><span class="line"> <span class="number">63</span>:                 extendClass = fullNames.get(extend);</span><br /><span class="line"> <span class="number">64</span>:             } <span class="keyword">else</span> { <span class="comment">// 引用整个包下的类</span></span><br /><span class="line"> <span class="number">65</span>:                 extendClass = ClassUtils.forName(packages, extend).getName();</span><br /><span class="line"> <span class="number">66</span>:             }</span><br /><span class="line"> <span class="number">67</span>:             <span class="comment">// 创建 CtClass 对象</span></span><br /><span class="line"> <span class="number">68</span>:             cls = pool.makeClass(name, pool.get(extendClass));</span><br /><span class="line"> <span class="number">69</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">70</span>:             <span class="comment">// 创建 CtClass 对象</span></span><br /><span class="line"> <span class="number">71</span>:             cls = pool.makeClass(name);</span><br /><span class="line"> <span class="number">72</span>:         }</span><br /><span class="line"> <span class="number">73</span>:         <span class="comment">// 匹配 implements</span></span><br /><span class="line"> <span class="number">74</span>:         matcher = IMPLEMENTS_PATTERN.matcher(source);</span><br /><span class="line"> <span class="number">75</span>:         <span class="keyword">if</span> (matcher.find()) {</span><br /><span class="line"> <span class="number">76</span>:             String[] ifaces = matcher.group(<span class="number">1</span>).trim().split(<span class="string">"\\,"</span>);</span><br /><span class="line"> <span class="number">77</span>:             <span class="keyword">for</span> (String iface : ifaces) {</span><br /><span class="line"> <span class="number">78</span>:                 iface = iface.trim();</span><br /><span class="line"> <span class="number">79</span>:                 String ifaceClass;</span><br /><span class="line"> <span class="number">80</span>:                 <span class="keyword">if</span> (iface.contains(<span class="string">"."</span>)) { <span class="comment">// 内嵌的接口，例如：extends A.B</span></span><br /><span class="line"> <span class="number">81</span>:                     ifaceClass = iface;</span><br /><span class="line"> <span class="number">82</span>:                 } <span class="keyword">else</span> <span class="keyword">if</span> (fullNames.containsKey(iface)) { <span class="comment">// 指定引用的接口</span></span><br /><span class="line"> <span class="number">83</span>:                     ifaceClass = fullNames.get(iface);</span><br /><span class="line"> <span class="number">84</span>:                 } <span class="keyword">else</span> { <span class="comment">// 引用整个包下的接口</span></span><br /><span class="line"> <span class="number">85</span>:                     ifaceClass = ClassUtils.forName(packages, iface).getName();</span><br /><span class="line"> <span class="number">86</span>:                 }</span><br /><span class="line"> <span class="number">87</span>:                 <span class="comment">// 添加接口</span></span><br /><span class="line"> <span class="number">88</span>:                 cls.addInterface(pool.get(ifaceClass));</span><br /><span class="line"> <span class="number">89</span>:             }</span><br /><span class="line"> <span class="number">90</span>:         }</span><br /><span class="line"> <span class="number">91</span>:         <span class="comment">// 获得类中的内容，即首末 {} 的内容。</span></span><br /><span class="line"> <span class="number">92</span>:         String body = source.substring(source.indexOf(<span class="string">"{"</span>) + <span class="number">1</span>, source.length() - <span class="number">1</span>);</span><br /><span class="line"> <span class="number">93</span>:         <span class="comment">// 匹配 method 。使用分隔的方式，实际上，分隔出来的不仅仅有方法。</span></span><br /><span class="line"> <span class="number">94</span>:         String[] methods = METHODS_PATTERN.split(body);</span><br /><span class="line"> <span class="number">95</span>:         <span class="keyword">for</span> (String method : methods) {</span><br /><span class="line"> <span class="number">96</span>:             method = method.trim();</span><br /><span class="line"> <span class="number">97</span>:             <span class="keyword">if</span> (method.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">98</span>:                 <span class="keyword">if</span> (method.startsWith(className)) { <span class="comment">// 构造方法</span></span><br /><span class="line"> <span class="number">99</span>:                     cls.addConstructor(CtNewConstructor.make(<span class="string">"public "</span> + method, cls));</span><br /><span class="line"><span class="number">100</span>:                 } <span class="keyword">else</span> <span class="keyword">if</span> (FIELD_PATTERN.matcher(method).matches()) { <span class="comment">// 变量</span></span><br /><span class="line"><span class="number">101</span>:                     cls.addField(CtField.make(<span class="string">"private "</span> + method, cls));</span><br /><span class="line"><span class="number">102</span>:                 } <span class="keyword">else</span> { <span class="comment">// 方法</span></span><br /><span class="line"><span class="number">103</span>:                     cls.addMethod(CtNewMethod.make(<span class="string">"public "</span> + method, cls));</span><br /><span class="line"><span class="number">104</span>:                 }</span><br /><span class="line"><span class="number">105</span>:             }</span><br /><span class="line"><span class="number">106</span>:         }</span><br /><span class="line"><span class="number">107</span>:         <span class="comment">// 生成类</span></span><br /><span class="line"><span class="number">108</span>:         <span class="comment">// JavassistCompiler.class.getProtectionDomain() =》 设置保护域和 JavassistCompiler 一致，即 `#getClass()` 方法。深入见 《Java安全&mdash;&mdash;安全管理器、访问控制器和类装载器》https://www.zybuluo.com/changedi/note/417132</span></span><br /><span class="line"><span class="number">109</span>:         <span class="keyword">return</span> cls.toClass(ClassHelper.getCallerClassLoader(getClass()), JavassistCompiler.class.getProtectionDomain());</span><br /><span class="line"><span class="number">110</span>:     }</span><br /><span class="line"><span class="number">111</span>: </span><br /><span class="line"><span class="number">112</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>因为传入的是 Java 源代码&nbsp;<code>source</code>&nbsp;，需要通过正则匹配出&nbsp;<code>import</code>、<code>extends</code>、<code>implements</code>、方法、变量，传递给 Javassist API ，进行类生成。🙂 如果胖友对 Javassist 的 API 不是很了解，可以看完整体逻辑，回看下上面提供的文档。挺有趣的。</li>
<li>第 27 至 28 行：获得类名。</li>
<li>第 30 行：创建 ClassPool 对象。<strong>ClassPool</strong>&nbsp;是一个 CtClass 对象的 hash 表，类名做为 key 。ClassPool 的&nbsp;<code>#get(key)</code>&nbsp;搜索 hash 表找到与指定 key 关联的 CtClass 对象。如果没有找到 CtClass 对象，<code>#get(key)</code>&nbsp;读一个类文件构建新的 CtClass 对象，它是被记录在 hash 表中然后返回这个对象。</li>
<li>第 32 行：调用&nbsp;<code>ClassPool#appendClassPath(ClassPath)</code>&nbsp;方法，设置类搜索路径。</li>
<li>第 33 至 52 行：匹配&nbsp;<code>import</code>&nbsp;。
<ul>
<li><code>ClassPool#importPackage(packageName)</code>&nbsp;方法，引用包。</li>
</ul>
</li>
<li>第 54 至 72 行：匹配&nbsp;<code>extends</code>&nbsp;。
<ul>
<li><code>ClassPool#makeClass(name, extendClass)</code>&nbsp;方法，创建<strong>带继承的</strong>类。</li>
<li><code>ClassPool#makeClass(name)</code>&nbsp;方法，创建类。</li>
</ul>
</li>
<li>第 74 至 90 行：匹配&nbsp;<code>implements</code>&nbsp;，整体逻辑和&nbsp;<code>extends</code>&nbsp;类似。
<ul>
<li><code>CtClass#addInterface(anInterface)</code>&nbsp;方法，添加类的接口。</li>
</ul>
</li>
<li>第 92 行：获得类中的内容，即首末&nbsp;<code>{</code>&nbsp;<code>}</code>&nbsp;中的内容体。</li>
<li>第 94 至 106 行：匹配方法和变量。使用&nbsp;<code>METHODS_PATTERN</code>&nbsp;分隔的方式。
<ul>
<li><code>CtClass#addConstructor(CtConstructor)</code>&nbsp;方法，添加类的构造方法。</li>
<li><code>CtClass#addMethod(CtMethod)</code>&nbsp;方法，添加类的方法。</li>
<li><code>CtClass#addField(CtField)</code>&nbsp;方法，添加类的属性。</li>
</ul>
</li>
<li>第 109 行：调用&nbsp;<code>CtClass#toClass(ClassLoader, ProtectionDomain)</code>&nbsp;方法，生成类。</li>
</ul>
</div>