<header class="article-header">
<h1 class="article-title">服务调用（二）之远程调用（Dubbo）【1】通信实现</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>从本文开始，我们开始分享&nbsp;<code>dubbo://</code>&nbsp;协议的远程调用，主要分成<strong>四个部分</strong>：</p>
<ol>
<li>通信实现</li>
<li>同步调用</li>
<li>异步调用</li>
<li>参数回调</li>
</ol>
<p>本文分享&nbsp;<strong>通信实现</strong>&nbsp;部分。</p>
<p>😈&nbsp;<a href="http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/">《精尽 Dubbo 源码解析 &mdash;&mdash; NIO 服务器》</a>&nbsp;系列，是本文的<strong>前置文章</strong>，所以胖友需要先读完这个系列。哈哈哈，当然，也可以凑合看看先。</p>
<p>本文涉及类图如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_10_04/01_01.png" alt="类图" /></p>
<h1 id="2-Server">2. Server</h1>
<p>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/reference-export-dubbo/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 服务引用（二）之远程暴露（Dubbo）》</a>&nbsp;中，我们看到使用的 Server 实现类是&nbsp;<strong>HeaderExchangeServer</strong>&nbsp;。</p>
<h1 id="3-Client">3. Client</h1>
<p>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 服务引用（二）之远程引用（Dubbo）》</a>&nbsp;中，我们看到使用的 Client 实现类是&nbsp;<strong>ReferenceCountExchangeClient</strong>&nbsp;和&nbsp;<strong>LazyConnectExchangeClient</strong>&nbsp;。</p>
<h1 id="4-ExchangeHandler">4. ExchangeHandler</h1>
<p>在 DubboProtocol 中，实现了 ExchangeHandler ，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() {</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">        <span class="comment">// ... 省略具体实现</span></span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">        <span class="comment">// ... 省略具体实现</span></span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">        <span class="keyword">this</span>.invoke(channel, Constants.ON_CONNECT_KEY);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">        <span class="comment">// ... 省略具体实现</span></span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Channel channel, String methodKey)</span> </span>{</span><br /><span class="line">        <span class="comment">// ... 省略具体实现</span></span><br /><span class="line">    }</span><br /><br /><span class="line">};</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p>这个处理器，负责将请求，<strong>转发到对应的 Invoker 对象</strong>，执行逻辑，返回结果。<br />当然，本文不细分享，放在&nbsp;<strong>同步调用</strong>&nbsp;一文详细解析。</p>
<h1 id="5-Codec">5. Codec</h1>
<p>在&nbsp;<a href="https://github.com/apache/incubator-dubbo/blob/master/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/codec/ExchangeCodec.java" target="_blank" rel="external nofollow noopener noreferrer">ExchangeCodec</a>&nbsp;中，我们看到对 Request 和 Response 的<strong>通用</strong>解析。但是它是<strong>不满足</strong>在&nbsp;<code>dubbo://</code>&nbsp;协议中，对&nbsp;<a href="http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/">RpcInvocation</a>&nbsp;和&nbsp;<a href="http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/">RpcResult</a>&nbsp;作为&nbsp;<strong>内容体( Body )</strong>&nbsp;的编解码的需要的。</p>
<p>另外，在&nbsp;<code>dubbo://</code>&nbsp;协议中，支持&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/callback-parameter.html" target="_blank" rel="external nofollow noopener noreferrer">参数回调</a>&nbsp;的特性，也是需要在编解码做一些<strong>特殊逻辑</strong>。</p>
<p>下面，让我们来一起瞅瞅代码实现吧。</p>
<h2 id="5-1-DubboCountCodec">5.1 DubboCountCodec</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboCountCodec.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec</code></a>&nbsp;，实现 Codec2 接口，支持<strong>多消息</strong>的编解码器。</p>
<h3 id="5-1-1-构造方法">5.1.1 构造方法</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 编解码器</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> DubboCodec codec = <span class="keyword">new</span> DubboCodec();</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>在 Dubbo Client 和 Server 创建的过程，我们看到设置了编解码器为&nbsp;<code>"dubbo"</code>&nbsp;，从而通过 Dubbo SPI 机制，加载到 DubboCountCodec 。相关内容如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboProtocol#createServer(...)</span></span><br /><span class="line">url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br /><br /><span class="line"><span class="comment">// DubboProtocol#initClient(...)</span></span><br /><span class="line">url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br /><br /><span class="line"><span class="comment">// META-INF/dubbo/internal/com.alibaba.dubbo.remoting.Codec2</span></span><br /><span class="line">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>实际编解码的逻辑，使用 DubboCodec ，即&nbsp;<code>codec</code>&nbsp;属性。</p>
</li>
</ul>
<h3 id="5-1-2-编码">5.1.2 编码</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line">    codec.encode(channel, buffer, msg);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="5-1-3-解码">5.1.3 解码</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 记录当前读位置</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">int</span> save = buffer.readerIndex();</span><br /><span class="line"> <span class="number">5</span>:     <span class="comment">// 创建 MultiMessage 对象</span></span><br /><span class="line"> <span class="number">6</span>:     MultiMessage result = MultiMessage.create();</span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">do</span> {</span><br /><span class="line"> <span class="number">8</span>:         <span class="comment">// 解码</span></span><br /><span class="line"> <span class="number">9</span>:         Object obj = codec.decode(channel, buffer);</span><br /><span class="line"><span class="number">10</span>:         <span class="comment">// 输入不够，重置读进度</span></span><br /><span class="line"><span class="number">11</span>:         <span class="keyword">if</span> (Codec2.DecodeResult.NEED_MORE_INPUT == obj) {</span><br /><span class="line"><span class="number">12</span>:             buffer.readerIndex(save);</span><br /><span class="line"><span class="number">13</span>:             <span class="keyword">break</span>;</span><br /><span class="line"><span class="number">14</span>:         <span class="comment">// 解析到消息</span></span><br /><span class="line"><span class="number">15</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">16</span>:             <span class="comment">// 添加结果消息</span></span><br /><span class="line"><span class="number">17</span>:             result.addMessage(obj);</span><br /><span class="line"><span class="number">18</span>:             <span class="comment">// 记录消息长度到隐式参数集合，用于 MonitorFilter 监控</span></span><br /><span class="line"><span class="number">19</span>:             logMessageLength(obj, buffer.readerIndex() - save);</span><br /><span class="line"><span class="number">20</span>:             <span class="comment">// 记录当前读位置</span></span><br /><span class="line"><span class="number">21</span>:             save = buffer.readerIndex();</span><br /><span class="line"><span class="number">22</span>:         }</span><br /><span class="line"><span class="number">23</span>:     } <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br /><span class="line"><span class="number">24</span>:     <span class="comment">// 需要更多的输入</span></span><br /><span class="line"><span class="number">25</span>:     <span class="keyword">if</span> (result.isEmpty()) {</span><br /><span class="line"><span class="number">26</span>:         <span class="keyword">return</span> Codec2.DecodeResult.NEED_MORE_INPUT;</span><br /><span class="line"><span class="number">27</span>:     }</span><br /><span class="line"><span class="number">28</span>:     <span class="comment">// 返回解析到的消息</span></span><br /><span class="line"><span class="number">29</span>:     <span class="keyword">if</span> (result.size() == <span class="number">1</span>) {</span><br /><span class="line"><span class="number">30</span>:         <span class="keyword">return</span> result.get(<span class="number">0</span>);</span><br /><span class="line"><span class="number">31</span>:     }</span><br /><span class="line"><span class="number">32</span>:     <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">33</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>包含两块逻辑：1）多消息解析的支持。2）记录每条消息的长度，用于 MonitorFilter 监控。</li>
<li>第 4 行：记录当前读位置，用于下面计算每条消息的长度。</li>
<li>第 6 行：创建 MultiMessage 对象。MultiMessageHandler 支持对它的处理分发。</li>
<li>第 7 至 23 行：<strong>循环</strong>解析消息，直到结束。</li>
<li>第 9 行：调用&nbsp;<code>DubboCodec#decode(channel, buffer)</code>&nbsp;方法，解码。</li>
<li>第 11 至 13 行：字节数组不够，重置读进度，结束解析。</li>
<li>
<p>第 15 至 22 行：解析到消息，添加到&nbsp;<code>result</code>&nbsp;。</p>
<ul>
<li>
<p>第 19 行：调用&nbsp;<code>#logMessageLength(obj, length)</code>&nbsp;方法，记录消息长度到<strong>隐式参数集合</strong>，用于 MonitorFilter 监控。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logMessageLength</span><span class="params">(Object result, <span class="keyword">int</span> bytes)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (bytes &lt;= <span class="number">0</span>) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Request) {</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            ((RpcInvocation) ((Request) result).getData()).setAttachment(Constants.INPUT_KEY, String.valueOf(bytes)); <span class="comment">// 请求</span></span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">            <span class="comment">/* ignore */</span></span><br /><span class="line">        }</span><br /><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Response) {</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            ((RpcResult) ((Response) result).getResult()).setAttachment(Constants.OUTPUT_KEY, String.valueOf(bytes)); <span class="comment">// 响应</span></span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">            <span class="comment">/* ignore */</span></span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>x</li>
</ul>
</li>
<li>第 21 行：记录当前读位置，用于计算<strong>下一条</strong>消息的长度。</li>
</ul>
</li>
<li>第 24 至 27 行：需要更多的输入。</li>
<li>第 28 至 32 行：返回结果。</li>
</ul>
<h2 id="5-2-DubboCodec">5.2 DubboCodec</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboCountCodec.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec</code></a>&nbsp;，实现 Codec2 接口，继承 ExchangeCodec 类，<strong>Dubbo 编解码器</strong>实现类。</p>
<h3 id="5-2-1-构造方法">5.2.1 构造方法</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 协议名</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"dubbo"</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 协议版本</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_VERSION = Version.getVersion(DubboCodec.class, Version.getVersion());</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 响应 - 异常</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> RESPONSE_WITH_EXCEPTION = <span class="number">0</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 响应 - 正常（空返回）</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> RESPONSE_VALUE = <span class="number">1</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 响应 - 正常（有返回）</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> RESPONSE_NULL_VALUE = <span class="number">2</span>;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 方法参数 - 空（参数）</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_OBJECT_ARRAY = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 方法参数 - 空（类型）</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>];</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="5-2-2-编码内容体">5.2.2 编码内容体</h3>
<h4 id="5-2-2-1-请求">5.2.2.1 请求</h4>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequestData</span><span class="params">(Channel channel, ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line"> <span class="number">3</span>:     RpcInvocation inv = (RpcInvocation) data;</span><br /><span class="line"> <span class="number">4</span>: </span><br /><span class="line"> <span class="number">5</span>:     <span class="comment">// 写入 `dubbo` `path` `version`</span></span><br /><span class="line"> <span class="number">6</span>:     out.writeUTF(inv.getAttachment(Constants.DUBBO_VERSION_KEY, DUBBO_VERSION));</span><br /><span class="line"> <span class="number">7</span>:     out.writeUTF(inv.getAttachment(Constants.PATH_KEY));</span><br /><span class="line"> <span class="number">8</span>:     out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));</span><br /><span class="line"> <span class="number">9</span>: </span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// 写入方法、方法签名、方法参数集合</span></span><br /><span class="line"><span class="number">11</span>:     out.writeUTF(inv.getMethodName());</span><br /><span class="line"><span class="number">12</span>:     out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));</span><br /><span class="line"><span class="number">13</span>:     Object[] args = inv.getArguments();</span><br /><span class="line"><span class="number">14</span>:     <span class="keyword">if</span> (args != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">15</span>:         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br /><span class="line"><span class="number">16</span>:             out.writeObject(CallbackServiceCodec.encodeInvocationArgument(channel, inv, i));</span><br /><span class="line"><span class="number">17</span>:         }</span><br /><span class="line"><span class="number">18</span>:     }</span><br /><span class="line"><span class="number">19</span>: </span><br /><span class="line"><span class="number">20</span>:     <span class="comment">// 写入隐式传参集合</span></span><br /><span class="line"><span class="number">21</span>:     out.writeObject(inv.getAttachments());</span><br /><span class="line"><span class="number">22</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>🙂 胖友看下代码注释。</li>
<li>编码 RpcInvocation 对象，写入需要编码的字段。</li>
<li>对应的解码，在 DecodeableRpcInvocation 中。</li>
<li>第 16 行：调用&nbsp;<code>CallbackServiceCodec#encodeInvocationArgument(...)</code>&nbsp;方法，编码参数。主要用于&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/callback-parameter.html" target="_blank" rel="external nofollow noopener noreferrer">参数回调</a>&nbsp;功能，后面的文章，详细解析。</li>
</ul>
<h4 id="5-2-2-2-响应">5.2.2.2 响应</h4>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeResponseData</span><span class="params">(Channel channel, ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line"> <span class="number">3</span>:     Result result = (Result) data;</span><br /><span class="line"> <span class="number">4</span>: </span><br /><span class="line"> <span class="number">5</span>:     Throwable th = result.getException();</span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// 正常</span></span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (th == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">8</span>:         Object ret = result.getValue();</span><br /><span class="line"> <span class="number">9</span>:         <span class="comment">// 空返回</span></span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">if</span> (ret == <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">11</span>:             out.writeByte(RESPONSE_NULL_VALUE);</span><br /><span class="line"><span class="number">12</span>:         <span class="comment">// 有返回</span></span><br /><span class="line"><span class="number">13</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">14</span>:             out.writeByte(RESPONSE_VALUE);</span><br /><span class="line"><span class="number">15</span>:             out.writeObject(ret);</span><br /><span class="line"><span class="number">16</span>:         }</span><br /><span class="line"><span class="number">17</span>:     <span class="comment">// 异常</span></span><br /><span class="line"><span class="number">18</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">19</span>:         out.writeByte(RESPONSE_WITH_EXCEPTION);</span><br /><span class="line"><span class="number">20</span>:         out.writeObject(th);</span><br /><span class="line"><span class="number">21</span>:     }</span><br /><span class="line"><span class="number">22</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>🙂 胖友看下代码注释。</li>
<li>编码 Result 对象，写入需要编码的字段。</li>
<li>对应的解码，在 DecodeableRpcResult 中。</li>
</ul>
<h3 id="5-2-3-解码内容体">5.2.3 解码内容体</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">byte</span> flag = header[<span class="number">2</span>];</span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">// 获得 Serialization 对象</span></span><br /><span class="line"> <span class="number">5</span>:     <span class="keyword">byte</span> proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br /><span class="line"> <span class="number">6</span>:     Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);</span><br /><span class="line"> <span class="number">7</span>:     <span class="comment">// 获得请求||响应编号</span></span><br /><span class="line"> <span class="number">8</span>:     <span class="comment">// get request id.</span></span><br /><span class="line"> <span class="number">9</span>:     <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);</span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// 解析响应</span></span><br /><span class="line"><span class="number">11</span>:     <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) {</span><br /><span class="line"><span class="number">12</span>:         <span class="comment">// decode response.</span></span><br /><span class="line"><span class="number">13</span>:         Response res = <span class="keyword">new</span> Response(id);</span><br /><span class="line"><span class="number">14</span>:         <span class="comment">// ... 省略代码</span></span><br /><span class="line"><span class="number">15</span>:         <span class="keyword">return</span> res;</span><br /><span class="line"><span class="number">16</span>:     <span class="comment">// 解析请求</span></span><br /><span class="line"><span class="number">17</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">18</span>:         <span class="comment">// decode request.</span></span><br /><span class="line"><span class="number">19</span>:         Request req = <span class="keyword">new</span> Request(id);</span><br /><span class="line"><span class="number">20</span>:         <span class="comment">// ... 省略代码</span></span><br /><span class="line"><span class="number">21</span>:         <span class="keyword">return</span> req;</span><br /><span class="line"><span class="number">22</span>:     }</span><br /><span class="line"><span class="number">23</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 4 至 6 行：调用&nbsp;<code>CodeSupport#getSerialization(url, proto)</code>&nbsp;方法，获得 Serialization 对象，用于下面反序列化内容体的每个字段。</li>
<li>第 9 行：获得请求或响应的编号。</li>
<li>第 10 至 15 行：解析响应( Response )。</li>
<li>第 16 至 22 行：解析请求( Request )。</li>
</ul>
<h4 id="5-2-3-1-请求">5.2.3.1 请求</h4>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">// decode response.</span></span><br /><span class="line"> <span class="number">2</span>: Response res = <span class="keyword">new</span> Response(id);</span><br /><span class="line"> <span class="number">3</span>: <span class="comment">// 若是心跳事件，进行设置</span></span><br /><span class="line"> <span class="number">4</span>: <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">5</span>:     res.setEvent(Response.HEARTBEAT_EVENT);</span><br /><span class="line"> <span class="number">6</span>: }</span><br /><span class="line"> <span class="number">7</span>: <span class="comment">// 设置状态</span></span><br /><span class="line"> <span class="number">8</span>: <span class="comment">// get status.</span></span><br /><span class="line"> <span class="number">9</span>: <span class="keyword">byte</span> status = header[<span class="number">3</span>];</span><br /><span class="line"><span class="number">10</span>: res.setStatus(status);</span><br /><span class="line"><span class="number">11</span>: <span class="comment">// 正常响应状态</span></span><br /><span class="line"><span class="number">12</span>: <span class="keyword">if</span> (status == Response.OK) {</span><br /><span class="line"><span class="number">13</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">14</span>:         Object data;</span><br /><span class="line"><span class="number">15</span>:         <span class="comment">// 解码心跳事件</span></span><br /><span class="line"><span class="number">16</span>:         <span class="keyword">if</span> (res.isHeartbeat()) {</span><br /><span class="line"><span class="number">17</span>:             data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));</span><br /><span class="line"><span class="number">18</span>:         <span class="comment">// 解码其它事件</span></span><br /><span class="line"><span class="number">19</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (res.isEvent()) {</span><br /><span class="line"><span class="number">20</span>:             data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));</span><br /><span class="line"><span class="number">21</span>:         <span class="comment">// 解码普通响应</span></span><br /><span class="line"><span class="number">22</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">23</span>:             DecodeableRpcResult result;</span><br /><span class="line"><span class="number">24</span>:             <span class="comment">// 在通信框架（例如，Netty）的 IO 线程，解码</span></span><br /><span class="line"><span class="number">25</span>:             <span class="keyword">if</span> (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) {</span><br /><span class="line"><span class="number">26</span>:                 result = <span class="keyword">new</span> DecodeableRpcResult(channel, res, is, (Invocation) getRequestData(id), proto);</span><br /><span class="line"><span class="number">27</span>:                 result.decode();</span><br /><span class="line"><span class="number">28</span>:             <span class="comment">// 在 Dubbo ThreadPool 线程，解码，使用 DecodeHandler</span></span><br /><span class="line"><span class="number">29</span>:             } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">30</span>:                 result = <span class="keyword">new</span> DecodeableRpcResult(channel, res, <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), (Invocation) getRequestData(id), proto);</span><br /><span class="line"><span class="number">31</span>:             }</span><br /><span class="line"><span class="number">32</span>:             data = result;</span><br /><span class="line"><span class="number">33</span>:         }</span><br /><span class="line"><span class="number">34</span>:         <span class="comment">// 设置结果</span></span><br /><span class="line"><span class="number">35</span>:         res.setResult(data);</span><br /><span class="line"><span class="number">36</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">37</span>:         <span class="keyword">if</span> (log.isWarnEnabled()) {</span><br /><span class="line"><span class="number">38</span>:             log.warn(<span class="string">"Decode response failed: "</span> + t.getMessage(), t);</span><br /><span class="line"><span class="number">39</span>:         }</span><br /><span class="line"><span class="number">40</span>:         res.setStatus(Response.CLIENT_ERROR);</span><br /><span class="line"><span class="number">41</span>:         res.setErrorMessage(StringUtils.toString(t));</span><br /><span class="line"><span class="number">42</span>:     }</span><br /><span class="line"><span class="number">43</span>: <span class="comment">// 异常响应状态</span></span><br /><span class="line"><span class="number">44</span>: } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">45</span>:     res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());</span><br /><span class="line"><span class="number">46</span>: }</span><br /><span class="line"><span class="number">47</span>: <span class="keyword">return</span> res;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>🙂 胖友看下代码注释。我们重点讲下可能<strong>比较绕</strong>的地方。</li>
<li>第 21 至 33 行：解码普通响应。我们可以看到代码分成【第 25 至 27 行】【第 28 至 31 行】<strong>两段</strong>。
<ul>
<li>相同点，使用&nbsp;<strong>DecodeableRpcResult</strong>&nbsp;解码。前者，比较好理解，【第 27 行】已经调用；后者，在 DecodeHandler 中，才最终调用&nbsp;<code>DecodeableRpcResult#decode()</code>&nbsp;方法。</li>
<li>差异点，使用<strong>哪个线程</strong>解码。前者，还是比较好理解，当前线程，即通信框架（例如，Netty）的 IO 线程。后者，Dubbo ThreadPool 线程中。</li>
<li><code>decode.in.io</code>&nbsp;配置项，目前在 Dubbo 文档中，并未说明，应该是<strong>性能调优</strong>，具体笔者还没测试过。嘿嘿。</li>
</ul>
</li>
</ul>
<h4 id="5-2-3-2-响应">5.2.3.2 响应</h4>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">// decode request.</span></span><br /><span class="line"> <span class="number">2</span>: Request req = <span class="keyword">new</span> Request(id);</span><br /><span class="line"> <span class="number">3</span>: req.setVersion(<span class="string">"2.0.0"</span>);</span><br /><span class="line"> <span class="number">4</span>: <span class="comment">// 是否需要响应</span></span><br /><span class="line"> <span class="number">5</span>: req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="number">0</span>);</span><br /><span class="line"> <span class="number">6</span>: <span class="comment">// 若是心跳事件，进行设置</span></span><br /><span class="line"> <span class="number">7</span>: <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">8</span>:     req.setEvent(Request.HEARTBEAT_EVENT);</span><br /><span class="line"> <span class="number">9</span>: }</span><br /><span class="line"><span class="number">10</span>: <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">11</span>:     Object data;</span><br /><span class="line"><span class="number">12</span>:     <span class="comment">// 解码心跳事件</span></span><br /><span class="line"><span class="number">13</span>:     <span class="keyword">if</span> (req.isHeartbeat()) {</span><br /><span class="line"><span class="number">14</span>:         data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));</span><br /><span class="line"><span class="number">15</span>:     <span class="comment">// 解码其它事件</span></span><br /><span class="line"><span class="number">16</span>:     } <span class="keyword">else</span> <span class="keyword">if</span> (req.isEvent()) {</span><br /><span class="line"><span class="number">17</span>:         data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));</span><br /><span class="line"><span class="number">18</span>:     <span class="comment">// 解码普通请求</span></span><br /><span class="line"><span class="number">19</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">20</span>:         <span class="comment">// 在通信框架（例如，Netty）的 IO 线程，解码</span></span><br /><span class="line"><span class="number">21</span>:         DecodeableRpcInvocation inv;</span><br /><span class="line"><span class="number">22</span>:         <span class="keyword">if</span> (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) {</span><br /><span class="line"><span class="number">23</span>:             inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req, is, proto);</span><br /><span class="line"><span class="number">24</span>:             inv.decode();</span><br /><span class="line"><span class="number">25</span>:         <span class="comment">// 在 Dubbo ThreadPool 线程，解码，使用 DecodeHandler</span></span><br /><span class="line"><span class="number">26</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">27</span>:             inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req, <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);</span><br /><span class="line"><span class="number">28</span>:         }</span><br /><span class="line"><span class="number">29</span>:         data = inv;</span><br /><span class="line"><span class="number">30</span>:     }</span><br /><span class="line"><span class="number">31</span>:     req.setData(data);</span><br /><span class="line"><span class="number">32</span>: } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">33</span>:     <span class="keyword">if</span> (log.isWarnEnabled()) {</span><br /><span class="line"><span class="number">34</span>:         log.warn(<span class="string">"Decode request failed: "</span> + t.getMessage(), t);</span><br /><span class="line"><span class="number">35</span>:     }</span><br /><span class="line"><span class="number">36</span>:     <span class="comment">// bad request</span></span><br /><span class="line"><span class="number">37</span>:     req.setBroken(<span class="keyword">true</span>);</span><br /><span class="line"><span class="number">38</span>:     req.setData(t);</span><br /><span class="line"><span class="number">39</span>: }</span><br /><span class="line"><span class="number">40</span>: <span class="keyword">return</span> req;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>和&nbsp;<a href="http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/">「5.2.3.1 请求」</a>&nbsp;<strong>类似</strong>，差异点在使用&nbsp;<strong>DecodeableRpcInvocation</strong>&nbsp;。</li>
<li>🙂 胖友看下代码注释。</li>
</ul>
<h2 id="5-3-DecodeableRpcInvocation">5.3 DecodeableRpcInvocation</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation</code></a>&nbsp;，实现 Codec 和 Decodeable 接口，继承 RpcInvocation 类，<strong>可解码</strong>的 RpcInvocation 实现类。</p>
<p>当服务消费者，调用服务提供者，前者编码的 RpcInvocation 对象，后者解码成 DecodeableRpcInvocation 对象。</p>
<p>从目前的代码实现来看，Codec 接口，可不实现。</p>
<h3 id="5-3-1-构造方法">5.3.1 构造方法</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 通道</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Channel channel;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Serialization 类型编号</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span> serializationType;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 输入流</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> InputStream inputStream;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 请求</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Request request;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否已经解码完成</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasDecoded;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="5-3-2-解码">5.3.2 解码</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            decode(channel, inputStream);</span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) {</span><br /><span class="line">                log.warn(<span class="string">"Decode rpc invocation failed: "</span> + e.getMessage(), e);</span><br /><span class="line">            }</span><br /><span class="line">            request.setBroken(<span class="keyword">true</span>);</span><br /><span class="line">            request.setData(e);</span><br /><span class="line">        } <span class="keyword">finally</span> {</span><br /><span class="line">            hasDecoded = <span class="keyword">true</span>;</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line">    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input);</span><br /><br /><span class="line">    <span class="comment">// 解码 `dubbo` `path` `version`</span></span><br /><span class="line">    setAttachment(Constants.DUBBO_VERSION_KEY, in.readUTF());</span><br /><span class="line">    setAttachment(Constants.PATH_KEY, in.readUTF());</span><br /><span class="line">    setAttachment(Constants.VERSION_KEY, in.readUTF());</span><br /><br /><span class="line">    <span class="comment">// 解码方法、方法签名、方法参数集合</span></span><br /><span class="line">    setMethodName(in.readUTF());</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        Object[] args;</span><br /><span class="line">        Class&lt;?&gt;[] pts;</span><br /><span class="line">        String desc = in.readUTF();</span><br /><span class="line">        <span class="keyword">if</span> (desc.length() == <span class="number">0</span>) {</span><br /><span class="line">            pts = DubboCodec.EMPTY_CLASS_ARRAY;</span><br /><span class="line">            args = DubboCodec.EMPTY_OBJECT_ARRAY;</span><br /><span class="line">        } <span class="keyword">else</span> {</span><br /><span class="line">            pts = ReflectUtils.desc2classArray(desc);</span><br /><span class="line">            args = <span class="keyword">new</span> Object[pts.length];</span><br /><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br /><span class="line">                <span class="keyword">try</span> {</span><br /><span class="line">                    args[i] = in.readObject(pts[i]);</span><br /><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">                    <span class="keyword">if</span> (log.isWarnEnabled()) {</span><br /><span class="line">                        log.warn(<span class="string">"Decode argument failed: "</span> + e.getMessage(), e);</span><br /><span class="line">                    }</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        setParameterTypes(pts);</span><br /><br /><span class="line">        <span class="comment">// 解码隐式传参集合</span></span><br /><span class="line">        Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map.class);</span><br /><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span> &amp;&amp; map.size() &gt; <span class="number">0</span>) {</span><br /><span class="line">            Map&lt;String, String&gt; attachment = getAttachments();</span><br /><span class="line">            <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) {</span><br /><span class="line">                attachment = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br /><span class="line">            }</span><br /><span class="line">            attachment.putAll(map);</span><br /><span class="line">            setAttachments(attachment);</span><br /><span class="line">        }</span><br /><br /><span class="line">        <span class="comment">// 进一步解码方法参数，主要为了参数返回</span></span><br /><span class="line">        <span class="comment">// decode argument ,may be callback</span></span><br /><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br /><span class="line">            args[i] = CallbackServiceCodec.decodeInvocationArgument(channel, <span class="keyword">this</span>, pts, i, args[i]);</span><br /><span class="line">        }</span><br /><span class="line">        setArguments(args);</span><br /><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read invocation data failed."</span>, e));</span><br /><span class="line">    } <span class="keyword">finally</span> {</span><br /><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) {</span><br /><span class="line">            ((Cleanable) in).cleanup();</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>🙂 胖友看下代码注释。</li>
</ul>
<h2 id="5-4-DecodeableRpcResult">5.4 DecodeableRpcResult</h2>
<blockquote>
<p>和 DecodeableRpcInvocation 一致。</p>
</blockquote>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcResult</code></a>&nbsp;，实现 Codec 和 Decodeable 接口，继承 RpcResult 类，<strong>可解码</strong>的 RpcResult 实现类。</p>
<p>当服务提供者者，返回服务消费者调用结果，前者编码的 RpcResult 对象，后者解码成 DecodeableRpcResult 对象。</p>
<p>从目前的代码实现来看，Codec 接口，可不实现。</p>
<h3 id="5-4-1-构造方法">5.4.1 构造方法</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 通道</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Channel channel;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Serialization 类型编号</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span> serializationType;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 输入流</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> InputStream inputStream;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 请求</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Response response;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Invocation 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Invocation invocation;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否已经解码完成</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasDecoded;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="5-4-2-解码">5.4.2 解码</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            decode(channel, inputStream);</span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) {</span><br /><span class="line">                log.warn(<span class="string">"Decode rpc result failed: "</span> + e.getMessage(), e);</span><br /><span class="line">            }</span><br /><span class="line">            response.setStatus(Response.CLIENT_ERROR);</span><br /><span class="line">            response.setErrorMessage(StringUtils.toString(e));</span><br /><span class="line">        } <span class="keyword">finally</span> {</span><br /><span class="line">            hasDecoded = <span class="keyword">true</span>;</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line">    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input);</span><br /><br /><span class="line">    <span class="comment">// 读取标记位</span></span><br /><span class="line">    <span class="keyword">byte</span> flag = in.readByte();</span><br /><span class="line">    <span class="keyword">switch</span> (flag) {</span><br /><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE: <span class="comment">// 无返回值</span></span><br /><span class="line">            <span class="keyword">break</span>;</span><br /><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE: <span class="comment">// 有返回值</span></span><br /><span class="line">            <span class="keyword">try</span> {</span><br /><span class="line">                Type[] returnType = RpcUtils.getReturnTypes(invocation);</span><br /><span class="line">                setValue(returnType == <span class="keyword">null</span> || returnType.length == <span class="number">0</span> ? in.readObject() :</span><br /><span class="line">                        (returnType.length == <span class="number">1</span> ? in.readObject((Class&lt;?&gt;) returnType[<span class="number">0</span>])</span><br /><span class="line">                                <span class="comment">// 返回结果:Type[]{method.getReturnType(), method.getGenericReturnType()}</span></span><br /><span class="line">                                : in.readObject((Class&lt;?&gt;) returnType[<span class="number">0</span>], returnType[<span class="number">1</span>])));</span><br /><span class="line">            } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br /><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br /><span class="line">            }</span><br /><span class="line">            <span class="keyword">break</span>;</span><br /><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION: <span class="comment">// 异常</span></span><br /><span class="line">            <span class="keyword">try</span> {</span><br /><span class="line">                Object obj = in.readObject();</span><br /><span class="line">                <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Throwable)) {</span><br /><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Response data error, expect Throwable, but get "</span> + obj);</span><br /><span class="line">                }</span><br /><span class="line">                setException((Throwable) obj);</span><br /><span class="line">            } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br /><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br /><span class="line">            }</span><br /><span class="line">            <span class="keyword">break</span>;</span><br /><span class="line">        <span class="keyword">default</span>:</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unknown result flag, expect '0' '1' '2', get "</span> + flag);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) {</span><br /><span class="line">        ((Cleanable) in).cleanup();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>🙂 胖友看下代码注释。</li>
</ul>
</div>