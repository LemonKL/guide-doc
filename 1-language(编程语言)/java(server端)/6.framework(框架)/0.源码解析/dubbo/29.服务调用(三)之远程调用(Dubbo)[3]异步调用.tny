<header class="article-header">
<h1 class="article-title">服务调用（三）之远程调用（Dubbo）【3】异步调用</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>本文分享&nbsp;<code>dubbo://</code>&nbsp;协议的远程调用的<strong>第三部分：异步调用</strong>。</p>
<p>对应&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/events-notify.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 事件通知》</a>&nbsp;文档。定义如下：</p>
<blockquote>
<p>在调用之前、调用之后、出现异常时，会触发&nbsp;<code>oninvoke</code>、<code>onreturn</code>、<code>onthrow</code>&nbsp;三个事件，可以配置当事件发生时，通知哪个类的哪个方法。</p>
</blockquote>
<p>看完定义，是不是有点疑惑，和本文的标题仿佛有些出入？相信自己，你是对的，标题是不严谨的，&ldquo;错误&rdquo;点如下：</p>
<ul>
<li><code>oninvoke</code>&nbsp;配置项，设置服务消费者<strong>调用</strong>服务提供者<strong>之前</strong>，执行前置方法，类似 AOP 的&nbsp;<code>#beforeMethod(...)</code>&nbsp;方法。</li>
<li><code>onreturn</code>&nbsp;和&nbsp;<code>onthrow</code>&nbsp;配置项，设置服务消费者<strong>调用</strong>服务提供者<strong>之后</strong>，执行后置方法，类似 AOP 的&nbsp;<code>#afterMethod(...)</code>&nbsp;方法。有一点我们需要注意，一开始笔者理解错了，并非只有&nbsp;<code>async = true</code>&nbsp;，异步调用才支持回调，同步调用和单向调用也支持回调。</li>
</ul>
<p>具体的调用，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/rpc-dubbo-2-sync/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 服务调用（二）之远程调用（Dubbo）【2】同步调用》「3. 消费者调用服务」</a>&nbsp;中，我们已经看到调用的代码。如果胖友没看过，建议先去看看。</p>
<h1 id="2-FutureAdapter">2. FutureAdapter</h1>
<p><a href="http://svip.iocoder.cn/Dubbo/rpc-dubbo-3-async/todo"><code>com.alibaba.dubbo.rpc.protocol.dubbo.FutureAdapter</code></a>&nbsp;，实现 Future 接口，适配 ResponseFuture 。通过这样的方式，对上层调用方，<strong>透明</strong>化 ResponseFuture 的存在。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code" style="background-color: #813799;">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureAdapter</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResponseFuture future;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureAdapter</span><span class="params">(ResponseFuture future)</span> </span>{</span><br /><span class="line">        <span class="keyword">this</span>.future = future;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">getFuture</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> future;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> future.isDone();</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br /><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>{</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="keyword">return</span> (V) (((Result) future.get()).recreate());</span><br /><span class="line">        } <span class="keyword">catch</span> (RemotingException e) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(e.getMessage(), e);</span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br /><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>{</span><br /><span class="line">        <span class="keyword">int</span> timeoutInMillis = (<span class="keyword">int</span>) unit.convert(timeout, TimeUnit.MILLISECONDS);</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="keyword">return</span> (V) (((Result) future.get(timeoutInMillis)).recreate());</span><br /><span class="line">        } <span class="keyword">catch</span> (com.alibaba.dubbo.remoting.TimeoutException e) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(StringUtils.toString(e));</span><br /><span class="line">        } <span class="keyword">catch</span> (RemotingException e) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(e.getMessage(), e);</span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="3-FutureFilter">3. FutureFilter</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.dubbo.filte.FutureFilter</code></a>&nbsp;，实现 Filter 接口，事件通知过滤器。实现代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Activate</span>(group = Constants.CONSUMER)</span><br /><span class="line"> <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>{</span><br /><span class="line"> <span class="number">3</span>: </span><br /><span class="line"> <span class="number">4</span>:     <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">5</span>:     <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; invoker, <span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">6</span>:         <span class="comment">// 获得是否异步调用</span></span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">final</span> <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(invoker.getUrl(), invocation);</span><br /><span class="line"> <span class="number">8</span>: </span><br /><span class="line"> <span class="number">9</span>:         <span class="comment">// 触发前置方法</span></span><br /><span class="line"><span class="number">10</span>:         fireInvokeCallback(invoker, invocation);</span><br /><span class="line"><span class="number">11</span>:         <span class="comment">// need to configure if there's return value before the invocation in order to help invoker to judge if it's</span></span><br /><span class="line"><span class="number">12</span>:         <span class="comment">// necessary to return future.</span></span><br /><span class="line"><span class="number">13</span>:         <span class="comment">// 调用方法</span></span><br /><span class="line"><span class="number">14</span>:         Result result = invoker.invoke(invocation);</span><br /><span class="line"><span class="number">15</span>: </span><br /><span class="line"><span class="number">16</span>:         <span class="comment">// 触发回调方法</span></span><br /><span class="line"><span class="number">17</span>:         <span class="keyword">if</span> (isAsync) { <span class="comment">// 异步回调</span></span><br /><span class="line"><span class="number">18</span>:             asyncCallback(invoker, invocation);</span><br /><span class="line"><span class="number">19</span>:         } <span class="keyword">else</span> { <span class="comment">// 同步回调</span></span><br /><span class="line"><span class="number">20</span>:             syncCallback(invoker, invocation, result);</span><br /><span class="line"><span class="number">21</span>:         }</span><br /><span class="line"><span class="number">22</span>:         <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">23</span>:     }</span><br /><span class="line"><span class="number">24</span>:     </span><br /><span class="line"><span class="number">25</span>:     <span class="comment">// ... 省略部分方法</span></span><br /><span class="line"><span class="number">26</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>@Activate(group = Constants.CONSUMER)</code>&nbsp;注解，基于 Dubbo SPI Activate 机制，只有<strong>服务消费者</strong>才生效该过滤器。</li>
<li>第 7 行：调用&nbsp;<code>RpcUtils#isAsync(url, invocation)</code>&nbsp;方法，判断是否异步调用。</li>
<li>第 10 行：调用&nbsp;<code>#fireInvokeCallback(invoker, invocation)</code>&nbsp;方法，触发前置方法。</li>
<li>第 14 行：调用&nbsp;<code>invoker#invoke(invocation)</code>&nbsp;方法，调用<strong>服务提供者</strong>，即 Dubbo RPC 。</li>
<li>第 16 至 21 行：触发回调方法。
<ul>
<li>第 17 至 18 行：若<strong>是</strong>异步调用，调用&nbsp;<code>#asyncCallback(invoker, invocation)</code>&nbsp;方法，执行异步回调。</li>
<li>第 19 至 21 行：若<strong>非</strong>异步调用，调用&nbsp;<code>#syncCallback(invoker, invocation)</code>&nbsp;方法，执行同步回调。</li>
</ul>
</li>
<li>第 22 行：返回结果。如果是异步调用或单向调用，所以返回结果是<strong>空</strong>的。</li>
</ul>
<h2 id="3-1-fireInvokeCallback">3.1 fireInvokeCallback</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 触发前置方法</span></span><br /><span class="line"><span class="comment"> 3:  *</span></span><br /><span class="line"><span class="comment"> 4:  * <span class="doctag">@param</span> invoker Invoker 对象</span></span><br /><span class="line"><span class="comment"> 5:  * <span class="doctag">@param</span> invocation Invocation 对象</span></span><br /><span class="line"><span class="comment"> 6:  */</span></span><br /><span class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireInvokeCallback</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; invoker, <span class="keyword">final</span> Invocation invocation)</span> </span>{</span><br /><span class="line"> <span class="number">8</span>:     <span class="comment">// 获得前置方法和对象</span></span><br /><span class="line"> <span class="number">9</span>:     <span class="keyword">final</span> Method onInvokeMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_METHOD_KEY));</span><br /><span class="line"><span class="number">10</span>:     <span class="keyword">final</span> Object onInvokeInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_INSTANCE_KEY));</span><br /><span class="line"><span class="number">11</span>:     <span class="keyword">if</span> (onInvokeMethod == <span class="keyword">null</span> &amp;&amp; onInvokeInst == <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">12</span>:         <span class="keyword">return</span>;</span><br /><span class="line"><span class="number">13</span>:     }</span><br /><span class="line"><span class="number">14</span>:     <span class="keyword">if</span> (onInvokeMethod == <span class="keyword">null</span> || onInvokeInst == <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">15</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"service:"</span> + invoker.getUrl().getServiceKey() + <span class="string">" has a onreturn callback config , but no such "</span> + (onInvokeMethod == <span class="keyword">null</span> ? <span class="string">"method"</span> : <span class="string">"instance"</span>) + <span class="string">" found. url:"</span> + invoker.getUrl());</span><br /><span class="line"><span class="number">16</span>:     }</span><br /><span class="line"><span class="number">17</span>:     <span class="keyword">if</span> (!onInvokeMethod.isAccessible()) {</span><br /><span class="line"><span class="number">18</span>:         onInvokeMethod.setAccessible(<span class="keyword">true</span>);</span><br /><span class="line"><span class="number">19</span>:     }</span><br /><span class="line"><span class="number">20</span>: </span><br /><span class="line"><span class="number">21</span>:     <span class="comment">// 调用前置方法</span></span><br /><span class="line"><span class="number">22</span>:     Object[] params = invocation.getArguments();</span><br /><span class="line"><span class="number">23</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">24</span>:         onInvokeMethod.invoke(onInvokeInst, params);</span><br /><span class="line"><span class="number">25</span>:     } <span class="keyword">catch</span> (InvocationTargetException e) {</span><br /><span class="line"><span class="number">26</span>:         fireThrowCallback(invoker, invocation, e.getTargetException());</span><br /><span class="line"><span class="number">27</span>:     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">28</span>:         fireThrowCallback(invoker, invocation, e);</span><br /><span class="line"><span class="number">29</span>:     }</span><br /><span class="line"><span class="number">30</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 8 至 19 行：获得前置方法和对象。StaticContext 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-api-3/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; API 配置（三）之服务消费者》</a>中，已经详细解析。</li>
<li>第 21 至 29 行：<strong>反射</strong>调用前置方法。</li>
</ul>
<h2 id="3-2-syncCallback">3.2 syncCallback</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 同步回调</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> invoker Invoker 对象</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> invocation Invocation 对象</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> result RPC 结果</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">syncCallback</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; invoker, <span class="keyword">final</span> Invocation invocation, <span class="keyword">final</span> Result result)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (result.hasException()) { <span class="comment">// 异常，触发异常回调</span></span><br /><span class="line">        fireThrowCallback(invoker, invocation, result.getException());</span><br /><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 正常，触发正常回调</span></span><br /><span class="line">        fireReturnCallback(invoker, invocation, result.getValue());</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>#fireThrowCallback(invoker, invocation, exception)</code>&nbsp;方法，触发异常回调方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireReturnCallback</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; invoker, <span class="keyword">final</span> Invocation invocation, <span class="keyword">final</span> Object result)</span> </span>{</span><br /><span class="line">    <span class="comment">// 获得 `onreturn` 方法和对象</span></span><br /><span class="line">    <span class="keyword">final</span> Method onReturnMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_METHOD_KEY));</span><br /><span class="line">    <span class="keyword">final</span> Object onReturnInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_INSTANCE_KEY));</span><br /><span class="line">    <span class="comment">//not set onreturn callback</span></span><br /><span class="line">    <span class="keyword">if</span> (onReturnMethod == <span class="keyword">null</span> &amp;&amp; onReturnInst == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">if</span> (onReturnMethod == <span class="keyword">null</span> || onReturnInst == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"service:"</span> + invoker.getUrl().getServiceKey() + <span class="string">" has a onreturn callback config , but no such "</span> + (onReturnMethod == <span class="keyword">null</span> ? <span class="string">"method"</span> : <span class="string">"instance"</span>) + <span class="string">" found. url:"</span> + invoker.getUrl());</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">if</span> (!onReturnMethod.isAccessible()) {</span><br /><span class="line">        onReturnMethod.setAccessible(<span class="keyword">true</span>);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">// 参数数组</span></span><br /><span class="line">    Object[] args = invocation.getArguments();</span><br /><span class="line">    Object[] params;</span><br /><span class="line">    Class&lt;?&gt;[] rParaTypes = onReturnMethod.getParameterTypes();</span><br /><span class="line">    <span class="keyword">if</span> (rParaTypes.length &gt; <span class="number">1</span>) {</span><br /><span class="line">        <span class="keyword">if</span> (rParaTypes.length == <span class="number">2</span> &amp;&amp; rParaTypes[<span class="number">1</span>].isAssignableFrom(Object[].class)) {</span><br /><span class="line">            params = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br /><span class="line">            params[<span class="number">0</span>] = result;</span><br /><span class="line">            params[<span class="number">1</span>] = args;</span><br /><span class="line">        } <span class="keyword">else</span> {</span><br /><span class="line">            params = <span class="keyword">new</span> Object[args.length + <span class="number">1</span>];</span><br /><span class="line">            params[<span class="number">0</span>] = result;</span><br /><span class="line">            System.arraycopy(args, <span class="number">0</span>, params, <span class="number">1</span>, args.length);</span><br /><span class="line">        }</span><br /><span class="line">    } <span class="keyword">else</span> {</span><br /><span class="line">        params = <span class="keyword">new</span> Object[]{result};</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">// 调用方法</span></span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        onReturnMethod.invoke(onReturnInst, params);</span><br /><span class="line">    } <span class="keyword">catch</span> (InvocationTargetException e) {</span><br /><span class="line">        fireThrowCallback(invoker, invocation, e.getTargetException());</span><br /><span class="line">    } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">        fireThrowCallback(invoker, invocation, e);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><code>#fireReturnCallback(invoker, invocation, result)</code>&nbsp;方法，触发正常回调方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireThrowCallback</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; invoker, <span class="keyword">final</span> Invocation invocation, <span class="keyword">final</span> Throwable exception)</span> </span>{</span><br /><span class="line">    <span class="comment">// 获得 `onthrow` 方法和对象</span></span><br /><span class="line">    <span class="keyword">final</span> Method onthrowMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_METHOD_KEY));</span><br /><span class="line">    <span class="keyword">final</span> Object onthrowInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_INSTANCE_KEY));</span><br /><span class="line">    <span class="comment">// onthrow callback not configured</span></span><br /><span class="line">    <span class="keyword">if</span> (onthrowMethod == <span class="keyword">null</span> &amp;&amp; onthrowInst == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">if</span> (onthrowMethod == <span class="keyword">null</span> || onthrowInst == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"service:"</span> + invoker.getUrl().getServiceKey() + <span class="string">" has a onthrow callback config , but no such "</span> + (onthrowMethod == <span class="keyword">null</span> ? <span class="string">"method"</span> : <span class="string">"instance"</span>) + <span class="string">" found. url:"</span> + invoker.getUrl());</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">if</span> (!onthrowMethod.isAccessible()) {</span><br /><span class="line">        onthrowMethod.setAccessible(<span class="keyword">true</span>);</span><br /><span class="line">    }</span><br /><br /><span class="line">    Class&lt;?&gt;[] rParaTypes = onthrowMethod.getParameterTypes();</span><br /><span class="line">    <span class="keyword">if</span> (rParaTypes[<span class="number">0</span>].isAssignableFrom(exception.getClass())) { <span class="comment">// 符合异常</span></span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="comment">// 参数数组</span></span><br /><span class="line">            Object[] args = invocation.getArguments();</span><br /><span class="line">            Object[] params;</span><br /><span class="line">            <span class="keyword">if</span> (rParaTypes.length &gt; <span class="number">1</span>) {</span><br /><span class="line">                <span class="keyword">if</span> (rParaTypes.length == <span class="number">2</span> &amp;&amp; rParaTypes[<span class="number">1</span>].isAssignableFrom(Object[].class)) {</span><br /><span class="line">                    params = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br /><span class="line">                    params[<span class="number">0</span>] = exception;</span><br /><span class="line">                    params[<span class="number">1</span>] = args;</span><br /><span class="line">                } <span class="keyword">else</span> {</span><br /><span class="line">                    params = <span class="keyword">new</span> Object[args.length + <span class="number">1</span>];</span><br /><span class="line">                    params[<span class="number">0</span>] = exception;</span><br /><span class="line">                    System.arraycopy(args, <span class="number">0</span>, params, <span class="number">1</span>, args.length);</span><br /><span class="line">                }</span><br /><span class="line">            } <span class="keyword">else</span> {</span><br /><span class="line">                params = <span class="keyword">new</span> Object[]{exception};</span><br /><span class="line">            }</span><br /><br /><span class="line">            <span class="comment">// 调用方法</span></span><br /><span class="line">            onthrowMethod.invoke(onthrowInst, params);</span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">            logger.error(invocation.getMethodName() + <span class="string">".call back method invoke error . callback method :"</span> + onthrowMethod + <span class="string">", url:"</span> + invoker.getUrl(), e);</span><br /><span class="line">        }</span><br /><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 不符合异常，打印错误日志</span></span><br /><span class="line">        logger.error(invocation.getMethodName() + <span class="string">".call back method invoke error . callback method :"</span> + onthrowMethod + <span class="string">", url:"</span> + invoker.getUrl(), exception);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<h2 id="3-3-asyncCallback">3.3 asyncCallback</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 异步回调</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> invoker Invoker 对象</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> invocation Invocation 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">asyncCallback</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; invoker, <span class="keyword">final</span> Invocation invocation)</span> </span>{</span><br /><span class="line">    <span class="comment">// 获得 Future 对象</span></span><br /><span class="line">    Future&lt;?&gt; f = RpcContext.getContext().getFuture();</span><br /><span class="line">    <span class="keyword">if</span> (f <span class="keyword">instanceof</span> FutureAdapter) {</span><br /><span class="line">        ResponseFuture future = ((FutureAdapter&lt;?&gt;) f).getFuture();</span><br /><span class="line">        <span class="comment">// 触发回调</span></span><br /><span class="line">        future.setCallback(<span class="keyword">new</span> ResponseCallback() {</span><br /><br /><span class="line">            <span class="comment">/**</span></span><br /><span class="line"><span class="comment">             * 触发正常回调方法</span></span><br /><span class="line"><span class="comment">             *</span></span><br /><span class="line"><span class="comment">             * <span class="doctag">@param</span> rpcResult RPC 结果</span></span><br /><span class="line"><span class="comment">             */</span></span><br /><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(Object rpcResult)</span> </span>{</span><br /><span class="line">                <span class="keyword">if</span> (rpcResult == <span class="keyword">null</span>) {</span><br /><span class="line">                    logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"invalid result value : null, expected "</span> + Result.class.getName()));</span><br /><span class="line">                    <span class="keyword">return</span>;</span><br /><span class="line">                }</span><br /><span class="line">                <span class="comment">// must be rpcResult</span></span><br /><span class="line">                <span class="keyword">if</span> (!(rpcResult <span class="keyword">instanceof</span> Result)) {</span><br /><span class="line">                    logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"invalid result type :"</span> + rpcResult.getClass() + <span class="string">", expected "</span> + Result.class.getName()));</span><br /><span class="line">                    <span class="keyword">return</span>;</span><br /><span class="line">                }</span><br /><span class="line">                Result result = (Result) rpcResult;</span><br /><span class="line">                <span class="keyword">if</span> (result.hasException()) { <span class="comment">// 触发正常回调方法</span></span><br /><span class="line">                    fireThrowCallback(invoker, invocation, result.getException());</span><br /><span class="line">                } <span class="keyword">else</span> { <span class="comment">// 触发异常回调方法</span></span><br /><span class="line">                    fireReturnCallback(invoker, invocation, result.getValue());</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><br /><span class="line">            <span class="comment">/**</span></span><br /><span class="line"><span class="comment">             * 触发异常回调方法</span></span><br /><span class="line"><span class="comment">             *</span></span><br /><span class="line"><span class="comment">             * <span class="doctag">@param</span> exception 异常</span></span><br /><span class="line"><span class="comment">             */</span></span><br /><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Throwable exception)</span> </span>{</span><br /><span class="line">                fireThrowCallback(invoker, invocation, exception);</span><br /><span class="line">            }</span><br /><span class="line">        });</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</div>