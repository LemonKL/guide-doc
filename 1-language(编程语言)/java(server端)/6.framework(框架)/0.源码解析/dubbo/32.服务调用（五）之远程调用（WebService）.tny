<header class="article-header">
<h1 class="article-title">服务调用（五）之远程调用（WebService）</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>本文，我们分享&nbsp;<code>webservice://</code>&nbsp;协议的远程调用，主要分成<strong>三个部分</strong>：</p>
<ul>
<li>服务暴露</li>
<li>服务引用</li>
<li>服务调用</li>
</ul>
<p>对应项目为&nbsp;<code>dubbo-rpc-webservice</code>&nbsp;。</p>
<p>对应文档为&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/webservice.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; webservice://》</a>&nbsp;。定义如下：</p>
<blockquote>
<p>基于 WebService 的远程调用协议，基于&nbsp;<a href="http://cxf.apache.org/" target="_blank" rel="external nofollow noopener noreferrer">Apache CXF</a>&nbsp;的 frontend-simple 和 transports-http 实现。</p>
</blockquote>
<blockquote>
<p>可以和原生 WebService 服务互操作，即：</p>
<ul>
<li>提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用，</li>
<li>或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。</li>
</ul>
</blockquote>
<p>本文涉及类图（红圈部分）如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_10_16/01.png" alt="类图" /></p>
<blockquote>
<p>旁白君：整体实现和&nbsp;<code>dubbo-rpc-http</code>&nbsp;一致，所以内容上和&nbsp;<a href="http://svip.iocoder.cn/Dubbo/rpc-http/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 服务调用（三）之远程调用（HTTP）》</a>&nbsp;差不多。</p>
</blockquote>
<h1 id="2-WebServiceProtocol">2. WebServiceProtocol</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-webservice/src/main/java/com/alibaba/dubbo/rpc/protocol/webservice/WebServiceProtocol.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol</code></a>&nbsp;，实现 AbstractProxyProtocol 抽象类，<code>webservice://</code>&nbsp;协议实现类。</p>
<h2 id="2-1-构造方法">2.1 构造方法</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 默认服务器端口</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">80</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Http 服务器集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key：ip:port</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, HttpServer&gt; serverMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HttpServer&gt;();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 《我眼中的CXF之Bus》http://jnn.iteye.com/blog/94746</span></span><br /><span class="line"><span class="comment"> * 《CXF BUS》https://blog.csdn.net/chen_fly2011/article/details/56664908</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExtensionManagerBus bus = <span class="keyword">new</span> ExtensionManagerBus();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HTTPTransportFactory transportFactory = <span class="keyword">new</span> HTTPTransportFactory();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * HttpBinder$Adaptive 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> HttpBinder httpBinder;</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebServiceProtocol</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">super</span>(Fault.class);</span><br /><span class="line">    bus.setExtension(<span class="keyword">new</span> ServletDestinationFactory(), HttpDestinationFactory.class);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHttpBinder</span><span class="params">(HttpBinder httpBinder)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>.httpBinder = httpBinder;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>serverMap</code>&nbsp;属性，HttpServer 集合。键为&nbsp;<code>ip:port</code>&nbsp;，通过&nbsp;<code>#getAddr(url)</code>&nbsp;方法，计算。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// AbstractProxyProtocol.java</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getAddr</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">    String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());</span><br /><span class="line">    <span class="keyword">if</span> (url.getParameter(Constants.ANYHOST_KEY, <span class="keyword">false</span>)) {</span><br /><span class="line">        bindIp = Constants.ANYHOST_VALUE;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> NetUtils.getIpByHost(bindIp) + <span class="string">":"</span> + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><code>skeletonMap</code>&nbsp;属性，<code>com.caucho.hessian.server.HessianSkeleton</code>&nbsp;集合。请求处理过程为&nbsp;<code>HttpServer =&gt; DispatcherServlet =&gt; WebServiceHandler =&gt; ServletController</code>&nbsp;。</p>
</li>
<li><code>httpBinder</code>&nbsp;属性，HttpBinder$Adaptive 对象，通过&nbsp;<code>#setHttpBinder(httpBinder)</code>&nbsp;方法，Dubbo SPI 调用设置。</li>
<li><code>rpcExceptions = Fault.class</code>&nbsp;。</li>
<li><code>bus</code>&nbsp;和&nbsp;<code>transportFactory</code>&nbsp;属性，可以参看如下文章：
<ul>
<li><a href="http://jnn.iteye.com/blog/94746" target="_blank" rel="external nofollow noopener noreferrer">《我眼中的CXF之Bus》</a></li>
<li><a href="https://blog.csdn.net/chen_fly2011/article/details/56664908" target="_blank" rel="external nofollow noopener noreferrer">《CXF BUS》</a></li>
</ul>
</li>
<li>🙂 艿艿对 Apache CXF 了解不多，所以本文更多梳理好整体脉络。</li>
</ul>
<h2 id="2-2-doExport">2.2 doExport</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;T&gt; <span class="function">Runnable <span class="title">doExport</span><span class="params">(T impl, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 获得服务器地址</span></span><br /><span class="line"> <span class="number">4</span>:     String addr = getAddr(url);</span><br /><span class="line"> <span class="number">5</span>:     <span class="comment">// 获得 HttpServer 对象。若不存在，进行创建。</span></span><br /><span class="line"> <span class="number">6</span>:     HttpServer httpServer = serverMap.get(addr);</span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (httpServer == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">8</span>:         httpServer = httpBinder.bind(url, <span class="keyword">new</span> WebServiceHandler()); <span class="comment">// WebServiceHandler</span></span><br /><span class="line"> <span class="number">9</span>:         serverMap.put(addr, httpServer);</span><br /><span class="line"><span class="number">10</span>:     }</span><br /><span class="line"><span class="number">11</span>:     <span class="comment">// 创建 ServerFactoryBean 对象</span></span><br /><span class="line"><span class="number">12</span>:     <span class="keyword">final</span> ServerFactoryBean serverFactoryBean = <span class="keyword">new</span> ServerFactoryBean();</span><br /><span class="line"><span class="number">13</span>:     serverFactoryBean.setAddress(url.getAbsolutePath());</span><br /><span class="line"><span class="number">14</span>:     serverFactoryBean.setServiceClass(type);</span><br /><span class="line"><span class="number">15</span>:     serverFactoryBean.setServiceBean(impl);</span><br /><span class="line"><span class="number">16</span>:     serverFactoryBean.setBus(bus);</span><br /><span class="line"><span class="number">17</span>:     serverFactoryBean.setDestinationFactory(transportFactory);</span><br /><span class="line"><span class="number">18</span>:     serverFactoryBean.create();</span><br /><span class="line"><span class="number">19</span>:     <span class="comment">// 返回取消暴露的回调 Runnable</span></span><br /><span class="line"><span class="number">20</span>:     <span class="keyword">return</span> <span class="keyword">new</span> Runnable() {</span><br /><span class="line"><span class="number">21</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br /><span class="line"><span class="number">22</span>:             serverFactoryBean.destroy();</span><br /><span class="line"><span class="number">23</span>:         }</span><br /><span class="line"><span class="number">24</span>:     };</span><br /><span class="line"><span class="number">25</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>基于&nbsp;<code>dubbo-remoting-http</code>&nbsp;项目，作为<strong>通信服务器</strong>。</li>
<li>第 4 行：调用&nbsp;<code>#getAddr(url)</code>&nbsp;方法，获得服务器地址。</li>
<li>第 5 至 10 行：从&nbsp;<code>serverMap</code>&nbsp;中，获得 HttpServer 对象。若不存在，调用&nbsp;<code>HttpBinder#bind(url, handler)</code>&nbsp;方法，创建 HttpServer 对象。此处使用的 WebServiceHandler ，下文详细解析。</li>
<li>第 11 至 18 行：创建 ServerFactoryBean 对象。</li>
<li>第 19 至 24 行：返回取消暴露的回调 Runnable 对象。</li>
</ul>
<h3 id="2-2-1-WebServiceHandler">2.2.1 WebServiceHandler</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServiceHandler</span> <span class="keyword">implements</span> <span class="title">HttpHandler</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServletController servletController;</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>{</span><br /><span class="line">        <span class="comment">// 创建 ServletController 对象，设置使用 DispatcherServlet 。</span></span><br /><span class="line">        <span class="keyword">if</span> (servletController == <span class="keyword">null</span>) {</span><br /><span class="line">            HttpServlet httpServlet = DispatcherServlet.getInstance();</span><br /><span class="line">            <span class="keyword">if</span> (httpServlet == <span class="keyword">null</span>) {</span><br /><span class="line">                response.sendError(<span class="number">500</span>, <span class="string">"No such DispatcherServlet instance."</span>);</span><br /><span class="line">                <span class="keyword">return</span>;</span><br /><span class="line">            }</span><br /><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br /><span class="line">                <span class="keyword">if</span> (servletController == <span class="keyword">null</span>) {</span><br /><span class="line">                    servletController = <span class="keyword">new</span> ServletController(transportFactory.getRegistry(), httpServlet.getServletConfig(), httpServlet);</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 设置调用方地址</span></span><br /><span class="line">        RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());</span><br /><span class="line">        <span class="comment">// 执行调用</span></span><br /><span class="line">        servletController.invoke(request, response);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="2-3-doRefer">2.3 doRefer</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br /><span class="line"> <span class="number">3</span>: <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doRefer</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; serviceType, <span class="keyword">final</span> URL url)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">// 创建 ClientProxyFactoryBean 对象</span></span><br /><span class="line"> <span class="number">5</span>:     ClientProxyFactoryBean proxyFactoryBean = <span class="keyword">new</span> ClientProxyFactoryBean();</span><br /><span class="line"> <span class="number">6</span>:     proxyFactoryBean.setAddress(url.setProtocol(<span class="string">"http"</span>).toIdentityString());</span><br /><span class="line"> <span class="number">7</span>:     proxyFactoryBean.setServiceClass(serviceType);</span><br /><span class="line"> <span class="number">8</span>:     proxyFactoryBean.setBus(bus);</span><br /><span class="line"> <span class="number">9</span>:     <span class="comment">// 创建 Service Proxy 对象</span></span><br /><span class="line"><span class="number">10</span>:     T ref = (T) proxyFactoryBean.create();</span><br /><span class="line"><span class="number">11</span>:     <span class="comment">// 设置超时相关属性</span></span><br /><span class="line"><span class="number">12</span>:     Client proxy = ClientProxy.getClient(ref);</span><br /><span class="line"><span class="number">13</span>:     HTTPConduit conduit = (HTTPConduit) proxy.getConduit();</span><br /><span class="line"><span class="number">14</span>:     HTTPClientPolicy policy = <span class="keyword">new</span> HTTPClientPolicy();</span><br /><span class="line"><span class="number">15</span>:     policy.setConnectionTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));</span><br /><span class="line"><span class="number">16</span>:     policy.setReceiveTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));</span><br /><span class="line"><span class="number">17</span>:     conduit.setClient(policy);</span><br /><span class="line"><span class="number">18</span>:     <span class="keyword">return</span> ref;</span><br /><span class="line"><span class="number">19</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 4 至 8 行：创建 ClientProxyFactoryBean 对象。</li>
<li>第 10 行：创建 Service Proxy 对象。</li>
<li>第 11 至 17 行：设置<strong>超时相关</strong>属性。</li>
</ul>
<h3 id="2-3-1-getErrorCode">2.3.1 getErrorCode</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">(Throwable e)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Fault) {</span><br /><span class="line">        e = e.getCause();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SocketTimeoutException) {</span><br /><span class="line">        <span class="keyword">return</span> RpcException.TIMEOUT_EXCEPTION;</span><br /><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IOException) {</span><br /><span class="line">        <span class="keyword">return</span> RpcException.NETWORK_EXCEPTION;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getErrorCode(e);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>将异常，翻译成 Dubbo 异常码。</li>
</ul>
</div>