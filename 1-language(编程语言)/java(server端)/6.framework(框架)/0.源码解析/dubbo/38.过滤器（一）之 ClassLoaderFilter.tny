<header class="article-header">
<h1 class="article-title">过滤器（一）之 ClassLoaderFilter</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>从本文开始，我们来分享 Dubbo 的<strong>过滤器</strong>们。在 ProtocolFilterWrapper 中，在服务引用和暴露时，<code>#buildInvokerChain(invoker, key, group)</code>&nbsp;方法中，基于 Dubbo SPI&nbsp;<strong>Active</strong>&nbsp;机制，加载<strong>匹配</strong>对应的过滤器数组，创建带有<strong>过滤器链的 Invoker 对象</strong>。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 创建带 Filter 链的 Invoker 对象</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> invoker Invoker 对象</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 获取 URL 参数名</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 分组</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> Invoker 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>{</span><br /><span class="line">    Invoker&lt;T&gt; last = invoker;</span><br /><span class="line">    <span class="comment">// 获得过滤器数组</span></span><br /><span class="line">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br /><span class="line">    <span class="comment">// 倒序循环 Filter ，创建带 Filter 链的 Invoker 对象</span></span><br /><span class="line">    <span class="keyword">if</span> (!filters.isEmpty()) {</span><br /><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br /><span class="line">            <span class="keyword">final</span> Filter filter = filters.get(i);</span><br /><span class="line">            <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br /><span class="line">            last = <span class="keyword">new</span> Invoker&lt;T&gt;() {</span><br /><br /><span class="line">                <span class="meta">@Override</span></span><br /><span class="line">                <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>{</span><br /><span class="line">                    <span class="keyword">return</span> invoker.getInterface();</span><br /><span class="line">                }</span><br /><br /><span class="line">                <span class="meta">@Override</span></span><br /><span class="line">                <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>{</span><br /><span class="line">                    <span class="keyword">return</span> invoker.getUrl();</span><br /><span class="line">                }</span><br /><br /><span class="line">                <span class="meta">@Override</span></span><br /><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>{</span><br /><span class="line">                    <span class="keyword">return</span> invoker.isAvailable();</span><br /><span class="line">                }</span><br /><br /><span class="line">                <span class="meta">@Override</span></span><br /><span class="line">                <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">                    <span class="keyword">return</span> filter.invoke(next, invocation);</span><br /><span class="line">                }</span><br /><br /><span class="line">                <span class="meta">@Override</span></span><br /><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">                    invoker.destroy();</span><br /><span class="line">                }</span><br /><br /><span class="line">                <span class="meta">@Override</span></span><br /><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br /><span class="line">                    <span class="keyword">return</span> invoker.toString();</span><br /><span class="line">                }</span><br /><span class="line">            };</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> last;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>具体的过滤器链的执行过程，在前面的 Dubbo RPC 调用，已经分享，这里就不重复解释啦。</li>
</ul>
<p>我们把服务提供者和消费者的过滤器统一整理如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_11_12/01.png" alt="过滤器整理" /></p>
<ul>
<li><strong>黄色</strong>部分，代表过滤器在服务提供者和消费者上的顺序。若为空，则表示无该过滤器。</li>
<li><strong>蓝色</strong>部分，EchoFilter 等等，已经在其他文章里分享。
<ul>
<li><code>dubbo-filter-cache</code>&nbsp;的 CacheFilter,&nbsp;<code>dubbo-filter-validation</code>&nbsp;的 ValidationFilter ，未罗列在表格中，也会在其他文章里分享。</li>
</ul>
</li>
<li><strong>绿色</strong>部分 ，CompatibleFilter 等等，目前未开启 Dubbo SPI&nbsp;<code>@Adaptive</code>&nbsp;注解，我们就不写了。</li>
</ul>
<p>本文分享 ClassLoaderFilter 。后续的文章，也会是每篇文章分享 1-2 个过滤器，根据实际用途的情况。</p>
<h1 id="2-Filter">2. Filter</h1>
<p>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/implementation-intro/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 核心流程一览》「4.4 Filter」</a>&nbsp;中，已经详细分享。</p>
<h1 id="3-ClassLoaderFilter">3. ClassLoaderFilter</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/ClassLoaderFilter.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.filter.ClassLoaderFilter</code></a>&nbsp;，实现 Filter 接口，类加载器切换过滤器实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Activate</span>(group = Constants.PROVIDER, order = -<span class="number">30000</span>)</span><br /><span class="line"> <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>{</span><br /><span class="line"> <span class="number">3</span>: </span><br /><span class="line"> <span class="number">4</span>:     <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">5</span>:     <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">6</span>:         <span class="comment">// 获得原来的类加载器</span></span><br /><span class="line"> <span class="number">7</span>:         ClassLoader ocl = Thread.currentThread().getContextClassLoader();</span><br /><span class="line"> <span class="number">8</span>:         <span class="comment">// 切换当前线程的类加载器为服务接口的类加载器</span></span><br /><span class="line"> <span class="number">9</span>:         Thread.currentThread().setContextClassLoader(invoker.getInterface().getClassLoader());</span><br /><span class="line"><span class="number">10</span>:         <span class="comment">// 服务调用</span></span><br /><span class="line"><span class="number">11</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">12</span>:             <span class="keyword">return</span> invoker.invoke(invocation);</span><br /><span class="line"><span class="number">13</span>:         } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">14</span>:             <span class="comment">// 切换当前线程的类加载器为原来的类加载器</span></span><br /><span class="line"><span class="number">15</span>:             Thread.currentThread().setContextClassLoader(ocl);</span><br /><span class="line"><span class="number">16</span>:         }</span><br /><span class="line"><span class="number">17</span>:     }</span><br /><span class="line"><span class="number">18</span>: </span><br /><span class="line"><span class="number">19</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 7 行：调用&nbsp;<code>Thread#getContextClassLoader()</code>&nbsp;方法，获得<strong>原来的</strong>类加载器。</li>
<li>第 9 行：调用&nbsp;<code>Thread#setContextClassLoader(ClassLoader)</code>&nbsp;方法，<strong>切换</strong>当前线程的类加载器为<strong>服务接口的</strong>类加载器。</li>
<li>第 12 行：调用&nbsp;<code>Invoker#invoke(invocation)</code>&nbsp;方法，服务调用。</li>
<li>第 15 行：调用&nbsp;<code>Thread#setContextClassLoader(ClassLoader)</code>&nbsp;方法，<strong>切换</strong>当前线程的类加载器为<strong>原来的</strong>类加载器。</li>
</ul>
<p>笔者看到这个过滤器，表示一脸懵逼，于是开始 Google 探索之路。</p>
<p>1、于是搜到&nbsp;<a href="https://github.com/apache/incubator-dubbo/issues/1406" target="_blank" rel="external nofollow noopener noreferrer">《ISSUE#1406：classloaderFilter》</a>&nbsp;，内容如下：<img src="http://static2.iocoder.cn/images/Dubbo/2018_11_12/02.png" alt="ISSUE#1406" /></p>
<p>使用我大有道词典翻译：</p>
<blockquote>
<p>在设计目的中，切换到加载了接口定义的类加载器，以便实现与相同的类加载器上下文一起工作。</p>
</blockquote>
<p>2、那么什么情况下会有多个 ClassLoader 的情况呢？再于是搜到&nbsp;<a href="https://github.com/apache/incubator-dubbo/issues/178" target="_blank" rel="external nofollow noopener noreferrer">《ISSUE#178：项目有多个ClassLoad时使用dubbo出错；》</a>&nbsp;，内容如下：<img src="http://static2.iocoder.cn/images/Dubbo/2018_11_12/03.png" alt="ISSUE#178" /></p>
<p>开始检索&nbsp;<strong>pf4j</strong>&nbsp;是什么东东？</p>
<blockquote>
<p>FROM&nbsp;<a href="https://www.oschina.net/p/pf4j" target="_blank" rel="external nofollow noopener noreferrer">《Java 的插件框架 PF4J》</a></p>
<p>PF4J 是一个 Java 的插件框架，为第三方提供应用扩展的渠道。使用 PF4J 你可以轻松将一个普通的 Java 应用转成一个模块化的应用。PF4J 本身非常轻量级，只有 50KB 左右，目前只依赖了 slf4j。<a href="https://www.oschina.net/p/gitblit" target="_blank" rel="external nofollow noopener noreferrer">Gitblit</a>&nbsp;项目使用的就是 PF4J 进行插件管理。</p>
</blockquote>
<p>🙂 看到此处，笔者已经进入了云里和雾里。所以，我仅仅是抛个砖，暂时还没去测试。再所以，胖友如果感兴趣，可以自己去研究下下。我的猜测是，使用 PF4J 加载不同的服务实现类的 Jar ，不同的 Jar 的类加载器不同。</p>
<p>有熟悉这块的胖友，如果有错误，请立即斧正我。哈哈哈。</p>
</div>