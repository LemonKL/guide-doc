<header class="article-header"><header class="article-header">
<h1 class="article-title">NIO 服务器（四）之 Exchange 层</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>本文接&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-api-telnet//?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（三）之 Telnet 层》</a>&nbsp;一文，分享&nbsp;<code>dubbo-remoting-api</code>模块，&nbsp;<code>exchange</code>&nbsp;包，<strong>信息交换层</strong>。</p>
<blockquote>
<p><strong>exchange</strong>&nbsp;信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer。</p>
</blockquote>
<p>在一次 RPC 调用，每个<strong>请求</strong>( Request )，是关注对应的<strong>响应</strong>( Response )。那么&nbsp;<strong>transport 层</strong>&nbsp;提供的<strong>网络传输</strong>&nbsp;功能，是无法满足 RPC 的诉求的。因此，<strong>exchange 层</strong>，在其&nbsp;<strong>Message</strong>&nbsp;之上，构造了<strong>Request-Response</strong>&nbsp;的模型。</p>
<p>实现上，也非常简单，将 Message 分成 Request 和 Response 两种类型，并增加<strong>编号</strong>属性，将 Request 和 Response 能够<strong>一一映射</strong>。</p>
<p>实际上，RPC 调用，会有更多特性的需求：1）<strong>异步</strong>处理返回结果；2）内置事件；3）等等。因此，Request 和 Response 上会有类似<strong>编号</strong>的<strong>系统字段</strong>。</p>
<p>一条消息，我们分成两段：</p>
<ul>
<li>协议头( Header ) ： 系统字段，例如编号等。</li>
<li>内容( Body ) ：具体请求的参数和响应的结果等。</li>
</ul>
<p>胖友在看下面这张图，是否就亲切多了 🙂 ：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_12_10/01.png" alt="类图" /></p>
<p>所以，<code>exchange</code>&nbsp;包，很多的代码，是在 Header 的处理。OK ，下面我们来看下这个包的<strong>类图</strong>：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_12_10/02.png" alt="类图" /></p>
<ul>
<li>白色部分，为通用接口和&nbsp;<code>transport</code>&nbsp;包下的类。</li>
<li>蓝色部分，为&nbsp;<code>exchange</code>&nbsp;包下的类。</li>
</ul>
<p>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-api-transport/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（二）之 Transport 层》</a>&nbsp;中，我们提到，<strong>装饰器设计模式</strong>，是&nbsp;<code>dubbo-remoting</code>&nbsp;项目，最核心的实现方式，所以，<code>exchange</code>&nbsp;其实是在&nbsp;<code>transport</code>&nbsp;上的<strong>装饰</strong>，提供给&nbsp;<code>dubbo-rpc</code>&nbsp;项目使用。</p>
<p>下面，我们来看具体代码实现。</p>
<h1 id="2-ExchangeChannel">2. ExchangeChannel</h1>
<p><code>com.alibaba.dubbo.remoting.exchange.ExchangeChannel</code>&nbsp;，继承 Channel 接口，<strong>信息交换通道</strong>接口。方法如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// 发送请求</span></span><br /><span class="line"><span class="function">ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br /><span class="line"><span class="function">ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br /><br /><span class="line"><span class="comment">// 获得信息交换处理器</span></span><br /><span class="line"><span class="function">ExchangeHandler <span class="title">getExchangeHandler</span><span class="params">()</span></span>;</span><br /><br /><span class="line"><span class="comment">// 优雅关闭</span></span><br /><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="2-1-HeaderExchangeChannel">2.1 HeaderExchangeChannel</h2>
<p><code>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeChannel</code>&nbsp;，实现 ExchangeChannel 接口，基于<strong>消息头部( Header )</strong>的信息交换通道实现类。</p>
<h3 id="2-1-1-构造方法">2.1.1 构造方法</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHANNEL_KEY = HeaderExchangeChannel.class.getName() + <span class="string">".CHANNEL"</span>;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 通道</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否关闭</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br /><br /><span class="line">HeaderExchangeChannel(Channel channel) {</span><br /><span class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"channel == null"</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>channel</code>&nbsp;属性，通道。HeaderExchangeChannel 是传入&nbsp;<code>channel</code>&nbsp;属性的<strong>装饰器</strong>，每个实现的方法，都会调用&nbsp;<code>channel</code>&nbsp;。如下是该属性的一个例子：<img src="http://static2.iocoder.cn/images/Dubbo/2018_12_10/03.png" alt="&#96;channel&#96;" /></li>
<li>
<p><code>#getOrAddChannel(Channel)</code>&nbsp;<strong>静态</strong>方法，创建 HeaderExchangeChannel 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">static</span> HeaderExchangeChannel <span class="title">getOrAddChannel</span><span class="params">(Channel ch)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (ch == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">    }</span><br /><span class="line">    HeaderExchangeChannel ret = (HeaderExchangeChannel) ch.getAttribute(CHANNEL_KEY);</span><br /><span class="line">    <span class="keyword">if</span> (ret == <span class="keyword">null</span>) {</span><br /><span class="line">        ret = <span class="keyword">new</span> HeaderExchangeChannel(ch);</span><br /><span class="line">        <span class="keyword">if</span> (ch.isConnected()) { <span class="comment">// 已连接</span></span><br /><span class="line">            ch.setAttribute(CHANNEL_KEY, ret);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> ret;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>传入的&nbsp;<code>ch</code>&nbsp;属性，实际就是&nbsp;<code>HeaderExchangeChanel.channel</code>&nbsp;属性。</li>
<li>通过&nbsp;<code>ch.attribute</code>&nbsp;的&nbsp;<code>CHANNEL_KEY</code>&nbsp;键值，保证有且仅有为&nbsp;<code>ch</code>&nbsp;属性，创建唯一的 HeaderExchangeChannel 对象。</li>
<li>要求<strong>已连接</strong>。</li>
</ul>
</li>
<li>
<p><code>#removeChannelIfDisconnected(ch)</code>&nbsp;<strong>静态方法</strong>，移除 HeaderExchangeChannel 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeChannelIfDisconnected</span><span class="params">(Channel ch)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (ch != <span class="keyword">null</span> &amp;&amp; !ch.isConnected()) { <span class="comment">// 未连接</span></span><br /><span class="line">        ch.removeAttribute(CHANNEL_KEY);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<h3 id="2-1-2-发送请求">2.1.2 发送请求</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (closed) {</span><br /><span class="line"> <span class="number">4</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send request "</span> + request + <span class="string">", cause: The channel "</span> + <span class="keyword">this</span> + <span class="string">" is closed!"</span>);</span><br /><span class="line"> <span class="number">5</span>:     }</span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// create request. 创建请求</span></span><br /><span class="line"> <span class="number">7</span>:     Request req = <span class="keyword">new</span> Request();</span><br /><span class="line"> <span class="number">8</span>:     req.setVersion(<span class="string">"2.0.0"</span>);</span><br /><span class="line"> <span class="number">9</span>:     req.setTwoWay(<span class="keyword">true</span>); <span class="comment">// 需要响应</span></span><br /><span class="line"><span class="number">10</span>:     req.setData(request);</span><br /><span class="line"><span class="number">11</span>:     <span class="comment">// 创建 DefaultFuture 对象</span></span><br /><span class="line"><span class="number">12</span>:     DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br /><span class="line"><span class="number">13</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">14</span>:         <span class="comment">// 发送请求</span></span><br /><span class="line"><span class="number">15</span>:         channel.send(req);</span><br /><span class="line"><span class="number">16</span>:     } <span class="keyword">catch</span> (RemotingException e) { <span class="comment">// 发生异常，取消 DefaultFuture</span></span><br /><span class="line"><span class="number">17</span>:         future.cancel();</span><br /><span class="line"><span class="number">18</span>:         <span class="keyword">throw</span> e;</span><br /><span class="line"><span class="number">19</span>:     }</span><br /><span class="line"><span class="number">20</span>:     <span class="comment">// 返回 DefaultFuture 对象</span></span><br /><span class="line"><span class="number">21</span>:     <span class="keyword">return</span> future;</span><br /><span class="line"><span class="number">22</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 至 5 行：若已经关闭，不再允许发起新的请求。</li>
<li>第 6 至 10 行：创建 Request 对象。其中，<code>twoWay = true</code>&nbsp;需要响应；<code>data = request</code>&nbsp;具体数据。</li>
<li>第 12 行：创建 DefaultFuture 对象。</li>
<li>第 13 至 15 行：调用&nbsp;<code>Channel#send(req)</code>&nbsp;方法，发送请求。</li>
<li>第 16 至 19 行：发生 RemotingException 异常，调用&nbsp;<code>DefaultFuture#cancel()</code>&nbsp;方法，取消。</li>
<li>第 21 行：返回 DefaultFuture 对象。从代码的形式上来说，有点类似线程池提交任务，返回 Future 对象。🙂 看到 DefaultFuture 的具体代码，我们就会更加理解了。</li>
</ul>
<h3 id="2-1-3-优雅关闭">2.1.3 优雅关闭</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (closed) {</span><br /><span class="line"> <span class="number">4</span>:         <span class="keyword">return</span>;</span><br /><span class="line"> <span class="number">5</span>:     }</span><br /><span class="line"> <span class="number">6</span>:     closed = <span class="keyword">true</span>;</span><br /><span class="line"> <span class="number">7</span>:     <span class="comment">// 等待请求完成</span></span><br /><span class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">9</span>:         <span class="keyword">long</span> start = System.currentTimeMillis();</span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">while</span> (DefaultFuture.hasFuture(channel) &amp;&amp; System.currentTimeMillis() - start &lt; timeout) {</span><br /><span class="line"><span class="number">11</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">12</span>:                 Thread.sleep(<span class="number">10</span>);</span><br /><span class="line"><span class="number">13</span>:             } <span class="keyword">catch</span> (InterruptedException e) {</span><br /><span class="line"><span class="number">14</span>:                 logger.warn(e.getMessage(), e);</span><br /><span class="line"><span class="number">15</span>:             }</span><br /><span class="line"><span class="number">16</span>:         }</span><br /><span class="line"><span class="number">17</span>:     }</span><br /><span class="line"><span class="number">18</span>:     <span class="comment">// 关闭通道</span></span><br /><span class="line"><span class="number">19</span>:     close();</span><br /><span class="line"><span class="number">20</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 至 6 行：标记&nbsp;<code>closed = true</code>&nbsp;，避免发起<strong>新</strong>的请求。</li>
<li>第 7 至 17 行：调用&nbsp;<code>DefaultFuture#hasFuture(channel)</code>&nbsp;方法，判断已发起的已经是否已经都响应了。若否，等待完成或超时。</li>
<li>第 19 行：关闭<strong>通道</strong>。</li>
</ul>
<p><strong>其它方法</strong></p>
<p>其它<strong>实现</strong>方法，主要是直接调用&nbsp;<code>channel</code>&nbsp;的方法，点击&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/2a0484941defceb9a600c7f7914ada335e3186af/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeChannel.java" target="_blank" rel="external nofollow noopener noreferrer">传送门</a>&nbsp;查看代码。</p>
<h1 id="3-ExchangeClient">3. ExchangeClient</h1>
<p><code>com.alibaba.dubbo.remoting.exchange.ExchangeClient</code>&nbsp;，实现 Client ，ExchangeChannel 接口，<strong>信息交换客户端</strong>接口。</p>
<p>无自定义方法。</p>
<h2 id="3-1-HeaderExchangeClient">3.1 HeaderExchangeClient</h2>
<p><code>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeClient</code>&nbsp;，实现 ExchangeClient 接口，基于<strong>消息头部( Header )</strong>的信息交换客户端实现类。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 定时器线程池</span></span><br /><span class="line"><span class="comment"> 3:  */</span></span><br /><span class="line"> <span class="number">4</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor scheduled = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">2</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-remoting-client-heartbeat"</span>, <span class="keyword">true</span>));</span><br /><span class="line"> <span class="number">5</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 6:  * 客户端</span></span><br /><span class="line"><span class="comment"> 7:  */</span></span><br /><span class="line"> <span class="number">8</span>: <span class="keyword">private</span> <span class="keyword">final</span> Client client;</span><br /><span class="line"> <span class="number">9</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">10:  * 信息交换通道</span></span><br /><span class="line"><span class="comment">11:  */</span></span><br /><span class="line"><span class="number">12</span>: <span class="keyword">private</span> <span class="keyword">final</span> ExchangeChannel channel;</span><br /><span class="line"><span class="number">13</span>: <span class="comment">// heartbeat timer</span></span><br /><span class="line"><span class="number">14</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">15:  * 心跳定时器</span></span><br /><span class="line"><span class="comment">16:  */</span></span><br /><span class="line"><span class="number">17</span>: <span class="keyword">private</span> ScheduledFuture&lt;?&gt; heartbeatTimer;</span><br /><span class="line"><span class="number">18</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">19:  * 是否心跳</span></span><br /><span class="line"><span class="comment">20:  */</span></span><br /><span class="line"><span class="number">21</span>: <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br /><span class="line"><span class="number">22</span>: <span class="comment">// heartbeat timeout (ms), default value is 0 , won't execute a heartbeat.</span></span><br /><span class="line"><span class="number">23</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">24:  * 心跳间隔，单位：毫秒</span></span><br /><span class="line"><span class="comment">25:  */</span></span><br /><span class="line"><span class="number">26</span>: <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br /><span class="line"><span class="number">27</span>: </span><br /><span class="line"><span class="number">28</span>: <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> needHeartbeat)</span> </span>{</span><br /><span class="line"><span class="number">29</span>:     <span class="keyword">if</span> (client == <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">30</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"client == null"</span>);</span><br /><span class="line"><span class="number">31</span>:     }</span><br /><span class="line"><span class="number">32</span>:     <span class="keyword">this</span>.client = client;</span><br /><span class="line"><span class="number">33</span>:     <span class="comment">// 创建 HeaderExchangeChannel 对象</span></span><br /><span class="line"><span class="number">34</span>:     <span class="keyword">this</span>.channel = <span class="keyword">new</span> HeaderExchangeChannel(client);</span><br /><span class="line"><span class="number">35</span>:     <span class="comment">// 读取心跳相关配置</span></span><br /><span class="line"><span class="number">36</span>:     String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);</span><br /><span class="line"><span class="number">37</span>:     <span class="keyword">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class="keyword">null</span> &amp;&amp; dubbo.startsWith(<span class="string">"1.0."</span>) ? Constants.DEFAULT_HEARTBEAT : <span class="number">0</span>);</span><br /><span class="line"><span class="number">38</span>:     <span class="keyword">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);</span><br /><span class="line"><span class="number">39</span>:     <span class="keyword">if</span> (heartbeatTimeout &lt; heartbeat * <span class="number">2</span>) { <span class="comment">// 避免间隔太短</span></span><br /><span class="line"><span class="number">40</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"heartbeatTimeout &lt; heartbeatInterval * 2"</span>);</span><br /><span class="line"><span class="number">41</span>:     }</span><br /><span class="line"><span class="number">42</span>:     <span class="comment">// 发起心跳定时器</span></span><br /><span class="line"><span class="number">43</span>:     <span class="keyword">if</span> (needHeartbeat) {</span><br /><span class="line"><span class="number">44</span>:         startHeatbeatTimer();</span><br /><span class="line"><span class="number">45</span>:     }</span><br /><span class="line"><span class="number">46</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>client</code>&nbsp;属性，客户端。如下是该属性的一个例子：<img src="http://static2.iocoder.cn/images/Dubbo/2018_12_10/04.png" alt="&#96;client&#96;" /></li>
<li>第 34 行：使用传入的&nbsp;<code>client</code>&nbsp;属性，创建 HeaderExchangeChannel 对象。</li>
<li>
<p>第 35 至 41 行：读取心跳相关配置。<strong>默认，开启心跳功能</strong>。为什么需要有心跳功能呢？</p>
<blockquote>
<p>FROM&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-protocol.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; dubbo:protocol》</a></p>
<p>心跳间隔，对于长连接，当物理层断开时，比如拔网线，TCP的FIN消息来不及发送，对方收不到断开事件，此时需要心跳来帮助检查连接是否已断开</p>
</blockquote>
</li>
<li>
<p>第 42 至 45 行：调用&nbsp;<code>#startHeatbeatTimer()</code>&nbsp;方法，发起心跳定时器。</p>
</li>
</ul>
<p><strong>发起心跳定时器</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeatbeatTimer</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="comment">// 停止原有定时任务</span></span><br /><span class="line"> <span class="number">3</span>:     stopHeartbeatTimer();</span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">// 发起新的定时任务</span></span><br /><span class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">6</span>:         heartbeatTimer = scheduled.scheduleWithFixedDelay(</span><br /><span class="line"> <span class="number">7</span>:                 <span class="keyword">new</span> HeartBeatTask(<span class="keyword">new</span> HeartBeatTask.ChannelProvider() {</span><br /><span class="line"> <span class="number">8</span>:                     <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">9</span>:                         <span class="keyword">return</span> Collections.&lt;Channel&gt;singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br /><span class="line"><span class="number">10</span>:                     }</span><br /><span class="line"><span class="number">11</span>:                 }, heartbeat, heartbeatTimeout),</span><br /><span class="line"><span class="number">12</span>:                 heartbeat, heartbeat, TimeUnit.MILLISECONDS);</span><br /><span class="line"><span class="number">13</span>:     }</span><br /><span class="line"><span class="number">14</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 行：调用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/0f933100ad0ea81d3760d42169318904f91a45bb/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java#L176-L188" target="_blank" rel="external nofollow noopener noreferrer"><code>#stopHeartbeatTimer()</code></a>&nbsp;方法，停止原有定时任务。</li>
<li>第 5 至 13 行：发起新的定时任务。
<ul>
<li>第 7 至 11 行：创建定时任务 HeartBeatTask 对象。具体实现见下文。</li>
</ul>
</li>
</ul>
<p><strong>其它方法</strong></p>
<p>其它<strong>实现</strong>方法，主要是直接调用&nbsp;<code>channel</code>&nbsp;或&nbsp;<code>client</code>&nbsp;的方法，点击&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/0f933100ad0ea81d3760d42169318904f91a45bb/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeClient.java" target="_blank" rel="external nofollow noopener noreferrer">传送门</a>&nbsp;查看代码。</p>
<h1 id="4-ExchangeServer">4. ExchangeServer</h1>
<p><code>com.alibaba.dubbo.remoting.exchange.ExchangeServer</code>&nbsp;，继承 Server 接口，<strong>信息交换服务器</strong>接口。方法如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// 获得通道数组</span></span><br /><span class="line"><span class="function">Collection&lt;ExchangeChannel&gt; <span class="title">getExchangeChannels</span><span class="params">()</span></span>;</span><br /><span class="line"><span class="function">ExchangeChannel <span class="title">getExchangeChannel</span><span class="params">(InetSocketAddress remoteAddress)</span></span>;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="4-1-HeaderExchangeServer">4.1 HeaderExchangeServer</h2>
<p><code>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeServer</code>&nbsp;，实现 ExchangeServer 接口，基于<strong>消息头部( Header )</strong>的信息交换服务器实现类。</p>
<blockquote>
<p>代码实现上，和 HeaderExchangeChannel + HeaderExchangeClient 的综合。</p>
</blockquote>
<h3 id="4-1-1-构造方法">4.1.1 构造方法</h3>
<blockquote>
<p>代码实现上，和 HeaderExchangeClient 的类似。</p>
</blockquote>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 定时器线程池</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-remoting-server-heartbeat"</span>, <span class="keyword">true</span>));</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 服务器</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Server server;</span><br /><span class="line"><span class="comment">// heartbeat timer</span></span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 心跳定时器</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> ScheduledFuture&lt;?&gt; heatbeatTimer;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否心跳</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="comment">// heartbeat timeout (ms), default value is 0 , won't execute a heartbeat.</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 心跳间隔，单位：毫秒</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否关闭</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeServer</span><span class="params">(Server server)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"server == null"</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 读取心跳相关配置</span></span><br /><span class="line">    <span class="keyword">this</span>.server = server;</span><br /><span class="line">    <span class="keyword">this</span>.heartbeat = server.getUrl().getParameter(Constants.HEARTBEAT_KEY, <span class="number">0</span>);</span><br /><span class="line">    <span class="keyword">this</span>.heartbeatTimeout = server.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);</span><br /><span class="line">    <span class="keyword">if</span> (heartbeatTimeout &lt; heartbeat * <span class="number">2</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"heartbeatTimeout &lt; heartbeatInterval * 2"</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 发起心跳定时器</span></span><br /><span class="line">    startHeatbeatTimer();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="4-1-2-发起心跳定时器">4.1.2 发起心跳定时器</h3>
<blockquote>
<p>代码实现上，和 HeaderExchangeClient 的类似。</p>
</blockquote>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeatbeatTimer</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 停止原有定时任务</span></span><br /><span class="line">    stopHeartbeatTimer();</span><br /><span class="line">    <span class="comment">// 发起新的定时任务</span></span><br /><span class="line">    <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) {</span><br /><span class="line">        heatbeatTimer = scheduled.scheduleWithFixedDelay(</span><br /><span class="line">                <span class="keyword">new</span> HeartBeatTask(<span class="keyword">new</span> HeartBeatTask.ChannelProvider() {</span><br /><span class="line">                    <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>{</span><br /><span class="line">                        <span class="keyword">return</span> Collections.unmodifiableCollection(HeaderExchangeServer.<span class="keyword">this</span>.getChannels());</span><br /><span class="line">                    }</span><br /><span class="line">                }, heartbeat, heartbeatTimeout),</span><br /><span class="line">                heartbeat, heartbeat, TimeUnit.MILLISECONDS);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>差异，Server 持有<strong>多条</strong>&nbsp;Client 连接的 Channel ，所以通过 ChannelProvider 返回的是<strong>多条</strong>。</li>
</ul>
<h3 id="4-1-3-重置属性">4.1.3 重置属性</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">    <span class="comment">// 重置服务器</span></span><br /><span class="line">    server.reset(url);</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        <span class="keyword">if</span> (url.hasParameter(Constants.HEARTBEAT_KEY)</span><br /><span class="line">                || url.hasParameter(Constants.HEARTBEAT_TIMEOUT_KEY)) {</span><br /><span class="line">            <span class="keyword">int</span> h = url.getParameter(Constants.HEARTBEAT_KEY, heartbeat);</span><br /><span class="line">            <span class="keyword">int</span> t = url.getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, h * <span class="number">3</span>);</span><br /><span class="line">            <span class="keyword">if</span> (t &lt; h * <span class="number">2</span>) {</span><br /><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"heartbeatTimeout &lt; heartbeatInterval * 2"</span>);</span><br /><span class="line">            }</span><br /><span class="line">            <span class="comment">// 重置定时任务</span></span><br /><span class="line">            <span class="keyword">if</span> (h != heartbeat || t != heartbeatTimeout) {</span><br /><span class="line">                heartbeat = h;</span><br /><span class="line">                heartbeatTimeout = t;</span><br /><span class="line">                startHeatbeatTimer();</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">        logger.error(t.getMessage(), t);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="4-1-4-优雅关闭">4.1.4 优雅关闭</h3>
<blockquote>
<p>代码实现上，和 HeaderExchangeChannel 的类似，且复杂一些。</p>
</blockquote>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> timeout)</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 关闭</span></span><br /><span class="line"> <span class="number">4</span>:     startClose();</span><br /><span class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">6</span>:         <span class="keyword">final</span> <span class="keyword">long</span> max = (<span class="keyword">long</span>) timeout;</span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br /><span class="line"> <span class="number">8</span>:         <span class="comment">// 发送 READONLY 事件给所有 Client ，表示 Server 不可读了。</span></span><br /><span class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (getUrl().getParameter(Constants.CHANNEL_SEND_READONLYEVENT_KEY, <span class="keyword">true</span>)) {</span><br /><span class="line"><span class="number">10</span>:             sendChannelReadOnlyEvent();</span><br /><span class="line"><span class="number">11</span>:         }</span><br /><span class="line"><span class="number">12</span>:         <span class="comment">// 等待请求完成</span></span><br /><span class="line"><span class="number">13</span>:         <span class="keyword">while</span> (HeaderExchangeServer.<span class="keyword">this</span>.isRunning() &amp;&amp; System.currentTimeMillis() - start &lt; max) {</span><br /><span class="line"><span class="number">14</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">15</span>:                 Thread.sleep(<span class="number">10</span>);</span><br /><span class="line"><span class="number">16</span>:             } <span class="keyword">catch</span> (InterruptedException e) {</span><br /><span class="line"><span class="number">17</span>:                 logger.warn(e.getMessage(), e);</span><br /><span class="line"><span class="number">18</span>:             }</span><br /><span class="line"><span class="number">19</span>:         }</span><br /><span class="line"><span class="number">20</span>:     }</span><br /><span class="line"><span class="number">21</span>:     <span class="comment">// 关闭心跳定时器</span></span><br /><span class="line"><span class="number">22</span>:     doClose();</span><br /><span class="line"><span class="number">23</span>:     <span class="comment">// 关闭服务器</span></span><br /><span class="line"><span class="number">24</span>:     server.close(timeout);</span><br /><span class="line"><span class="number">25</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>Server 关闭的过程，分成<strong>两个阶段</strong>：正在关闭和已经关闭。</li>
<li>
<p>第 4 行：调用&nbsp;<code>#startClose()</code>&nbsp;方法，标记正在关闭。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span> </span>{</span><br /><span class="line">    server.startClose();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// AbstractPeer.java</span></span><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (isClosed()) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    closing = <span class="keyword">true</span>;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>第 8 至 11 行：发送&nbsp;<strong>READONLY</strong>&nbsp;事件给所有 Client ，表示 Server 不再接收新的消息，避免不断有<strong>新的消息</strong>接收到。杂实现的呢？以 DubboInvoker 举例子，<code>#isAvailable()</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (!<span class="keyword">super</span>.isAvailable())</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br /><span class="line">    <span class="keyword">for</span> (ExchangeClient client : clients) {</span><br /><span class="line">        <span class="keyword">if</span> (client.isConnected() &amp;&amp; !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY)) { <span class="comment">// 只读判断</span></span><br /><span class="line">            <span class="comment">//cannot write == not Available ?</span></span><br /><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>即使&nbsp;<code>client</code>&nbsp;处于<strong>连接中</strong>，但是 Server 处于<strong>正在关闭中</strong>，也算<strong>不可用</strong>，不进行发送请求( 消息 )。</li>
</ul>
</li>
<li>
<p><code>#sendChannelReadOnlyEvent()</code>&nbsp;方法，广播客户端，READONLY_EVENT 事件。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendChannelReadOnlyEvent</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 READONLY_EVENT 请求</span></span><br /><span class="line">    Request request = <span class="keyword">new</span> Request();</span><br /><span class="line">    request.setEvent(Request.READONLY_EVENT);</span><br /><span class="line">    request.setTwoWay(<span class="keyword">false</span>); <span class="comment">// 无需响应</span></span><br /><span class="line">    request.setVersion(Version.getVersion());</span><br /><br /><span class="line">    <span class="comment">// 发送给所有 Client</span></span><br /><span class="line">    Collection&lt;Channel&gt; channels = getChannels();</span><br /><span class="line">    <span class="keyword">for</span> (Channel channel : channels) {</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="keyword">if</span> (channel.isConnected())</span><br /><span class="line">                channel.send(request, getUrl().getParameter(Constants.CHANNEL_READONLYEVENT_SENT_KEY, <span class="keyword">true</span>));</span><br /><span class="line">        } <span class="keyword">catch</span> (RemotingException e) {</span><br /><span class="line">            logger.warn(<span class="string">"send connot write messge error."</span>, e);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>第 22 行：调用&nbsp;<code>#oClose()</code>&nbsp;方法，关闭心跳定时器。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (!closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    stopHeartbeatTimer();</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        scheduled.shutdown();</span><br /><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">        logger.warn(t.getMessage(), t);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>第 24 行：<strong>真正</strong>关闭服务器。</p>
</li>
</ul>
<h2 id="4-2-ExchangeServerDelegate">4.2 ExchangeServerDelegate</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/31b3f1e868ed2d62c97a26b5cd233a921ce2205a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/ExchangeServerDelegate.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.exchange.support.ExchangeServerDelegate</code></a>&nbsp;，实现 ExchangeServer 接口，信息交换服务器装饰者。在每个实现的方法里，直接调用被装饰的&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/31b3f1e868ed2d62c97a26b5cd233a921ce2205a/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/ExchangeServerDelegate.java#L34" target="_blank" rel="external nofollow noopener noreferrer"><code>server</code></a>&nbsp;属性的方法。</p>
<p>目前&nbsp;<code>dubbo-remoting-p2p</code>&nbsp;模块中，ExchangeServerPeer 会继承该类，后续再看。</p>
<h1 id="5-请求-响应模型">5. 请求/响应模型</h1>
<h2 id="5-1-Request">5.1 Request</h2>
<p><code>com.alibaba.dubbo.remoting.exchange.Request</code>&nbsp;，请求。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 事件 - 心跳</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEARTBEAT_EVENT = <span class="keyword">null</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 事件 - 只读</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String READONLY_EVENT = <span class="string">"R"</span>;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 请求编号自增序列</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong INVOKE_ID = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 请求编号</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mId;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Dubbo 版本</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> String mVersion;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否需要响应</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * true-需要</span></span><br /><span class="line"><span class="comment"> * false-不需要</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mTwoWay = <span class="keyword">true</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否是事件。例如，心跳事件。</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mEvent = <span class="keyword">false</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否异常的请求。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 在消息解析的时候，会出现。</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mBroken = <span class="keyword">false</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 数据</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Object mData;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>内置两种事件：
<ul>
<li><code>HEARTBEAT_EVENT</code>&nbsp;：心跳。因为心跳比较常用，所以在事件上时候了&nbsp;<code>null</code>&nbsp;。</li>
<li><code>READONLY_EVENT</code>&nbsp;：只读。上文已经解释。</li>
</ul>
</li>
<li>
<p><code>mId</code>&nbsp;属性：编号。使用&nbsp;<code>INVOKE_ID</code>&nbsp;属性生成，JVM 进程内唯一。生成代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">newId</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// getAndIncrement() When it grows to MAX_VALUE, it will grow to MIN_VALUE, and the negative can be used as ID</span></span><br /><span class="line">    <span class="keyword">return</span> INVOKE_ID.getAndIncrement();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><code>version</code>&nbsp;属性，版本号。目前使用 Dubbo 大版本，<code>"2.0.0"</code>&nbsp;。</p>
</li>
<li><code>mTwoWay</code>&nbsp;属性，标记请求是否响应( Response )，默认<strong>需要</strong>。</li>
<li><code>mBroken</code>&nbsp;属性，是否异常的请求。在消息解析的时候，会出现。</li>
<li><code>mData</code>&nbsp;属性，请求具体数据。</li>
</ul>
<h2 id="5-2-Response">5.2 Response</h2>
<p><code>com.alibaba.dubbo.remoting.exchange.Response</code>&nbsp;，响应。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 响应编号</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 一个 {<span class="doctag">@link</span> Request#mId} 和 {<span class="doctag">@link</span> Response#mId} 一一对应。</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mId = <span class="number">0</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 版本</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> String mVersion;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 状态</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span> mStatus = OK;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否事件</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mEvent = <span class="keyword">false</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 错误消息</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> String mErrorMsg;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 结果</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Object mResult;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>mId</code>&nbsp;属性，响应编号，和请求编号一致。</li>
<li><code>mStatus</code>&nbsp;属性，状态。有多种状态：[状态码] (<a href="https://github.com/apache/incubator-dubbo/blob/9deadadea3b1342345fed77c87a3d24ea026d7e6/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/Response.java)%E3%80%82" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/apache/incubator-dubbo/blob/9deadadea3b1342345fed77c87a3d24ea026d7e6/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/Response.java)。</a></li>
<li><code>mEvent</code>&nbsp;属性，是否事件。和 Request 内置了<strong>一样</strong>的事件，但是&nbsp;<code>READONLY_EVENT</code>&nbsp;并未使用。因为目前，只读事件，无需响应。</li>
<li><code>mErrorMsg</code>&nbsp;属性，错误消息。</li>
<li><code>mResult</code>&nbsp;属性，结果。</li>
</ul>
<h2 id="5-3-ResponseFuture">5.3 ResponseFuture</h2>
<p><code>com.alibaba.dubbo.remoting.exchange.ResponseFuture</code>&nbsp;，响应 Future&nbsp;<strong>接口</strong>。方法如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// 获得值</span></span><br /><span class="line"><span class="function">Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException</span>;</span><br /><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeoutInMillis)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br /><br /><span class="line"><span class="comment">// 设置回调</span></span><br /><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(ResponseCallback callback)</span></span>;</span><br /><br /><span class="line"><span class="comment">// 是否完成</span></span><br /><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p>和&nbsp;<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html" target="_blank" rel="external nofollow noopener noreferrer"><code>java.util.concurrent.Future</code></a>&nbsp;很类似。</p>
<h3 id="5-3-1-ResponseCallback">5.3.1 ResponseCallback</h3>
<p><code>com.alibaba.dubbo.remoting.exchange.ResponseCallback</code>&nbsp;，响应回调<strong>接口</strong>。方法如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// 处理执行完成</span></span><br /><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">done</span><span class="params">(Object response)</span></span>;</span><br /><br /><span class="line"><span class="comment">// 处理发生异常</span></span><br /><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">caught</span><span class="params">(Throwable exception)</span></span>;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p>ResponseCallback 在&nbsp;<code>com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter</code>&nbsp;中有使用，后面我们会有文章来分享 FutureFilter 。</p>
<h3 id="5-3-2-DefaultFuture">5.3.2 DefaultFuture</h3>
<p><code>com.alibaba.dubbo.remoting.exchange.support.DefaultFuture</code>&nbsp;，实现 ResponseFuture 接口，<strong>默认</strong>响应 Future 实现类。同时，它也是所有 DefaultFuture 的管理容器。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 通道集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key：请求编号</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, Channel&gt; CHANNELS = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, Channel&gt;();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Future 集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key：请求编号</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, DefaultFuture&gt; FUTURES = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, DefaultFuture&gt;();</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 请求编号</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="comment">// invoke id.</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 通道</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 请求</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Request request;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 超时</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> timeout;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 创建开始时间</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 发送请求时间</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> sent;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 响应</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Response response;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 回调</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ResponseCallback callback;</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br /><span class="line">    <span class="keyword">this</span>.request = request;</span><br /><span class="line">    <span class="keyword">this</span>.id = request.getId();</span><br /><span class="line">    <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br /><span class="line">    <span class="comment">// put into waiting map.</span></span><br /><span class="line">    FUTURES.put(id, <span class="keyword">this</span>);</span><br /><span class="line">    CHANNELS.put(id, channel);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>CHANNELS</code>&nbsp;<strong>静态</strong>属性，通道集合。通过&nbsp;<code>#hasFuture(channel)</code>&nbsp;方法，判断通道是否有未结束的请求。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasFuture</span><span class="params">(Channel channel)</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> CHANNELS.containsValue(channel);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><code>FUTURES</code>&nbsp;<strong>静态</strong>属性，Future 集合。</p>
</li>
<li>
<p><code>sent</code>&nbsp;属性，发送请求时间。因为在目前 Netty Mina 等通信框架中，发送请求一般是异步的，因此在&nbsp;<code>ChannelHandler#sent(channel, message)</code>&nbsp;方法中，调用&nbsp;<code>DefaultFuture#sent(channel, request)</code>&nbsp;<strong>静态方法</strong>，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Request request)</span> </span>{</span><br /><span class="line">    DefaultFuture future = FUTURES.get(request.getId());</span><br /><span class="line">    <span class="keyword">if</span> (future != <span class="keyword">null</span>) {</span><br /><span class="line">        future.doSent();</span><br /><span class="line">    }</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSent</span><span class="params">()</span> </span>{</span><br /><span class="line">    sent = System.currentTimeMillis();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><code>callback</code>&nbsp;属性，回调，适用于异步请求。通过&nbsp;<code>#setCallback(callback)</code>&nbsp;方法设置。</p>
</li>
</ul>
<p><strong>获得值</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 锁</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 完成 Condition</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition done = lock.newCondition();</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">  <span class="number">3</span>:     <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) {</span><br /><span class="line">  <span class="number">4</span>:         timeout = Constants.DEFAULT_TIMEOUT;</span><br /><span class="line">  <span class="number">5</span>:     }</span><br /><span class="line">  <span class="number">6</span>:     <span class="comment">// 若未完成，等待</span></span><br /><span class="line">  <span class="number">7</span>:     <span class="keyword">if</span> (!isDone()) {</span><br /><span class="line">  <span class="number">8</span>:         <span class="keyword">long</span> start = System.currentTimeMillis();</span><br /><span class="line">  <span class="number">9</span>:         lock.lock();</span><br /><span class="line"> <span class="number">10</span>:         <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">11</span>:             <span class="comment">// 等待完成或超时</span></span><br /><span class="line"> <span class="number">12</span>:             <span class="keyword">while</span> (!isDone()) {</span><br /><span class="line"> <span class="number">13</span>:                 done.await(timeout, TimeUnit.MILLISECONDS);</span><br /><span class="line"> <span class="number">14</span>:                 <span class="keyword">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) {</span><br /><span class="line"> <span class="number">15</span>:                     <span class="keyword">break</span>;</span><br /><span class="line"> <span class="number">16</span>:                 }</span><br /><span class="line"> <span class="number">17</span>:             }</span><br /><span class="line"> <span class="number">18</span>:         } <span class="keyword">catch</span> (InterruptedException e) {</span><br /><span class="line"> <span class="number">19</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br /><span class="line"> <span class="number">20</span>:         } <span class="keyword">finally</span> {</span><br /><span class="line"> <span class="number">21</span>:             lock.unlock();</span><br /><span class="line"> <span class="number">22</span>:         }</span><br /><span class="line"> <span class="number">23</span>:         <span class="comment">// 未完成，抛出超时异常 TimeoutException</span></span><br /><span class="line"> <span class="number">24</span>:         <span class="keyword">if</span> (!isDone()) {</span><br /><span class="line"> <span class="number">25</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(sent &gt; <span class="number">0</span>, channel, getTimeoutMessage(<span class="keyword">false</span>));</span><br /><span class="line"> <span class="number">26</span>:         }</span><br /><span class="line"> <span class="number">27</span>:     }</span><br /><span class="line"> <span class="number">28</span>:     <span class="comment">// 返回响应</span></span><br /><span class="line"> <span class="number">29</span>:     <span class="keyword">return</span> returnFromResponse();</span><br /><span class="line"> <span class="number">30</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 7 行：调用&nbsp;<code>#isDone()</code>&nbsp;方法，判断是否完成。若未完成，基于 Lock + Condition 的方式，实现等待。而等待的唤醒，通过&nbsp;<code>ChannelHandler#received(channel, message)</code>&nbsp;方法，接收到请求时执行&nbsp;<code>DefaultFuture#received(channel, response)</code>&nbsp;方法。🙂 下文详细解析。
<ul>
<li><a href="https://blog.csdn.net/ghsau/article/details/7481142" target="_blank" rel="external nofollow noopener noreferrer">《 Java线程(九)：Condition-线程通信更高效的方式》</a></li>
<li><a href="http://www.importnew.com/9281.html" target="_blank" rel="external nofollow noopener noreferrer">《怎么理解Condition》</a></li>
<li>第 8 行：获得开始时间。<strong>注意</strong>，此处使用的不是&nbsp;<code>start</code>&nbsp;属性。后面我们会看到，<code>#get(...)</code>&nbsp;方法中，使用的是<strong>重新</strong>获取开始时间；<strong>后台扫描调用超时任务</strong>，使用的是&nbsp;<code>start</code>&nbsp;属性。也就是说，<code>#get(timeout)</code>&nbsp;方法的&nbsp;<code>timeout</code>&nbsp;参数，指的是从当前时刻开始的<strong>等待超时</strong>时间。当然，这不影响最终的结果，最终 Response 是什么，由是&nbsp;<code>ChannelHandler#received(channel, message)</code>&nbsp;还是<strong>后台扫描调用超时任务</strong>，谁<strong>先调用</strong><code>DefaultFuture#received(channel, response)</code>&nbsp;方法决定。🙂 有点绕，胖友细看下。</li>
<li>第 9 行：获得锁。</li>
<li>第 11 至 17 行：等待<strong>完成</strong>或<strong>超时</strong>。</li>
<li>第 21 行：释放锁。</li>
<li>第 24 至 26 行：若未完成，抛出超时异常 TimeoutException 。
<ul>
<li><code>TimeoutException.phase</code>&nbsp;的阶段，由&nbsp;<code>sent &gt; 0</code>&nbsp;来决定，即 Client 是否发送给 Server 。</li>
<li><a href="https://github.com/apache/incubator-dubbo/blob/9deadadea3b1342345fed77c87a3d24ea026d7e6/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/DefaultFuture.java#L264-L275" target="_blank" rel="external nofollow noopener noreferrer"><code>#getTimeoutMessage(scan)</code></a>&nbsp;方法，获得超时异常提示信息。🙂 胖友自己看哈。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第 29 行：调用&nbsp;<code>#returnFromResponse()</code>&nbsp;方法，返回响应( Response )。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">returnFromResponse</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">    Response res = response;</span><br /><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null"</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 正常，返回结果</span></span><br /><span class="line">    <span class="keyword">if</span> (res.getStatus() == Response.OK) {</span><br /><span class="line">        <span class="keyword">return</span> res.getResult();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 超时，抛出 TimeoutException 异常</span></span><br /><span class="line">    <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 其他，抛出 RemotingException 异常</span></span><br /><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, res.getErrorMessage());</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<p><strong>响应结果</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">3</span>:         <span class="comment">// 移除 FUTURES</span></span><br /><span class="line"> <span class="number">4</span>:         DefaultFuture future = FUTURES.remove(response.getId());</span><br /><span class="line"> <span class="number">5</span>:         <span class="comment">// 接收结果</span></span><br /><span class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (future != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">7</span>:             future.doReceived(response);</span><br /><span class="line"> <span class="number">8</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">9</span>:             logger.warn(<span class="string">"The timeout response finally returned at "</span></span><br /><span class="line"><span class="number">10</span>:                     + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date()))</span><br /><span class="line"><span class="number">11</span>:                     + <span class="string">", response "</span> + response</span><br /><span class="line"><span class="number">12</span>:                     + (channel == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">", channel: "</span> + channel.getLocalAddress()</span><br /><span class="line"><span class="number">13</span>:                     + <span class="string">" -&gt; "</span> + channel.getRemoteAddress()));</span><br /><span class="line"><span class="number">14</span>:         }</span><br /><span class="line"><span class="number">15</span>:     <span class="comment">// 移除 CHANNELS</span></span><br /><span class="line"><span class="number">16</span>:     } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">17</span>:         CHANNELS.remove(response.getId());</span><br /><span class="line"><span class="number">18</span>:     }</span><br /><span class="line"><span class="number">19</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>该方法有两处被调用，如下图所示：<img src="http://static2.iocoder.cn/images/Dubbo/2018_12_10/05.png" alt="调用" /></li>
<li>第 4 行：移除&nbsp;<code>FUTURES</code>&nbsp;。</li>
<li>
<p>第 6 至 7 行：调用&nbsp;<code>DefaultFuture#doReceived(response)</code>&nbsp;方法，响应结果。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="comment">// 锁定</span></span><br /><span class="line"> <span class="number">3</span>:     lock.lock();</span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">5</span>:         <span class="comment">// 设置结果</span></span><br /><span class="line"> <span class="number">6</span>:         response = res;</span><br /><span class="line"> <span class="number">7</span>:         <span class="comment">// 通知，唤醒等待</span></span><br /><span class="line"> <span class="number">8</span>:         <span class="keyword">if</span> (done != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">9</span>:             done.signal();</span><br /><span class="line"><span class="number">10</span>:         }</span><br /><span class="line"><span class="number">11</span>:     } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">12</span>:         <span class="comment">// 释放锁定</span></span><br /><span class="line"><span class="number">13</span>:         lock.unlock();</span><br /><span class="line"><span class="number">14</span>:     }</span><br /><span class="line"><span class="number">15</span>:     <span class="comment">// 调用回调</span></span><br /><span class="line"><span class="number">16</span>:     <span class="keyword">if</span> (callback != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">17</span>:         invokeCallback(callback);</span><br /><span class="line"><span class="number">18</span>:     }</span><br /><span class="line"><span class="number">19</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 行：获得锁。</li>
<li>第 6 行：设置响应&nbsp;<code>response</code>&nbsp;。</li>
<li>第 8 至 10 行：调用&nbsp;<code>Condition#signal()</code>&nbsp;方法，通知，<strong>唤醒</strong>&nbsp;<code>DefaultFuture#get(..)</code>&nbsp;方法的等待。</li>
<li>第 13 行：释放锁。</li>
<li>第 16 至 18 行：调用&nbsp;<code>#invokeCallback(callback)</code>&nbsp;方法，执行回调方法。</li>
</ul>
</li>
<li>
<p>第 8 至 14 行：超时情况，打印<strong>告警</strong>日志。</p>
</li>
<li>第 15 至 18 行：移除&nbsp;<code>CHANNELS</code>&nbsp;。</li>
</ul>
<p><strong>设置回调</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(ResponseCallback callback)</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 已完成，调用回调</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (isDone()) {</span><br /><span class="line"> <span class="number">5</span>:         invokeCallback(callback);</span><br /><span class="line"> <span class="number">6</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">boolean</span> isdone = <span class="keyword">false</span>;</span><br /><span class="line"> <span class="number">8</span>:         <span class="comment">// 获得锁</span></span><br /><span class="line"> <span class="number">9</span>:         lock.lock();</span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">11</span>:             <span class="comment">// 未完成，设置回调</span></span><br /><span class="line"><span class="number">12</span>:             <span class="keyword">if</span> (!isDone()) {</span><br /><span class="line"><span class="number">13</span>:                 <span class="keyword">this</span>.callback = callback;</span><br /><span class="line"><span class="number">14</span>:             } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">15</span>:                 isdone = <span class="keyword">true</span>;</span><br /><span class="line"><span class="number">16</span>:             }</span><br /><span class="line"><span class="number">17</span>:         <span class="comment">// 释放锁</span></span><br /><span class="line"><span class="number">18</span>:         } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">19</span>:             lock.unlock();</span><br /><span class="line"><span class="number">20</span>:         }</span><br /><span class="line"><span class="number">21</span>:         <span class="comment">// 已完成，调用回调</span></span><br /><span class="line"><span class="number">22</span>:         <span class="keyword">if</span> (isdone) {</span><br /><span class="line"><span class="number">23</span>:             invokeCallback(callback);</span><br /><span class="line"><span class="number">24</span>:         }</span><br /><span class="line"><span class="number">25</span>:     }</span><br /><span class="line"><span class="number">26</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 至 5 行：若<strong>已完成</strong>，调用&nbsp;<code>#invokeCallback(callback)</code>&nbsp;方法，执行回调方法。</li>
<li>第 9 行：获得锁。</li>
<li>第 12 至 13 行：若<strong>未完成</strong>，设置回调&nbsp;<code>callback</code>&nbsp;属性，等在&nbsp;<code>#doReceived(response)</code>&nbsp;方法中<strong>再回调</strong>。</li>
<li>第 14 至 16 行：标记已完成。在【第 22 至 24 行】，调用&nbsp;<code>#invokeCallback(callback)</code>&nbsp;方法，执行回调方法。</li>
<li>第 18 至 20 行：释放锁。</li>
</ul>
<p><strong>调用回调</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeCallback</span><span class="params">(ResponseCallback c)</span> </span>{</span><br /><span class="line"> <span class="number">2</span>:     ResponseCallback callbackCopy = c;</span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (callbackCopy == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">4</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"callback cannot be null."</span>);</span><br /><span class="line"> <span class="number">5</span>:     }</span><br /><span class="line"> <span class="number">6</span>:     Response res = response;</span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (res == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">8</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null. url:"</span> + channel.getUrl());</span><br /><span class="line"> <span class="number">9</span>:     }</span><br /><span class="line"><span class="number">10</span>: </span><br /><span class="line"><span class="number">11</span>:     <span class="comment">// 正常，处理结果</span></span><br /><span class="line"><span class="number">12</span>:     <span class="keyword">if</span> (res.getStatus() == Response.OK) {</span><br /><span class="line"><span class="number">13</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">14</span>:             callbackCopy.done(res.getResult());</span><br /><span class="line"><span class="number">15</span>:         } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line"><span class="number">16</span>:             logger.error(<span class="string">"callback invoke error .reasult:"</span> + res.getResult() + <span class="string">",url:"</span> + channel.getUrl(), e);</span><br /><span class="line"><span class="number">17</span>:         }</span><br /><span class="line"><span class="number">18</span>:     <span class="comment">// 超时，处理 TimeoutException 异常</span></span><br /><span class="line"><span class="number">19</span>:     } <span class="keyword">else</span> <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {</span><br /><span class="line"><span class="number">20</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">21</span>:             TimeoutException te = <span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());</span><br /><span class="line"><span class="number">22</span>:             callbackCopy.caught(te);</span><br /><span class="line"><span class="number">23</span>:         } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line"><span class="number">24</span>:             logger.error(<span class="string">"callback invoke error ,url:"</span> + channel.getUrl(), e);</span><br /><span class="line"><span class="number">25</span>:         }</span><br /><span class="line"><span class="number">26</span>:     <span class="comment">// 其他，处理 RemotingException 异常</span></span><br /><span class="line"><span class="number">27</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">28</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">29</span>:             RuntimeException re = <span class="keyword">new</span> RuntimeException(res.getErrorMessage());</span><br /><span class="line"><span class="number">30</span>:             callbackCopy.caught(re);</span><br /><span class="line"><span class="number">31</span>:         } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line"><span class="number">32</span>:             logger.error(<span class="string">"callback invoke error ,url:"</span> + channel.getUrl(), e);</span><br /><span class="line"><span class="number">33</span>:         }</span><br /><span class="line"><span class="number">34</span>:     }</span><br /><span class="line"><span class="number">35</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>和&nbsp;<code>#returnFromResponse()</code>&nbsp;方法，情况一致。</li>
<li>第 11 至 17 行：正常返回，调用&nbsp;<code>ResponseCallback#done(result)</code>&nbsp;方法，处理结果。</li>
<li>第 18 至 25 行：超时异常，调用&nbsp;<code>ResponseCallback#caught(e)</code>&nbsp;方法，处理 TimeoutException 异常。</li>
<li>第 26 至 34 行：其他异常，调用 ResponseCallback#caught(e)` 方法，处理 RuntimeException 异常。</li>
</ul>
<p><strong>后台扫描调用超时任务</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">static</span> {</span><br /><span class="line">    Thread th = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RemotingInvocationTimeoutScan(), <span class="string">"DubboResponseTimeoutScanTimer"</span>);</span><br /><span class="line">    th.setDaemon(<span class="keyword">true</span>);</span><br /><span class="line">    th.start();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RemotingInvocationTimeoutScan</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br /><span class="line">            <span class="keyword">try</span> {</span><br /><span class="line">                <span class="keyword">for</span> (DefaultFuture future : FUTURES.values()) {</span><br /><span class="line">                    <span class="comment">// 已完成，跳过</span></span><br /><span class="line">                    <span class="keyword">if</span> (future == <span class="keyword">null</span> || future.isDone()) {</span><br /><span class="line">                        <span class="keyword">continue</span>;</span><br /><span class="line">                    }</span><br /><span class="line">                    <span class="comment">// 超时</span></span><br /><span class="line">                    <span class="keyword">if</span> (System.currentTimeMillis() - future.getStartTimestamp() &gt; future.getTimeout()) {</span><br /><span class="line">                        <span class="comment">// 创建超时 Response</span></span><br /><span class="line">                        <span class="comment">// create exception response.</span></span><br /><span class="line">                        Response timeoutResponse = <span class="keyword">new</span> Response(future.getId());</span><br /><span class="line">                        <span class="comment">// set timeout status.</span></span><br /><span class="line">                        timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);</span><br /><span class="line">                        timeoutResponse.setErrorMessage(future.getTimeoutMessage(<span class="keyword">true</span>));</span><br /><span class="line">                        <span class="comment">// 响应结果</span></span><br /><span class="line">                        <span class="comment">// handle response.</span></span><br /><span class="line">                        DefaultFuture.received(future.getChannel(), timeoutResponse);</span><br /><span class="line">                    }</span><br /><span class="line">                }</span><br /><span class="line">                <span class="comment">// 30 ms</span></span><br /><span class="line">                Thread.sleep(<span class="number">30</span>);</span><br /><span class="line">            } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">                logger.error(<span class="string">"Exception when scan the timeout invocation of remoting."</span>, e);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>🙂 代码比较简单，胖友自己看下代码和注释嘿。</li>
</ul>
<hr />
<p>代码略多，胖友自己在梳理梳理，也可以多多调试。</p>
<h3 id="5-3-3-SimpleFuture">5.3.3 SimpleFuture</h3>
<p><a href="https://github.com/apache/incubator-dubbo/blob/9deadadea3b1342345fed77c87a3d24ea026d7e6/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/SimpleFuture.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.exchange.support.SimpleFuture</code></a>&nbsp;，实现 ResponseFuture 接口，简单的 Future 实现。</p>
<p>目前暂未使用。</p>
<h2 id="5-4-MultiMessage">5.4 MultiMessage</h2>
<p><code>com.alibaba.dubbo.remoting.exchange.support.MultiMessage</code>&nbsp;，实现 Iterable 接口，多消息的封装。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiMessage</span> <span class="keyword">implements</span> <span class="title">Iterable</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List messages = <span class="keyword">new</span> ArrayList();</span><br />    <br /><span class="line">    <span class="comment">// ... 省略方法</span></span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="6-Handler">6. Handler</h1>
<p>在文初的，我们在类图可以看到，有多种处理器，统一在本小节分享。</p>
<h2 id="6-1-HeartbeatHandler">6.1 HeartbeatHandler</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/619cbe46350c8d0b97b84631c6518e4603a89aee/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeartbeatHandler.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.exchange.support.header.HeartbeatHandler</code></a>&nbsp;，实现 AbstractChannelHandlerDelegate 抽象类，<strong>心跳处理器</strong>，处理心跳事件。</p>
<blockquote>
<p>旁白君，注意，它是一个 AbstractChannelHandlerDelegate ！！！</p>
</blockquote>
<p>代码比较简单，胖友自己查看。</p>
<h3 id="6-1-1-HeartBeatTask">6.1.1 HeartBeatTask</h3>
<p><code>com.alibaba.dubbo.remoting.exchange.support.header.HeartBeatTask</code>&nbsp;，实现 Runnable 接口，心跳任务。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> ChannelProvider channelProvider;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 心跳间隔，单位：毫秒</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 心跳超时时间，单位：毫秒</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>channelProvider</code>&nbsp;属性，用于查询获得需要心跳的通道数组。ChannelProvider 接口，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChannelProvider</span> </span>{</span><br /><span class="line">    <span class="function">Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span></span>;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<p><strong>执行任务</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">4</span>:         <span class="keyword">long</span> now = System.currentTimeMillis();</span><br /><span class="line"> <span class="number">5</span>:         <span class="keyword">for</span> (Channel channel : channelProvider.getChannels()) {</span><br /><span class="line"> <span class="number">6</span>:             <span class="keyword">if</span> (channel.isClosed()) {</span><br /><span class="line"> <span class="number">7</span>:                 <span class="keyword">continue</span>;</span><br /><span class="line"> <span class="number">8</span>:             }</span><br /><span class="line"> <span class="number">9</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">10</span>:                 Long lastRead = (Long) channel.getAttribute(HeaderExchangeHandler.KEY_READ_TIMESTAMP);</span><br /><span class="line"><span class="number">11</span>:                 Long lastWrite = (Long) channel.getAttribute(HeaderExchangeHandler.KEY_WRITE_TIMESTAMP);</span><br /><span class="line"><span class="number">12</span>:                 <span class="comment">// 最后读写的时间，任一超过心跳间隔，发送心跳</span></span><br /><span class="line"><span class="number">13</span>:                 <span class="keyword">if</span> ((lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeat)</span><br /><span class="line"><span class="number">14</span>:                         || (lastWrite != <span class="keyword">null</span> &amp;&amp; now - lastWrite &gt; heartbeat)) {</span><br /><span class="line"><span class="number">15</span>:                     Request req = <span class="keyword">new</span> Request();</span><br /><span class="line"><span class="number">16</span>:                     req.setVersion(<span class="string">"2.0.0"</span>);</span><br /><span class="line"><span class="number">17</span>:                     req.setTwoWay(<span class="keyword">true</span>); <span class="comment">// 需要响应</span></span><br /><span class="line"><span class="number">18</span>:                     req.setEvent(Request.HEARTBEAT_EVENT);</span><br /><span class="line"><span class="number">19</span>:                     channel.send(req);</span><br /><span class="line"><span class="number">20</span>:                     <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br /><span class="line"><span class="number">21</span>:                         logger.debug(<span class="string">"Send heartbeat to remote channel "</span> + channel.getRemoteAddress()</span><br /><span class="line"><span class="number">22</span>:                                 + <span class="string">", cause: The channel has no data-transmission exceeds a heartbeat period: "</span> + heartbeat + <span class="string">"ms"</span>);</span><br /><span class="line"><span class="number">23</span>:                     }</span><br /><span class="line"><span class="number">24</span>:                 }</span><br /><span class="line"><span class="number">25</span>:                 <span class="comment">// 最后读的时间，超过心跳超时时间</span></span><br /><span class="line"><span class="number">26</span>:                 <span class="keyword">if</span> (lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeatTimeout) {</span><br /><span class="line"><span class="number">27</span>:                     logger.warn(<span class="string">"Close channel "</span> + channel</span><br /><span class="line"><span class="number">28</span>:                             + <span class="string">", because heartbeat read idle time out: "</span> + heartbeatTimeout + <span class="string">"ms"</span>);</span><br /><span class="line"><span class="number">29</span>:                     <span class="comment">// 客户端侧，重新连接服务端</span></span><br /><span class="line"><span class="number">30</span>:                     <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> Client) {</span><br /><span class="line"><span class="number">31</span>:                         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">32</span>:                             ((Client) channel).reconnect();</span><br /><span class="line"><span class="number">33</span>:                         } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line"><span class="number">34</span>:                             <span class="comment">//do nothing</span></span><br /><span class="line"><span class="number">35</span>:                         }</span><br /><span class="line"><span class="number">36</span>:                     <span class="comment">// 服务端侧，关闭客户端连接</span></span><br /><span class="line"><span class="number">37</span>:                     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">38</span>:                         channel.close();</span><br /><span class="line"><span class="number">39</span>:                     }</span><br /><span class="line"><span class="number">40</span>:                 }</span><br /><span class="line"><span class="number">41</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">42</span>:                 logger.warn(<span class="string">"Exception when heartbeat to remote channel "</span> + channel.getRemoteAddress(), t);</span><br /><span class="line"><span class="number">43</span>:             }</span><br /><span class="line"><span class="number">44</span>:         }</span><br /><span class="line"><span class="number">45</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">46</span>:         logger.warn(<span class="string">"Unhandled exception when heartbeat, cause: "</span> + t.getMessage(), t);</span><br /><span class="line"><span class="number">47</span>:     }</span><br /><span class="line"><span class="number">48</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>【任务一】第 13 至 24 行：最后读或写的时间，<strong>任一</strong>超过心跳间隔&nbsp;<code>heartbeat</code>&nbsp;，<strong>发送心跳</strong>。</li>
<li>【任务二】第 25 至 40 行：最后读的时间，超过心跳超时时间&nbsp;<code>heartbeatTimeout</code>&nbsp;，分成两种情况：
<ul>
<li>第 29 至 35 行：<strong>客户端侧</strong>，重连连接服务端。</li>
<li>第 36 至 39 行：<strong>服务端侧</strong>，关闭客户端连接。</li>
</ul>
</li>
</ul>
<h2 id="6-2-HeaderExchangeHandler">6.2 HeaderExchangeHandler</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/e24730a1dcfe8d5f1329377e80b1577724a85aac/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeHandler.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler</code></a>，实现 ChannelHandlerDelegate 接口，<strong>基于消息头部( Header )</strong>的信息交换处理器实现类。</p>
<blockquote>
<p>旁白君，注意，它是一个 ChannelHandlerDelegate ！！！</p>
</blockquote>
<p>代码比较简单，胖友自己查看，我们挑几个比较重要的来讲讲。</p>
<p><strong>接收消息</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 设置最后的读时间</span></span><br /><span class="line"> <span class="number">4</span>:     channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br /><span class="line"> <span class="number">5</span>:     <span class="comment">// 创建 ExchangeChannel 对象</span></span><br /><span class="line"> <span class="number">6</span>:     ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">8</span>:         <span class="comment">// 处理请求( Request )</span></span><br /><span class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) {</span><br /><span class="line"><span class="number">10</span>:             <span class="comment">// handle request.</span></span><br /><span class="line"><span class="number">11</span>:             Request request = (Request) message;</span><br /><span class="line"><span class="number">12</span>:             <span class="comment">// 处理事件请求</span></span><br /><span class="line"><span class="number">13</span>:             <span class="keyword">if</span> (request.isEvent()) {</span><br /><span class="line"><span class="number">14</span>:                 handlerEvent(channel, request);</span><br /><span class="line"><span class="number">15</span>:             } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">16</span>:                 <span class="comment">// 处理普通请求</span></span><br /><span class="line"><span class="number">17</span>:                 <span class="keyword">if</span> (request.isTwoWay()) {</span><br /><span class="line"><span class="number">18</span>:                     Response response = handleRequest(exchangeChannel, request);</span><br /><span class="line"><span class="number">19</span>:                     channel.send(response);</span><br /><span class="line"><span class="number">20</span>:                 <span class="comment">// 提交给装饰的 `handler`，继续处理</span></span><br /><span class="line"><span class="number">21</span>:                 } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">22</span>:                     handler.received(exchangeChannel, request.getData());</span><br /><span class="line"><span class="number">23</span>:                 }</span><br /><span class="line"><span class="number">24</span>:             }</span><br /><span class="line"><span class="number">25</span>:         <span class="comment">// 处理响应( Response )</span></span><br /><span class="line"><span class="number">26</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) {</span><br /><span class="line"><span class="number">27</span>:             handleResponse(channel, (Response) message);</span><br /><span class="line"><span class="number">28</span>:         <span class="comment">// 处理 String</span></span><br /><span class="line"><span class="number">29</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) {</span><br /><span class="line"><span class="number">30</span>:             <span class="comment">// 客户端侧，不支持 String</span></span><br /><span class="line"><span class="number">31</span>:             <span class="keyword">if</span> (isClientSide(channel)) {</span><br /><span class="line"><span class="number">32</span>:                 Exception e = <span class="keyword">new</span> Exception(<span class="string">"Dubbo client can not supported string message: "</span> + message + <span class="string">" in channel: "</span> + channel + <span class="string">", url: "</span> + channel.getUrl());</span><br /><span class="line"><span class="number">33</span>:                 logger.error(e.getMessage(), e);</span><br /><span class="line"><span class="number">34</span>:             <span class="comment">// 服务端侧，目前是 telnet 命令</span></span><br /><span class="line"><span class="number">35</span>:             } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">36</span>:                 String echo = handler.telnet(channel, (String) message);</span><br /><span class="line"><span class="number">37</span>:                 <span class="keyword">if</span> (echo != <span class="keyword">null</span> &amp;&amp; echo.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">38</span>:                     channel.send(echo);</span><br /><span class="line"><span class="number">39</span>:                 }</span><br /><span class="line"><span class="number">40</span>:             }</span><br /><span class="line"><span class="number">41</span>:             <span class="comment">// 提交给装饰的 `handler`，继续处理</span></span><br /><span class="line"><span class="number">42</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">43</span>:             handler.received(exchangeChannel, message);</span><br /><span class="line"><span class="number">44</span>:         }</span><br /><span class="line"><span class="number">45</span>:     } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">46</span>:         <span class="comment">// 移除 ExchangeChannel 对象，若已断开</span></span><br /><span class="line"><span class="number">47</span>:         HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br /><span class="line"><span class="number">48</span>:     }</span><br /><span class="line"><span class="number">49</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 4 行：设置最后的<strong>读时间</strong>。</li>
<li>第 6 行：创建 ExchangeChannel 对象。</li>
<li>第 8 至 24 行：处理请求( Request)
<ul>
<li>第 13 至 14 行：调用&nbsp;<code>#handlerEvent(channel, request)</code>&nbsp;方法，处理事件请求。</li>
<li>第 17 至 19 行：调用&nbsp;<code>#handleRequest(channel, request)</code>&nbsp;方法，处理普通请求（需要响应），并将响应写回请求方。</li>
<li>第 21 至 23 行：调用&nbsp;<code>ChannelHandler#received(channel, message)</code>&nbsp;方法，处理普通请求（无需响应）。</li>
</ul>
</li>
<li>第 25 至 27 行：调用&nbsp;<code>#handleResponse(channel, message)</code>&nbsp;方法，处理响应。</li>
<li>第 29 至 41 行：处理 String 的情况
<ul>
<li>第 30 至 33 行：客户端侧，不支持 String 的情况。</li>
<li>第 34 至 40 行：服务端侧，目前仅有 telnet 命令的情况，调用&nbsp;<code>TelnetHandler#telnet(channel, message)</code>&nbsp;方法，获得 telnet 命令的结果，并响应给 telnet 客户端。在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-api-telnet/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（三）之 Telnet 层》</a>&nbsp;有详细分享。</li>
</ul>
</li>
<li>第 42 至 44 行：剩余的情况，调用&nbsp;<code>ChannelHandler#received(channel, message)</code>&nbsp;方法，处理。</li>
<li>第 45 至 48 行：移除 ExchangeChannel 对象，若已断开。</li>
<li>
<p><code>#handlerEvent(channel, request)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handlerEvent</span><span class="params">(Channel channel, Request req)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (req.getData() != <span class="keyword">null</span> &amp;&amp; req.getData().equals(Request.READONLY_EVENT)) {</span><br /><span class="line">        channel.setAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY, Boolean.TRUE);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>客户端接收到 READONLY_EVENT 事件请求，进行记录到通道。后续，不再向该服务器，<strong>发送新的请求</strong>。</li>
</ul>
</li>
<li>
<p><code>#handleRequest(channel, request)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function">Response <span class="title">handleRequest</span><span class="params">(ExchangeChannel channel, Request req)</span> </span>{</span><br /><span class="line"> <span class="number">2</span>:     Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 请求无法解析，返回 BAD_REQUEST 响应</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (req.isBroken()) {</span><br /><span class="line"> <span class="number">5</span>:         Object data = req.getData();</span><br /><span class="line"> <span class="number">6</span>:         String msg; <span class="comment">// 请求数据，转成 msg</span></span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">if</span> (data == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">8</span>:             msg = <span class="keyword">null</span>;</span><br /><span class="line"> <span class="number">9</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> Throwable) {</span><br /><span class="line"><span class="number">10</span>:             msg = StringUtils.toString((Throwable) data);</span><br /><span class="line"><span class="number">11</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">12</span>:             msg = data.toString();</span><br /><span class="line"><span class="number">13</span>:         }</span><br /><span class="line"><span class="number">14</span>:         res.setErrorMessage(<span class="string">"Fail to decode request due to: "</span> + msg);</span><br /><span class="line"><span class="number">15</span>:         res.setStatus(Response.BAD_REQUEST);</span><br /><span class="line"><span class="number">16</span>:         <span class="keyword">return</span> res;</span><br /><span class="line"><span class="number">17</span>:     }</span><br /><span class="line"><span class="number">18</span>:     <span class="comment">// 使用 ExchangeHandler 处理，并返回响应</span></span><br /><span class="line"><span class="number">19</span>:     <span class="comment">// find handler by message class.</span></span><br /><span class="line"><span class="number">20</span>:     Object msg = req.getData();</span><br /><span class="line"><span class="number">21</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">22</span>:         <span class="comment">// handle data.</span></span><br /><span class="line"><span class="number">23</span>:         Object result = handler.reply(channel, msg);</span><br /><span class="line"><span class="number">24</span>:         res.setStatus(Response.OK);</span><br /><span class="line"><span class="number">25</span>:         res.setResult(result);</span><br /><span class="line"><span class="number">26</span>:     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">27</span>:         res.setStatus(Response.SERVICE_ERROR);</span><br /><span class="line"><span class="number">28</span>:         res.setErrorMessage(StringUtils.toString(e));</span><br /><span class="line"><span class="number">29</span>:     }</span><br /><span class="line"><span class="number">30</span>:     <span class="keyword">return</span> res;</span><br /><span class="line"><span class="number">31</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 至 17 行：请求<strong>无法解析</strong>，返回 BAD_REQUEST 响应。下面 ExchangeCodec ，我们将看到具体发生的代码。</li>
<li>第 18 至 30 行：调用&nbsp;<code>ExchangeHandler#reply(channel, message)</code>&nbsp;方法，返回结果，并设置到响应( Response) 最终返回。</li>
</ul>
</li>
<li>
<p><code>#handleResponse(channel, response)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(Channel channel, Response response)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; !response.isHeartbeat()) {</span><br /><span class="line">        DefaultFuture.received(channel, response);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>非心跳事件响应，调用&nbsp;<code>DefaultFuture#received(channel, response)</code>&nbsp;方法，唤醒等待请求结果的线程。</li>
</ul>
</li>
</ul>
<p>🙂 比较繁杂，胖友耐心的看一看哟。</p>
<p><strong>发生异常</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 当发生 ExecutionException 异常，返回异常响应( Response )</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ExecutionException) {</span><br /><span class="line"> <span class="number">5</span>:         ExecutionException e = (ExecutionException) exception;</span><br /><span class="line"> <span class="number">6</span>:         Object msg = e.getRequest();</span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Request) {</span><br /><span class="line"> <span class="number">8</span>:             Request req = (Request) msg;</span><br /><span class="line"> <span class="number">9</span>:             <span class="keyword">if</span> (req.isTwoWay() &amp;&amp; !req.isHeartbeat()) { <span class="comment">// 需要响应，并且非心跳时间</span></span><br /><span class="line"><span class="number">10</span>:                 Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br /><span class="line"><span class="number">11</span>:                 res.setStatus(Response.SERVER_ERROR);</span><br /><span class="line"><span class="number">12</span>:                 res.setErrorMessage(StringUtils.toString(e));</span><br /><span class="line"><span class="number">13</span>:                 channel.send(res);</span><br /><span class="line"><span class="number">14</span>:                 <span class="keyword">return</span>;</span><br /><span class="line"><span class="number">15</span>:             }</span><br /><span class="line"><span class="number">16</span>:         }</span><br /><span class="line"><span class="number">17</span>:     }</span><br /><span class="line"><span class="number">18</span>:     <span class="comment">// 创建 ExchangeChannel 对象</span></span><br /><span class="line"><span class="number">19</span>:     ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br /><span class="line"><span class="number">20</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">21</span>:         <span class="comment">// 提交给装饰的 `handler`，继续处理</span></span><br /><span class="line"><span class="number">22</span>:         handler.caught(exchangeChannel, exception);</span><br /><span class="line"><span class="number">23</span>:     } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">24</span>:         <span class="comment">// 移除 ExchangeChannel 对象，若已断开</span></span><br /><span class="line"><span class="number">25</span>:         HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br /><span class="line"><span class="number">26</span>:     }</span><br /><span class="line"><span class="number">27</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>第 3 至 17 行：当发生 ExecutionException 异常，返回异常响应( Response )。目前会发生 ExecutionException 的情况，并且符合提交，如下图所示：<img src="http://static2.iocoder.cn/images/Dubbo/2018_12_10/06.png" alt="ExecutionException" /></p>
</li>
<li>
<p>第 18 至 26 行：见注释。</p>
</li>
</ul>
<h2 id="6-3-ExchangeHandler">6.3 ExchangeHandler</h2>
<p><code>com.alibaba.dubbo.remoting.exchange.ExchangeHandler</code>&nbsp;，继承 ChannelHandler 和 TelnetHandler 接口，信息交换处理器<strong>接口</strong>。方法如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// 回复请求结果</span></span><br /><span class="line"><span class="function">Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object request)</span> <span class="keyword">throws</span> RemotingException</span>;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><strong>注意</strong>，返回的是<strong>请求结果</strong>。正如我们在上文看到的，将请求结果，设置到&nbsp;<code>Response.mResult</code>&nbsp;属性中。</li>
</ul>
<p>ExchangeHandler 是一个非常关键的接口。为什么这么说呢，点击&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/619cbe46350c8d0b97b84631c6518e4603a89aee/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboProtocol.java#L82-L112" target="_blank" rel="external nofollow noopener noreferrer"><code>DubboProtocol. requestHandler</code></a>&nbsp;！胖友，领悟到了么？如果没有，淡定，后面我们会有文章分享。</p>
<h3 id="6-3-1-ExchangeHandlerAdapter">6.3.1 ExchangeHandlerAdapter</h3>
<p><code>com.alibaba.dubbo.remoting.exchange.support.ExchangeHandlerAdapter</code>&nbsp;，实现 ExchangeHandler 接口，继承 TelnetHandlerAdapter 抽象类，信息交换处理器适配器<strong>抽象类</strong>。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object msg)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p>在 DubboProtocol 、ThirftProtocol 中，都会基于 ExchangeHandlerAdapter&nbsp;<strong>实现自己的处理器</strong>，处理请求，返回结果。</p>
<h2 id="6-4-Replier">6.4 Replier</h2>
<blockquote>
<p>友情提示：这个小节，胖友可以选择性来看，目前仅用于&nbsp;<code>dubbo-remoting-p2p</code>&nbsp;模块中。</p>
</blockquote>
<p>在 ExchangeHandler 中，我们看到的是，Request 对应统一的 ExchangeHandler 实现的对象。但是在一些场景下，我们希望实现，不同的数据类型，对应不同的处理器。Replier 就是来处理这种情况的。一个数据类型，对应一个 Replier 对象。</p>
<p><code>com.alibaba.dubbo.remoting.exchange.support.Replier</code>&nbsp;，回复者接口。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Replier</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="comment">// 回复请求结果</span></span><br /><span class="line">    <span class="function">Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, T request)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>和 ExchangeHandler 最大的不同是，使用的是<strong>泛型 T</strong>，而不是固定的 Request 。</li>
</ul>
<h3 id="6-4-1-ReplierDispatcher">6.4.1 ReplierDispatcher</h3>
<p><code>com.alibaba.dubbo.remoting.exchange.support.ReplierDispatcher</code>&nbsp;，实现 Replier 接口，回复者<strong>调度器</strong>实现类。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 默认回复者</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Replier&lt;?&gt; defaultReplier;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 回复者集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key：类</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Replier&lt;?&gt;&gt; repliers = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Replier&lt;?&gt;&gt;();</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReplierDispatcher</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReplierDispatcher</span><span class="params">(Replier&lt;?&gt; defaultReplier)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>(defaultReplier, <span class="keyword">null</span>);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReplierDispatcher</span><span class="params">(Replier&lt;?&gt; defaultReplier, Map&lt;Class&lt;?&gt;, Replier&lt;?&gt;&gt; repliers)</span> </span>{</span><br /><span class="line">    <span class="comment">// ... 省略</span></span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>repliers</code>&nbsp;属性，回复者集合。可通过&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/c63ec335b776a386a215fa3662b575ece7d32c5e/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/ReplierDispatcher.java#L49-L52" target="_blank" rel="external nofollow noopener noreferrer"><code>#addReplier(Class&lt;T&gt; type, Replier&lt;T&gt; replier)</code></a>&nbsp;或&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/c63ec335b776a386a215fa3662b575ece7d32c5e/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/ReplierDispatcher.java#L54-L57" target="_blank" rel="external nofollow noopener noreferrer"><code>#removeReplier(Class&lt;T&gt; type)</code></a>&nbsp;方法，添加或移除回复者。</li>
</ul>
<p><strong>回复请求结果</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="meta">@SuppressWarnings</span>({<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>})</span><br /><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object request)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">    <span class="keyword">return</span> ((Replier) getReplier(request.getClass())).reply(channel, request);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>调用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/c63ec335b776a386a215fa3662b575ece7d32c5e/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/support/ReplierDispatcher.java#L59-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>#getReplier(Class&lt;?&gt; type)</code></a>&nbsp;方法，获得回复者对象。</li>
<li>调用&nbsp;<code>Repiler#reply(channel, request)</code>&nbsp;方法，回复请求结果。</li>
</ul>
<h3 id="6-4-2-ExchangeHandlerDispatcher">6.4.2 ExchangeHandlerDispatcher</h3>
<p><code>com.alibaba.dubbo.remoting.exchange.support.ExchangeHandlerDispatcher</code>&nbsp;，实现 ExchangeHandler 接口，信息交换处理器<strong>调度器</strong>实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 回复者调度器</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReplierDispatcher replierDispatcher;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 通道处理器集合</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelHandlerDispatcher handlerDispatcher;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Telnet 命令处理器</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TelnetHandler telnetHandler;</span><br /><br /><span class="line"><span class="comment">// ... 省略方法</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>通过 ExchangeHandlerDispatcher ，将 ReplierDispatcher + ChannelHandlerDispatcher + TelnetHandler 三者结合在一起，将对应的事件，调度到<strong>合适的</strong>处理器。以&nbsp;<code>#reply(...)</code>&nbsp;<code>#received(...)</code>&nbsp;<code>#telnet(...)</code>&nbsp;方法，举例子，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="meta">@SuppressWarnings</span>({<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>})</span><br /><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object request)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">    <span class="keyword">return</span> replierDispatcher.reply(channel, request);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> </span>{</span><br /><span class="line">    handlerDispatcher.received(channel, message);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">telnet</span><span class="params">(Channel channel, String message)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">    <span class="keyword">return</span> telnetHandler.telnet(channel, message);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<h1 id="7-Exchanger">7. Exchanger</h1>
<p><code>com.alibaba.dubbo.remoting.exchange.Exchanger</code>&nbsp;，<strong>数据交换者</strong>接口。方法如下：</p>
<blockquote>
<p>Exchanger 和 Transporter 类似。</p>
</blockquote>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@SPI</span>(HeaderExchanger.NAME)</span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Exchanger</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * bind.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 绑定一个服务器</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> url server url</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> message server 服务器</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="meta">@Adaptive</span>({Constants.EXCHANGER_KEY})</span><br /><span class="line">    <span class="function">ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * connect.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 连接一个服务器，即创建一个客户端</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> url server url 服务器地址</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> message channel 客户端</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="meta">@Adaptive</span>({Constants.EXCHANGER_KEY})</span><br /><span class="line">    <span class="function">ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>@SPI(HeaderExchanger.NAME)</code>&nbsp;注解，Dubbo SPI&nbsp;<strong>拓展点</strong>，默认为&nbsp;<code>"header"</code>，即 HeaderExchanger 。</li>
<li><code>@Adaptive({Constants.EXCHANGER_KEY})</code>&nbsp;注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Server 实现，使用&nbsp;<code>URL.exchanger</code>&nbsp;属性。</li>
<li><code>@Adaptive({Constants.EXCHANGER_KEY})</code>&nbsp;注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Client 实现，使用&nbsp;<code>URL.exchanger</code>&nbsp;属性。</li>
</ul>
<h2 id="7-1-HeaderExchanger">7.1 HeaderExchanger</h2>
<p><code>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchanger</code>&nbsp;，实现 Exchanger 接口，基于消息头部( Header )的<strong>信息交换者</strong>实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchanger</span> <span class="keyword">implements</span> <span class="title">Exchanger</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"header"</span>;</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>以&nbsp;<code>#connect(...)</code>&nbsp;方法举例子。
<ul>
<li>通过&nbsp;<code>Transporters#connect(url, handler)</code>&nbsp;方法，创建通信 Client ，内嵌到 HeaderExchangeClient 中。</li>
<li>传入的&nbsp;<code>handler</code>&nbsp;处理器，内嵌到 HeaderExchangeHandler ，再进一步内嵌到 DecodeHandler 中。所以，处理器的顺序是：DecodeHandler =&gt; HeaderExchangeHandler =&gt; ExchangeHandler(&nbsp;<code>handler</code>&nbsp;) 。</li>
</ul>
</li>
</ul>
<h2 id="7-2-Exchangers">7.2 Exchangers</h2>
<blockquote>
<p>Exchangers 和 Transporters 类似。</p>
</blockquote>
<p><a href="https://github.com/YunaiV/dubbo/blob/e24730a1dcfe8d5f1329377e80b1577724a85aac/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/Exchangers.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.Transporters</code></a>&nbsp;，数据交换者门面类，参见 Facade 设计模式。</p>
<p>代码比较简单，胖友自己查看列。</p>
<h1 id="8-ExchangeCodec">8. ExchangeCodec</h1>
<p>胖友，打起精神，ExchangeCodec 非常重要。</p>
<p><code>com.alibaba.dubbo.remoting.exchange.codec.ExchangeCodec</code>&nbsp;，继承 TelnetCodec 类，信息交换编解码器。</p>
<p>在看具体的编解码方法的代码时，我们来先看一幅图：<img src="http://static2.iocoder.cn/images/Dubbo/2018_12_10/07.png" alt="协议" /></p>
<ul>
<li>基于<strong>消息长度</strong>的方式，做每条消息的<strong>粘包拆包</strong>处理。和我们在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-api-transport/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（二）之 Transport 层》</a>&nbsp;中，看到 Telnet 协议，基于<strong>特定字符</strong>的方式，做每条命令的<strong>粘包拆包</strong>处理<strong>不同</strong>。</li>
<li>Header 部分，协议头，通过 Codec 编解码。Bits 位如下：
<ul>
<li><code>[0, 15]</code>：Magic Number</li>
<li><code>[16, 20]</code>：Serialization 编号。</li>
<li><code>[21]</code>：<code>event</code>&nbsp;是否为事件。</li>
<li><code>[22]</code>：<code>twoWay</code>&nbsp;是否需要响应。</li>
<li><code>[23]</code>：是请求还是响应。</li>
<li><code>[24 - 31]</code>：<code>status</code>&nbsp;状态。</li>
<li><code>[32 - 95]</code>：<code>id</code>&nbsp;编号，Long 型。</li>
<li><code>[96 - 127]</code>：Body 的<strong>长度</strong>。通过该长度，读取 Body 。</li>
</ul>
</li>
<li>Body 部分，协议体，通过 Serialization 序列化/反序列化。</li>
</ul>
<p><strong>属性</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// header length.</span></span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEADER_LENGTH = <span class="number">16</span>;</span><br /><span class="line"><span class="comment">// magic header.</span></span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> MAGIC = (<span class="keyword">short</span>) <span class="number">0xdabb</span>;</span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> MAGIC_HIGH = Bytes.short2bytes(MAGIC)[<span class="number">0</span>];</span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> MAGIC_LOW = Bytes.short2bytes(MAGIC)[<span class="number">1</span>];</span><br /><span class="line"><span class="comment">// message flag.</span></span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> FLAG_REQUEST = (<span class="keyword">byte</span>) <span class="number">0x80</span>; <span class="comment">// 128</span></span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> FLAG_TWOWAY = (<span class="keyword">byte</span>) <span class="number">0x40</span>; <span class="comment">// 64</span></span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> FLAG_EVENT = (<span class="keyword">byte</span>) <span class="number">0x20</span>; <span class="comment">// 32</span></span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERIALIZATION_MASK = <span class="number">0x1f</span>; <span class="comment">// 31</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>HEADER_LENGTH</code>&nbsp;<strong>静态</strong>属性，Header 总长度，16 Bytes = 128 Bits 。</li>
<li>其它<strong>静态</strong>属性，胖友对照上面的 Bits 位。</li>
</ul>
<p><strong>编码</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Request) { <span class="comment">// 请求</span></span><br /><span class="line"> <span class="number">4</span>:         encodeRequest(channel, buffer, (Request) msg);</span><br /><span class="line"> <span class="number">5</span>:     } <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Response) { <span class="comment">// 响应</span></span><br /><span class="line"> <span class="number">6</span>:         encodeResponse(channel, buffer, (Response) msg);</span><br /><span class="line"> <span class="number">7</span>:     } <span class="keyword">else</span> { <span class="comment">// 提交给父类( Telnet ) 处理，目前是 Telnet 命令的结果。</span></span><br /><span class="line"> <span class="number">8</span>:         <span class="keyword">super</span>.encode(channel, buffer, msg);</span><br /><span class="line"> <span class="number">9</span>:     }</span><br /><span class="line"><span class="number">10</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 至 4 行：调用&nbsp;<code>#encodeRequest(channel, buffer, request)</code>&nbsp;方法，编码请求。</li>
<li>第 5 至 6 行：调用&nbsp;<code>#encodeResponse(channel, buffer, response)</code>&nbsp;方法，编码响应。</li>
<li>第 7 至 9 行：调用&nbsp;<code>TelnetCodec#encode(channel, buffer, msg)</code>&nbsp;方法，编码 Telnet 命令的结果。</li>
<li>
<p><code>#encodeRequest(channel, buffer, request)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequest</span><span class="params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line"> <span class="number">2</span>:     Serialization serialization = getSerialization(channel);</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// `[0, 15]`：Magic Number</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">// header.</span></span><br /><span class="line"> <span class="number">5</span>:     <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[HEADER_LENGTH];</span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// set magic number.</span></span><br /><span class="line"> <span class="number">7</span>:     Bytes.short2bytes(MAGIC, header);</span><br /><span class="line"> <span class="number">8</span>: </span><br /><span class="line"> <span class="number">9</span>:     <span class="comment">// `[16, 20]`：Serialization 编号 &amp;&amp; `[23]`：请求。</span></span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// set request and serialization flag.</span></span><br /><span class="line"><span class="number">11</span>:     header[<span class="number">2</span>] = (<span class="keyword">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());</span><br /><span class="line"><span class="number">12</span>: </span><br /><span class="line"><span class="number">13</span>:     <span class="comment">// `[21]`：`event` 是否为事件。</span></span><br /><span class="line"><span class="number">14</span>:     <span class="keyword">if</span> (req.isTwoWay()) header[<span class="number">2</span>] |= FLAG_TWOWAY;</span><br /><span class="line"><span class="number">15</span>:     <span class="comment">// `[22]`：`twoWay` 是否需要响应。</span></span><br /><span class="line"><span class="number">16</span>:     <span class="keyword">if</span> (req.isEvent()) header[<span class="number">2</span>] |= FLAG_EVENT;</span><br /><span class="line"><span class="number">17</span>: </span><br /><span class="line"><span class="number">18</span>:     <span class="comment">// `[32 - 95]`：`id` 编号，Long 型。</span></span><br /><span class="line"><span class="number">19</span>:     <span class="comment">// set request id.</span></span><br /><span class="line"><span class="number">20</span>:     Bytes.long2bytes(req.getId(), header, <span class="number">4</span>);</span><br /><span class="line"><span class="number">21</span>: </span><br /><span class="line"><span class="number">22</span>:     <span class="comment">// 编码 `Request.data` 到 Body ，并写入到 Buffer</span></span><br /><span class="line"><span class="number">23</span>:     <span class="comment">// encode request data.</span></span><br /><span class="line"><span class="number">24</span>:     <span class="keyword">int</span> savedWriteIndex = buffer.writerIndex();</span><br /><span class="line"><span class="number">25</span>:     buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);</span><br /><span class="line"><span class="number">26</span>:     ChannelBufferOutputStream bos = <span class="keyword">new</span> ChannelBufferOutputStream(buffer);</span><br /><span class="line"><span class="number">27</span>:     ObjectOutput out = serialization.serialize(channel.getUrl(), bos); <span class="comment">// 序列化 Output</span></span><br /><span class="line"><span class="number">28</span>:     <span class="keyword">if</span> (req.isEvent()) {</span><br /><span class="line"><span class="number">29</span>:         encodeEventData(channel, out, req.getData());</span><br /><span class="line"><span class="number">30</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">31</span>:         encodeRequestData(channel, out, req.getData());</span><br /><span class="line"><span class="number">32</span>:     }</span><br /><span class="line"><span class="number">33</span>:     <span class="comment">// 释放资源</span></span><br /><span class="line"><span class="number">34</span>:     out.flushBuffer();</span><br /><span class="line"><span class="number">35</span>:     <span class="keyword">if</span> (out <span class="keyword">instanceof</span> Cleanable) {</span><br /><span class="line"><span class="number">36</span>:         ((Cleanable) out).cleanup();</span><br /><span class="line"><span class="number">37</span>:     }</span><br /><span class="line"><span class="number">38</span>:     bos.flush();</span><br /><span class="line"><span class="number">39</span>:     bos.close();</span><br /><span class="line"><span class="number">40</span>:     <span class="comment">// 检查 Body 长度，是否超过消息上限。</span></span><br /><span class="line"><span class="number">41</span>:     <span class="keyword">int</span> len = bos.writtenBytes();</span><br /><span class="line"><span class="number">42</span>:     checkPayload(channel, len);</span><br /><span class="line"><span class="number">43</span>:     <span class="comment">// `[96 - 127]`：Body 的**长度**。</span></span><br /><span class="line"><span class="number">44</span>:     Bytes.int2bytes(len, header, <span class="number">12</span>);</span><br /><span class="line"><span class="number">45</span>: </span><br /><span class="line"><span class="number">46</span>:     <span class="comment">// 写入 Header 到 Buffer</span></span><br /><span class="line"><span class="number">47</span>:     <span class="comment">// write</span></span><br /><span class="line"><span class="number">48</span>:     buffer.writerIndex(savedWriteIndex);</span><br /><span class="line"><span class="number">49</span>:     buffer.writeBytes(header); <span class="comment">// write header.</span></span><br /><span class="line"><span class="number">50</span>:     buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);</span><br /><span class="line"><span class="number">51</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>Header 部分，先写入&nbsp;<code>header</code>&nbsp;数组，再写入 Buffer 中。</li>
<li>
<p>Body 部分，使用 Serialization 序列化&nbsp;<code>Request.data</code>&nbsp;，写入到 Buffer 中。</p>
<ul>
<li>
<p><code>#encodeEventData(Channel channel, ObjectOutput out, Object data)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">encodeEventData</span><span class="params">(Channel channel, ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line">    encodeEventData(out, data);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">encodeEventData</span><span class="params">(ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line">    out.writeObject(data);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>x</li>
</ul>
</li>
<li>
<p><code>#encodeRequestData(Channel channel, ObjectOutput out, Object data)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequestData</span><span class="params">(Channel channel, ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line">    encodeRequestData(out, data);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequestData</span><span class="params">(ObjectOutput out, Object data)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line">    out.writeObject(data);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>#encodeEventData(...)</code>&nbsp;和&nbsp;<code>#encodeRequestData(...)</code>&nbsp;两个方法是一致的。</li>
</ul>
</li>
</ul>
</li>
<li>第 42 行：会调用&nbsp;<code>#checkPayload(channel, len)</code>&nbsp;方法，校验 Body 内容的长度。笔者在这块纠结了很久，如果过长而抛出 ExceedPayloadLimitException 异常，那么 ChannelBuffer 是否重置下写入位置。后来发现自己煞笔了，每次 ChannelBuffer 都是新创建的，所以无需重置。</li>
<li>为什么 Buffer 先写入了 Body ，再写入 Header 呢？因为 Header 中，里面&nbsp;<code>[96 - 127]</code>&nbsp;的 Body 长度，需要序列化后才得到。</li>
</ul>
</li>
<li><a href="https://github.com/YunaiV/dubbo/blob/a89a569e608ee1282d1bce3fc2540860873629db/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/codec/ExchangeCodec.java#L292-L404" target="_blank" rel="external nofollow noopener noreferrer"><code>#encodeResponse(channel, buffer, response)</code></a>&nbsp;方法，和&nbsp;<code>#encodeRequest(chanel, buffer, request)</code>&nbsp;方法，基本一致，胖友自己瞅瞅列。主要差异点如下：
<ul>
<li><code>[24 - 31]</code>：<code>status</code>&nbsp;状态。这是 Request 没有，而 Response 有的部分。</li>
<li>当响应的内容过长而抛出 ExceedPayloadLimitException 异常，根据条件，发送一条 Response (&nbsp;<code>status = BAD_RESPONSE</code>&nbsp;) 给请求方。</li>
</ul>
</li>
</ul>
<p><strong>解码</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 读取 Header 数组</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">int</span> readable = buffer.readableBytes();</span><br /><span class="line"> <span class="number">5</span>:     <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];</span><br /><span class="line"> <span class="number">6</span>:     buffer.readBytes(header);</span><br /><span class="line"> <span class="number">7</span>:     <span class="comment">// 解码</span></span><br /><span class="line"> <span class="number">8</span>:     <span class="keyword">return</span> decode(channel, buffer, readable, header);</span><br /><span class="line"> <span class="number">9</span>: }</span><br /><span class="line"><span class="number">10</span>: </span><br /><span class="line"><span class="number">11</span>: <span class="meta">@Override</span></span><br /><span class="line"><span class="number">12</span>: <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer, <span class="keyword">int</span> readable, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>{</span><br /><span class="line"><span class="number">13</span>:     <span class="comment">// 非 Dubbo 协议，目前是 Telnet 命令。</span></span><br /><span class="line"><span class="number">14</span>:     <span class="comment">// check magic number.</span></span><br /><span class="line"><span class="number">15</span>:     <span class="keyword">if</span> (readable &gt; <span class="number">0</span> &amp;&amp; header[<span class="number">0</span>] != MAGIC_HIGH || readable &gt; <span class="number">1</span> &amp;&amp; header[<span class="number">1</span>] != MAGIC_LOW) {</span><br /><span class="line"><span class="number">16</span>:         <span class="comment">// 将 buffer 完全复制到 `header` 数组中。因为，上面的 `#decode(channel, buffer)` 方法，可能未读全</span></span><br /><span class="line"><span class="number">17</span>:         <span class="keyword">int</span> length = header.length;</span><br /><span class="line"><span class="number">18</span>:         <span class="keyword">if</span> (header.length &lt; readable) {</span><br /><span class="line"><span class="number">19</span>:             header = Bytes.copyOf(header, readable);</span><br /><span class="line"><span class="number">20</span>:             buffer.readBytes(header, length, readable - length);</span><br /><span class="line"><span class="number">21</span>:         }</span><br /><span class="line"><span class="number">22</span>:         <span class="comment">// 【TODO 8026 】header[i] == MAGIC_HIGH &amp;&amp; header[i + 1] == MAGIC_LOW ？</span></span><br /><span class="line"><span class="number">23</span>:         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; header.length - <span class="number">1</span>; i++) {</span><br /><span class="line"><span class="number">24</span>:             <span class="keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="number">1</span>] == MAGIC_LOW) {</span><br /><span class="line"><span class="number">25</span>:                 buffer.readerIndex(buffer.readerIndex() - header.length + i);</span><br /><span class="line"><span class="number">26</span>:                 header = Bytes.copyOf(header, i);</span><br /><span class="line"><span class="number">27</span>:                 <span class="keyword">break</span>;</span><br /><span class="line"><span class="number">28</span>:             }</span><br /><span class="line"><span class="number">29</span>:         }</span><br /><span class="line"><span class="number">30</span>:         <span class="comment">// 提交给父类( Telnet ) 处理，目前是 Telnet 命令。</span></span><br /><span class="line"><span class="number">31</span>:         <span class="keyword">return</span> <span class="keyword">super</span>.decode(channel, buffer, readable, header);</span><br /><span class="line"><span class="number">32</span>:     }</span><br /><span class="line"><span class="number">33</span>:     <span class="comment">// Header 长度不够，返回需要更多的输入</span></span><br /><span class="line"><span class="number">34</span>:     <span class="comment">// check length.</span></span><br /><span class="line"><span class="number">35</span>:     <span class="keyword">if</span> (readable &lt; HEADER_LENGTH) {</span><br /><span class="line"><span class="number">36</span>:         <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br /><span class="line"><span class="number">37</span>:     }</span><br /><span class="line"><span class="number">38</span>: </span><br /><span class="line"><span class="number">39</span>:     <span class="comment">// `[96 - 127]`：Body 的**长度**。通过该长度，读取 Body 。</span></span><br /><span class="line"><span class="number">40</span>:     <span class="comment">// get data length.</span></span><br /><span class="line"><span class="number">41</span>:     <span class="keyword">int</span> len = Bytes.bytes2int(header, <span class="number">12</span>);</span><br /><span class="line"><span class="number">42</span>:     checkPayload(channel, len);</span><br /><span class="line"><span class="number">43</span>: </span><br /><span class="line"><span class="number">44</span>:     <span class="comment">// 总长度不够，返回需要更多的输入</span></span><br /><span class="line"><span class="number">45</span>:     <span class="keyword">int</span> tt = len + HEADER_LENGTH;</span><br /><span class="line"><span class="number">46</span>:     <span class="keyword">if</span> (readable &lt; tt) {</span><br /><span class="line"><span class="number">47</span>:         <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br /><span class="line"><span class="number">48</span>:     }</span><br /><span class="line"><span class="number">49</span>: </span><br /><span class="line"><span class="number">50</span>:     <span class="comment">// 解析 Header + Body</span></span><br /><span class="line"><span class="number">51</span>:     <span class="comment">// limit input stream.</span></span><br /><span class="line"><span class="number">52</span>:     ChannelBufferInputStream is = <span class="keyword">new</span> ChannelBufferInputStream(buffer, len);</span><br /><span class="line"><span class="number">53</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">54</span>:         <span class="keyword">return</span> decodeBody(channel, is, header);</span><br /><span class="line"><span class="number">55</span>:     } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">56</span>:         <span class="comment">// skip 未读完的流，并打印错误日志</span></span><br /><span class="line"><span class="number">57</span>:         <span class="keyword">if</span> (is.available() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">58</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">59</span>:                 <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br /><span class="line"><span class="number">60</span>:                     logger.warn(<span class="string">"Skip input stream "</span> + is.available());</span><br /><span class="line"><span class="number">61</span>:                 }</span><br /><span class="line"><span class="number">62</span>:                 StreamUtils.skipUnusedStream(is);</span><br /><span class="line"><span class="number">63</span>:             } <span class="keyword">catch</span> (IOException e) {</span><br /><span class="line"><span class="number">64</span>:                 logger.warn(e.getMessage(), e);</span><br /><span class="line"><span class="number">65</span>:             }</span><br /><span class="line"><span class="number">66</span>:         }</span><br /><span class="line"><span class="number">67</span>:     }</span><br /><span class="line"><span class="number">68</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 至 6 行：读取&nbsp;<code>header</code>&nbsp;数组。<strong>注意</strong>，这里的&nbsp;<code>Math.min(readable, HEADER_LENGTH)</code>&nbsp;，优先考虑解析 Dubbo 协议。</li>
<li>第 8 行：调用&nbsp;<code>#decode(channel, buffer, readable, header)</code>&nbsp;方法，解码。</li>
<li>========== 分隔线 ==========</li>
<li>第 13 至 32 行：非 Dubbo 协议，目前是 Telnet 协议。
<ul>
<li>第 17 至 21 行：将 Buffer 完全复制到&nbsp;<code>header</code>&nbsp;数组中。因为，上面的&nbsp;<code>#decode(channel, buffer)</code>&nbsp;方法，可能未读全。因为，【第 3 至 6 行】，是以&nbsp;<strong>Dubbo 协议</strong>&nbsp;为优先考虑解码的。</li>
<li>第 22 至 29 行：【TODO 8026 】header[i] == MAGIC_HIGH &amp;&amp; header[i + 1] == MAGIC_LOW ？搞不懂？</li>
<li>第 31 行：调用&nbsp;<code>Telnet#decode(channel, buffer, readable, header)</code>&nbsp;方法，解码 Telnet 。在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-api-telnet/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（三）之 Telnet 层》</a>&nbsp;有详细解析。</li>
</ul>
</li>
<li>第 33 至 48 行：基于<strong>消息长度</strong>的方式，拆包。</li>
<li>第 50 至 54 行：调用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/a89a569e608ee1282d1bce3fc2540860873629db/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/codec/ExchangeCodec.java#L148-L218" target="_blank" rel="external nofollow noopener noreferrer"><code>#decodeBody(channel, is, header)</code></a>&nbsp;方法，解析 Header + Body ，根据情况，返回 Request 或 Reponse 。🙂 逻辑上，是&nbsp;<code>#encodeRequest(...)</code>&nbsp;和&nbsp;<code>#encodeResponse(...)</code>&nbsp;方法的反向，所以，胖友就自己看啦。</li>
<li>第 55 至 67 行：skip&nbsp;<strong>未读完的流</strong>，并打印告警日志。</li>
</ul>
</div>
</header>
<div class="article-entry">&nbsp;</div>