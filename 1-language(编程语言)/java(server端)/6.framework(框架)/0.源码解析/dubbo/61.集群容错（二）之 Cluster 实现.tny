<header class="article-header">
<h1 class="article-title">集群容错（二）之 Cluster 实现</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>本文接&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-1-api-interface//?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（一）之抽象 API》</a>&nbsp;一文，分享&nbsp;<code>dubbo-cluster</code>&nbsp;模块，&nbsp;<code>support</code>&nbsp;包，<strong>各种 Cluster 实现类</strong>。</p>
<p>Cluster 子类如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_04_01/01.png" alt="Cluster 子类" /></p>
<p>我们可以看到，每个 Cluster 实现类，对应一个<strong>专属</strong>于其的 Invoker 实现类。下面，我们一个一个子类往下看。</p>
<blockquote>
<p>老艿艿：本文对应&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 集群容错》</a>&nbsp;文档。</p>
</blockquote>
<h1 id="2-AvailableCluster">2. AvailableCluster</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.support.AvailableCluster</code>&nbsp;，实现 Cluster 接口，调用<strong>首个可用</strong>服务器，目前用于<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/multi-registry.html#%E5%A4%9A%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%B3%A8%E5%86%8C" target="_blank" rel="external nofollow noopener noreferrer">多注册中心引用</a>。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"available"</span>;</span><br /><br /><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AvailableClusterInvoker&lt;T&gt;(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>对应 Invoker 实现类为 AvailableClusterInvoker 。</li>
</ul>
<h2 id="2-1-AvailableClusterInvoker">2.1 AvailableClusterInvoker</h2>
<p><code>com.alibaba.dubbo.rpc.cluster.support.AvailableClusterInvoker</code>&nbsp;，实现 AbstractClusterInvoker 抽象类，AvailableCluster Invoker 实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AvailableClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>{</span><br /><span class="line">        <span class="keyword">super</span>(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="comment">// 循环候选的 Invoker 集合，调用首个可用的 Invoker 对象。</span></span><br /><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) {</span><br /><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) { <span class="comment">// 可用</span></span><br /><span class="line">                <span class="comment">// 发起 RPC 调用</span></span><br /><span class="line">                <span class="keyword">return</span> invoker.invoke(invocation);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"No provider available in "</span> + invokers);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="3-BroadcastCluster">3. BroadcastCluster</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.support.BroadcastCluster</code>&nbsp;，实现 Cluster 接口，广播调用<strong>所有</strong>提供者，逐个调用，<strong>任意</strong>一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>{</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BroadcastClusterInvoker&lt;T&gt;(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>对应 Invoker 实现类为 BroadcastClusterInvoker 。</li>
</ul>
<h2 id="3-1-BroadcastClusterInvoker">3.1 BroadcastClusterInvoker</h2>
<p><code>com.alibaba.dubbo.rpc.cluster.support.BroadcastClusterInvoker</code>&nbsp;，实现 AbstractClusterInvoker 抽象类，BroadcastCluster Invoker 实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(BroadcastClusterInvoker.class);</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BroadcastClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>{</span><br /><span class="line">        <span class="keyword">super</span>(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="meta">@SuppressWarnings</span>({<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>})</span><br /><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="comment">// 检查 invokers 即可用Invoker集合是否为空，如果为空，那么抛出异常</span></span><br /><span class="line">        checkInvokers(invokers, invocation);</span><br /><span class="line">        <span class="comment">// 设置已经调用的 Invoker 集合，到 Context 中</span></span><br /><span class="line">        RpcContext.getContext().setInvokers((List) invokers);</span><br /><span class="line">        <span class="comment">// 保存最后一次调用的异常</span></span><br /><span class="line">        RpcException exception = <span class="keyword">null</span>;</span><br /><span class="line">        <span class="comment">// 保存最后一次调用的结果</span></span><br /><span class="line">        Result result = <span class="keyword">null</span>;</span><br /><span class="line">        <span class="comment">// 循环候选的 Invoker 集合，调用所有 Invoker 对象。</span></span><br /><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) {</span><br /><span class="line">            <span class="keyword">try</span> {</span><br /><span class="line">                <span class="comment">// 发起 RPC 调用</span></span><br /><span class="line">                result = invoker.invoke(invocation);</span><br /><span class="line">            } <span class="keyword">catch</span> (RpcException e) {</span><br /><span class="line">                exception = e;</span><br /><span class="line">                logger.warn(e.getMessage(), e);</span><br /><span class="line">            } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">                exception = <span class="keyword">new</span> RpcException(e.getMessage(), e); <span class="comment">// 封装成 RpcException 异常</span></span><br /><span class="line">                logger.warn(e.getMessage(), e);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 若存在一个异常，抛出该异常</span></span><br /><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) {</span><br /><span class="line">            <span class="keyword">throw</span> exception;</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">return</span> result;</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="4-FailbackCluster">4. FailbackCluster</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.support.FailbackCluster</code>&nbsp;，实现 Cluster 接口，失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failback"</span>;</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailbackClusterInvoker&lt;T&gt;(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>对应 Invoker 实现类为 FailbackClusterInvoker 。</li>
</ul>
<h2 id="4-1-FailbackClusterInvoker">4.1 FailbackClusterInvoker</h2>
<p><code>com.alibaba.dubbo.rpc.cluster.support.FailbackClusterInvoker</code>&nbsp;，实现 AbstractClusterInvoker 抽象类，FailbackCluster Invoker 实现类。</p>
<h3 id="4-1-1-构造方法">4.1.1 构造方法</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 重试频率</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RETRY_FAILED_PERIOD = <span class="number">5</span> * <span class="number">1000</span>;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * ScheduledExecutorService 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">2</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"failback-cluster-timer"</span>, <span class="keyword">true</span>));</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 失败任务集合</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Invocation, AbstractClusterInvoker&lt;?&gt;&gt; failed = <span class="keyword">new</span> ConcurrentHashMap&lt;Invocation, AbstractClusterInvoker&lt;?&gt;&gt;();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 重试任务 Future</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ScheduledFuture&lt;?&gt; retryFuture;</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FailbackClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>{</span><br /><span class="line">    <span class="keyword">super</span>(directory);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>所有字段，都是和重试相关，胖友看下注释。</li>
</ul>
<h3 id="4-1-2-doInvoke">4.1.2 doInvoke</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        <span class="comment">// 检查 invokers 即可用Invoker集合是否为空，如果为空，那么抛出异常</span></span><br /><span class="line">        checkInvokers(invokers, invocation);</span><br /><span class="line">        <span class="comment">// 根据负载均衡机制从 invokers 中选择一个Invoker</span></span><br /><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br /><span class="line">        <span class="comment">// RPC 调用得到 Result</span></span><br /><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br /><span class="line">    } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">        logger.error(<span class="string">"Failback to invoke method "</span> + invocation.getMethodName() + <span class="string">", wait for retry in background. Ignored exception: "</span> + e.getMessage() + <span class="string">", "</span>, e);</span><br /><span class="line">        <span class="comment">// 添加到失败任务</span></span><br /><span class="line">        addFailed(invocation, <span class="keyword">this</span>);</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(); <span class="comment">// ignore</span></span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>若 RPC 调用失败，则调用&nbsp;<code>#addFailed(invocation, this)</code>&nbsp;方法，添加到&nbsp;<code>failed</code>&nbsp;中，后台定时重试。</li>
</ul>
<h3 id="4-1-3-addFailed">4.1.3 addFailed</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFailed</span><span class="params">(Invocation invocation, AbstractClusterInvoker&lt;?&gt; router)</span> </span>{</span><br /><span class="line">    <span class="comment">// 若定时任务未初始化，进行创建</span></span><br /><span class="line">    <span class="keyword">if</span> (retryFuture == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br /><span class="line">            <span class="keyword">if</span> (retryFuture == <span class="keyword">null</span>) {</span><br /><span class="line">                retryFuture = scheduledExecutorService.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() {</span><br /><br /><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br /><span class="line">                        <span class="comment">// collect retry statistics</span></span><br /><span class="line">                        <span class="keyword">try</span> {</span><br /><span class="line">                            retryFailed();</span><br /><span class="line">                        } <span class="keyword">catch</span> (Throwable t) { <span class="comment">// Defensive fault tolerance</span></span><br /><span class="line">                            logger.error(<span class="string">"Unexpected error occur at collect statistic"</span>, t);</span><br /><span class="line">                        }</span><br /><span class="line">                    }</span><br /><span class="line">                }, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.MILLISECONDS);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 添加到失败任务</span></span><br /><span class="line">    failed.put(invocation, router);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>创建的定时任务，会调用&nbsp;<code>#retryFailed()</code>&nbsp;方法，重试任务，发起 RCP 调用。</li>
</ul>
<h3 id="4-1-4-retryFailed">4.1.4 retryFailed</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retryFailed</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (failed.size() == <span class="number">0</span>) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 循环重试任务，逐个调用</span></span><br /><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Invocation, AbstractClusterInvoker&lt;?&gt;&gt; entry : <span class="keyword">new</span> HashMap&lt;Invocation, AbstractClusterInvoker&lt;?&gt;&gt;(failed).entrySet()) { <span class="comment">// 创建集合</span></span><br /><span class="line">        Invocation invocation = entry.getKey();</span><br /><span class="line">        Invoker&lt;?&gt; invoker = entry.getValue();</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="comment">// RPC 调用得到 Result</span></span><br /><span class="line">            invoker.invoke(invocation);</span><br /><span class="line">            <span class="comment">// 移除失败任务</span></span><br /><span class="line">            failed.remove(invocation);</span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">            logger.error(<span class="string">"Failed retry to invoke method "</span> + invocation.getMethodName() + <span class="string">", waiting again."</span>, e);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>循环重试任务，逐个发起 RPC 调用。若调用成功，移除该失败任务出&nbsp;<code>failed</code>&nbsp;集合。</li>
</ul>
<p>在极端情况下，存在一个 BUG ，复现步骤如下：</p>
<ol>
<li>假设目前有两个服务提供者 A、B 。</li>
<li>首先调用 A 服务，假设超时，添加到&nbsp;<code>failed</code>&nbsp;中。</li>
<li>重试调用 B 服务（A 服务亦可），假设再次超时，添加到&nbsp;<code>failed</code>&nbsp;中。</li>
<li>因为&nbsp;<code>#doInvoker(...)</code>&nbsp;方法，调用失败，不会抛出异常（当然也不能），导致&nbsp;<code>#retryFailed(...)</code>&nbsp;方法，<strong>误以为</strong>调用成功，错误的移除该失败任务出&nbsp;<code>failed</code>&nbsp;集合。</li>
</ol>
<p>那么能不能在&nbsp;<code>#retryFailed(...)</code>&nbsp;方法中，先移除该失败任务出&nbsp;<code>failed</code>&nbsp;集合呢，再发起 PRC 调用呢？答案是<strong>不可以</strong>，因为在调用&nbsp;<code>#doInvoke(...)</code>&nbsp;方法之前，可能发生异常，导致失败任务的丢失。</p>
<p>那么该怎么办？有两种方式：</p>
<ol>
<li>上述方案的基础上，在&nbsp;<code>#retryFailed(...)</code>&nbsp;方法的移除处理中，增加调用&nbsp;<code>#addFailed(...)</code>&nbsp;方法。</li>
<li>枚举一个&nbsp;<code>FAILED_RESULT</code>&nbsp;对象，让&nbsp;<code>#doInvoke(...)</code>&nbsp;方法发生异常时，返回该对象。这样&nbsp;<code>#retryFailed(...)</code>&nbsp;方法，在移除出&nbsp;<code>failed</code>&nbsp;集合时，增加下是否执行成功的判断。</li>
</ol>
<p>笔者倾向第二种，逻辑更加线性和易懂。</p>
<h1 id="5-FailfastCluster">5. FailfastCluster</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.support.FailfastCluster</code>&nbsp;，实现 Cluster 接口，快速失败，只发起一次调用，<strong>失败立即报错</strong>。通常用于<strong>非幂等性的写操作</strong>，比如新增记录。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailfastCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failfast"</span>;</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailfastClusterInvoker&lt;T&gt;(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>对应 Invoker 实现类为 FailfastClusterInvoker 。</li>
</ul>
<h2 id="5-1-FailfastInvoker">5.1 FailfastInvoker</h2>
<p><code>com.alibaba.dubbo.rpc.cluster.support.FailbackClusterInvoker</code>&nbsp;，实现 AbstractClusterInvoker 抽象类，Failfast Invoker 实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailfastClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailfastClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>{</span><br /><span class="line">        <span class="keyword">super</span>(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="comment">// 检查 invokers 即可用Invoker集合是否为空，如果为空，那么抛出异常</span></span><br /><span class="line">        checkInvokers(invokers, invocation);</span><br /><span class="line">        <span class="comment">// 根据负载均衡机制从 invokers 中选择一个Invoker</span></span><br /><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="comment">// RPC 调用得到 Result</span></span><br /><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">            <span class="comment">// 若是业务性质的异常，直接抛出</span></span><br /><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RpcException &amp;&amp; ((RpcException) e).isBiz()) { <span class="comment">// biz exception.</span></span><br /><span class="line">                <span class="keyword">throw</span> (RpcException) e;</span><br /><span class="line">            }</span><br /><span class="line">            <span class="comment">// 封装 RpcException 异常，并抛出</span></span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>,</span><br /><span class="line">                    <span class="string">"Failfast invoke providers "</span> + invoker.getUrl() + <span class="string">" "</span> + loadbalance.getClass().getSimpleName() + <span class="string">" select from all providers "</span> + invokers + <span class="string">" for service "</span> + getInterface().getName() + <span class="string">" method "</span> + invocation.getMethodName() + <span class="string">" on consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", but no luck to perform the invocation. Last error is: "</span> + e.getMessage(), e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>和 FailbackClusterInvoker 差异点，在于对异常的处理。</li>
</ul>
<h1 id="6-FailsafeCluster">6. FailsafeCluster</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.support.FailsafeCluster</code>&nbsp;，实现 Cluster 接口，失败安全，<strong>出现异常时，直接忽略</strong>。通常用于写入审计日志等操作。</p>
<p>代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailfastCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failfast"</span>;</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailfastClusterInvoker&lt;T&gt;(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>对应 Invoker 实现类为 FailsafeClusterInvoker 。</li>
</ul>
<h2 id="6-1-FailsafeClusterInvoker">6.1 FailsafeClusterInvoker</h2>
<p><code>com.alibaba.dubbo.rpc.cluster.support.FailsafeClusterInvoker</code>&nbsp;，实现 AbstractClusterInvoker 抽象类，Failsafe Invoker 实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailsafeClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FailsafeClusterInvoker.class);</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailsafeClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>{</span><br /><span class="line">        <span class="keyword">super</span>(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="comment">// 检查 invokers 即可用Invoker集合是否为空，如果为空，那么抛出异常</span></span><br /><span class="line">            checkInvokers(invokers, invocation);</span><br /><span class="line">            <span class="comment">// 根据负载均衡机制从 invokers 中选择一个Invoker</span></span><br /><span class="line">            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br /><span class="line">            <span class="comment">// RPC 调用得到 Result</span></span><br /><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">            <span class="comment">// 打印异常日志</span></span><br /><span class="line">            logger.error(<span class="string">"Failsafe ignore exception: "</span> + e.getMessage(), e);</span><br /><span class="line">            <span class="comment">// 忽略异常</span></span><br /><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(); <span class="comment">// ignore</span></span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>和 FailfastInvoker 差异点，在于对异常的处理。</li>
</ul>
<h1 id="7-ForkingCluster">7. ForkingCluster</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.support.ForkingCluster</code>&nbsp;，实现 Cluster 接口，并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过&nbsp;<code>forks="2"</code>&nbsp;来设置最大并行数。</p>
<p>代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkingCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"forking"</span>;</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkingClusterInvoker&lt;T&gt;(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="7-1-ForkingClusterInvoker">7.1 ForkingClusterInvoker</h2>
<blockquote>
<p>老艿艿：BlockQueue 的使用，非常精髓！</p>
</blockquote>
<p><code>com.alibaba.dubbo.rpc.cluster.support.ForkingClusterInvoker</code>&nbsp;，实现 AbstractClusterInvoker 抽象类，ForkingCluster Invoker 实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkingClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><span class="line"> <span class="number">2</span>: </span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 4:      * ExecutorService 对象，并且为 CachedThreadPool 。</span></span><br /><span class="line"><span class="comment"> 5:      */</span></span><br /><span class="line"> <span class="number">6</span>:     <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"forking-cluster-timer"</span>, <span class="keyword">true</span>));</span><br /><span class="line"> <span class="number">7</span>: </span><br /><span class="line"> <span class="number">8</span>:     <span class="function"><span class="keyword">public</span> <span class="title">ForkingClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>{</span><br /><span class="line"> <span class="number">9</span>:         <span class="keyword">super</span>(directory);</span><br /><span class="line"><span class="number">10</span>:     }</span><br /><span class="line"><span class="number">11</span>: </span><br /><span class="line"><span class="number">12</span>:     <span class="meta">@Override</span></span><br /><span class="line"><span class="number">13</span>:     <span class="meta">@SuppressWarnings</span>({<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>})</span><br /><span class="line"><span class="number">14</span>:     <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"><span class="number">15</span>:         <span class="comment">// 检查 invokers 即可用Invoker集合是否为空，如果为空，那么抛出异常</span></span><br /><span class="line"><span class="number">16</span>:         checkInvokers(invokers, invocation);</span><br /><span class="line"><span class="number">17</span>:         <span class="comment">// 保存选择的 Invoker 集合</span></span><br /><span class="line"><span class="number">18</span>:         <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; selected;</span><br /><span class="line"><span class="number">19</span>:         <span class="comment">// 得到最大并行数，默认为 Constants.DEFAULT_FORKS = 2</span></span><br /><span class="line"><span class="number">20</span>:         <span class="keyword">final</span> <span class="keyword">int</span> forks = getUrl().getParameter(Constants.FORKS_KEY, Constants.DEFAULT_FORKS);</span><br /><span class="line"><span class="number">21</span>:         <span class="comment">// 获得调用超时时间，默认为 DEFAULT_TIMEOUT = 1000 毫秒</span></span><br /><span class="line"><span class="number">22</span>:         <span class="keyword">final</span> <span class="keyword">int</span> timeout = getUrl().getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br /><span class="line"><span class="number">23</span>:         <span class="comment">// 若最大并行书小于等于 0，或者大于 invokers 的数量，直接使用 invokers</span></span><br /><span class="line"><span class="number">24</span>:         <span class="keyword">if</span> (forks &lt;= <span class="number">0</span> || forks &gt;= invokers.size()) {</span><br /><span class="line"><span class="number">25</span>:             selected = invokers;</span><br /><span class="line"><span class="number">26</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">27</span>:             <span class="comment">// 循环，根据负载均衡机制从 invokers，中选择一个个Invoker ，从而组成 Invoker 集合。</span></span><br /><span class="line"><span class="number">28</span>:             <span class="comment">// 注意，因为增加了排重逻辑，所以不能保证获得的 Invoker 集合的大小，小于最大并行数</span></span><br /><span class="line"><span class="number">29</span>:             selected = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br /><span class="line"><span class="number">30</span>:             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; forks; i++) {</span><br /><span class="line"><span class="number">31</span>:                 <span class="comment">// 在invoker列表(排除selected)后,如果没有选够,则存在重复循环问题.见select实现.</span></span><br /><span class="line"><span class="number">32</span>:                 Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, selected);</span><br /><span class="line"><span class="number">33</span>:                 <span class="keyword">if</span> (!selected.contains(invoker)) { <span class="comment">//Avoid add the same invoker several times. //防止重复添加invoker</span></span><br /><span class="line"><span class="number">34</span>:                     selected.add(invoker);</span><br /><span class="line"><span class="number">35</span>:                 }</span><br /><span class="line"><span class="number">36</span>:             }</span><br /><span class="line"><span class="number">37</span>:         }</span><br /><span class="line"><span class="number">38</span>:         <span class="comment">// 设置已经调用的 Invoker 集合，到 Context 中</span></span><br /><span class="line"><span class="number">39</span>:         RpcContext.getContext().setInvokers((List) selected);</span><br /><span class="line"><span class="number">40</span>:         <span class="comment">// 异常计数器</span></span><br /><span class="line"><span class="number">41</span>:         <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br /><span class="line"><span class="number">42</span>:         <span class="comment">// 创建阻塞队列</span></span><br /><span class="line"><span class="number">43</span>:         <span class="keyword">final</span> BlockingQueue&lt;Object&gt; ref = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;();</span><br /><span class="line"><span class="number">44</span>:         <span class="comment">// 循环 selected 集合，提交线程池，发起 RPC 调用</span></span><br /><span class="line"><span class="number">45</span>:         <span class="keyword">for</span> (<span class="keyword">final</span> Invoker&lt;T&gt; invoker : selected) {</span><br /><span class="line"><span class="number">46</span>:             executor.execute(<span class="keyword">new</span> Runnable() {</span><br /><span class="line"><span class="number">47</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br /><span class="line"><span class="number">48</span>:                     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">49</span>:                         <span class="comment">// RPC 调用，获得 Result 结果</span></span><br /><span class="line"><span class="number">50</span>:                         Result result = invoker.invoke(invocation);</span><br /><span class="line"><span class="number">51</span>:                         <span class="comment">// 添加 Result 到 `ref` 阻塞队列</span></span><br /><span class="line"><span class="number">52</span>:                         ref.offer(result);</span><br /><span class="line"><span class="number">53</span>:                     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">54</span>:                         <span class="comment">// 异常计数器 + 1</span></span><br /><span class="line"><span class="number">55</span>:                         <span class="keyword">int</span> value = count.incrementAndGet();</span><br /><span class="line"><span class="number">56</span>:                         <span class="comment">// 若 RPC 调用结果都是异常，则添加异常到 `ref` 阻塞队列</span></span><br /><span class="line"><span class="number">57</span>:                         <span class="keyword">if</span> (value &gt;= selected.size()) {</span><br /><span class="line"><span class="number">58</span>:                             ref.offer(e);</span><br /><span class="line"><span class="number">59</span>:                         }</span><br /><span class="line"><span class="number">60</span>:                     }</span><br /><span class="line"><span class="number">61</span>:                 }</span><br /><span class="line"><span class="number">62</span>:             });</span><br /><span class="line"><span class="number">63</span>:         }</span><br /><span class="line"><span class="number">64</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">65</span>:             <span class="comment">// 从 `ref` 队列中，阻塞等待结果</span></span><br /><span class="line"><span class="number">66</span>:             Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);</span><br /><span class="line"><span class="number">67</span>:             <span class="comment">// 若是异常结果，抛出 RpcException 异常</span></span><br /><span class="line"><span class="number">68</span>:             <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> Throwable) {</span><br /><span class="line"><span class="number">69</span>:                 Throwable e = (Throwable) ret;</span><br /><span class="line"><span class="number">70</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>, <span class="string">"Failed to forking invoke provider "</span> + selected + <span class="string">", but no luck to perform the invocation. Last error is: "</span> + e.getMessage(), e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br /><span class="line"><span class="number">71</span>:             }</span><br /><span class="line"><span class="number">72</span>:             <span class="comment">// 若是正常结果，直接返回</span></span><br /><span class="line"><span class="number">73</span>:             <span class="keyword">return</span> (Result) ret;</span><br /><span class="line"><span class="number">74</span>:         } <span class="keyword">catch</span> (InterruptedException e) {</span><br /><span class="line"><span class="number">75</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to forking invoke provider "</span> + selected + <span class="string">", but no luck to perform the invocation. Last error is: "</span> + e.getMessage(), e);</span><br /><span class="line"><span class="number">76</span>:         }</span><br /><span class="line"><span class="number">77</span>:     }</span><br /><span class="line"><span class="number">78</span>: </span><br /><span class="line"><span class="number">79</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 15 至 39 行：胖友自己看代码注释，比较易懂。</li>
<li>第 41 行：<code>count</code>&nbsp;变量，<strong>异常</strong>计数器。</li>
<li>第 43 行：<code>ref</code>&nbsp;变量，阻塞队列。通过它，实现线程池异步执行任务的<strong>结果通知</strong>，非常亮眼。</li>
<li>第 44 至 63 行：循环&nbsp;<code>selected</code>&nbsp;集合，提交线程池，发起 RPC 调用。
<ul>
<li>第 49 至 52 行：调用&nbsp;<code>Invoker#invoke(invocation)</code>&nbsp;方法，RPC 调用，<strong>成功</strong>获得 Result 结果，并将 Result 添加到&nbsp;<code>ref</code>&nbsp;阻塞队列中。</li>
<li>第 53 至 59 行：若调用<strong>失败</strong>，异常计数器&nbsp;<code>count</code>&nbsp;加一。当所有的 RPC 调用都完成，并且都是异常时，则添加<strong>最后一个</strong>异常到&nbsp;<code>ref</code>&nbsp;阻塞队列。🙂 细节处理很到位。</li>
</ul>
</li>
<li>第 66 行：从&nbsp;<code>ref</code>&nbsp;队列中，<strong>阻塞</strong>等待，直到获得到结果或者超时。至此，ForkingClusterInvoker 实现了并行调用，且只要一个成功即返回。当然，还有一个隐性的，<strong>所有都失败才返回</strong>。</li>
<li>第 67 至 76 行：处理等待的&ldquo;结果&rdquo;。</li>
</ul>
<h1 id="8-FailoverCluster">8. FailoverCluster</h1>
<p>FailoverCluster ，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-1-api-interface//?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（一）之抽象 API》</a>&nbsp;一文中，我们已经详细解析。</p>
<h1 id="9-MergeableCluster">9. MergeableCluster</h1>
<p>MergeableCluster ，对应&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 分组聚合》</a>&nbsp;文档，我们后续单独写文章分享。</p>
<h1 id="10-MockClusterWrapper">10. MockClusterWrapper</h1>
<p>MockClusterWrapper ，对应&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash;本地伪装 》</a>&nbsp;文档，我们后续单独写文章分享。</p>
</div>