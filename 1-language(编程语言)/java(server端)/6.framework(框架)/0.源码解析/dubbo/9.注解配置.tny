<header class="article-header">
<h1 class="article-title">注解配置</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.7.1-SNAPSHOT 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>在 Dubbo 提供的几种方式中，<strong>注解配置</strong>慢慢变成大家最常用的方式。</p>
<p>如果胖友不熟悉，可以查看如下文档：</p>
<ul>
<li><a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/annotation.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 注解配置》</a></li>
<li><a href="http://dubbo.apache.org/zh-cn/blog/dubbo-annotation.html" target="_blank" rel="external nofollow noopener noreferrer">《在 Dubbo 中使用注解》</a></li>
<li><a href="https://dubbo.apache.org/zh-cn/blog/dubbo-annotation-driven.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 注解驱动（Annotation-Driven）》</a></li>
</ul>
<h1 id="2-使用示例">2. 使用示例</h1>
<p>我们来看看&nbsp;<code>dubbo-demo-annotation</code>&nbsp;项目下的&nbsp;<code>dubbo-demo-annotation-provider</code>&nbsp;子项目提供的 Dubbo Provider 示例。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// Application.java</span></span><br /><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before</span></span><br /><span class="line"><span class="comment">     * launch the application</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ProviderConfiguration.class);</span><br /><span class="line">        context.start();</span><br /><span class="line">        System.in.read();</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Configuration</span></span><br /><span class="line">    <span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"org.apache.dubbo.demo.provider"</span>) <span class="comment">// &lt;1&gt;</span></span><br /><span class="line">    <span class="meta">@PropertySource</span>(<span class="string">"classpath:/spring/dubbo-provider.properties"</span>) <span class="comment">// &lt;2&gt;</span></span><br /><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>{</span><br /><br /><span class="line">        <span class="meta">@Bean</span> <span class="comment">// &lt;3&gt;</span></span><br /><span class="line">        <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>{</span><br /><span class="line">            RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br /><span class="line">            registryConfig.setAddress(<span class="string">"multicast://224.5.6.7:1234"</span>);</span><br /><span class="line">            <span class="keyword">return</span> registryConfig;</span><br /><span class="line">        }</span><br /><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>&lt;1&gt;</code>&nbsp;处，使用&nbsp;<code>@EnableDubbo</code>&nbsp;注解，配置扫描&nbsp;<code>"org.apache.dubbo.demo.provider"</code>&nbsp;目录下的&nbsp;<code>@Service</code>&nbsp;和&nbsp;<code>@Reference</code>&nbsp;Bean 对象。</li>
<li><code>&lt;2&gt;</code>&nbsp;处，使用&nbsp;<code>@PropertySource</code>&nbsp;注解，导入&nbsp;<code>"classpath:/spring/dubbo-provider.properties"</code>&nbsp;配置文件。</li>
<li><code>&lt;3&gt;</code>&nbsp;处，通过&nbsp;<code>@Bean</code>&nbsp;注解方法，创建 RegistryConfig Bean 对象，即注册中心。</li>
<li>通过使用 Java Config + 注解的方式，相比 XML 来说，会更加熟悉一些~</li>
</ul>
<p>下面，我们就来看看具体的源码落。本文涉及的类，主要如下图所示：<img src="http://static2.iocoder.cn/images/Dubbo/2018_01_22/01.jpg" alt="类" /></p>
<h1 id="3-EnableDubbo">3. @EnableDubbo</h1>
<p><code>org.apache.dubbo.config.spring.context.annotation.@EnableDubbo</code>&nbsp;注解，是&nbsp;<code>@EnableDubboConfig</code>&nbsp;和&nbsp;<code>@DubboComponentScan</code>&nbsp;的组合注解，使用时更加便利。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// EnableDubbo.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Enables Dubbo components as Spring Beans, equals</span></span><br /><span class="line"><span class="comment"> * {<span class="doctag">@link</span> DubboComponentScan} and {<span class="doctag">@link</span> EnableDubboConfig} combination.</span></span><br /><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br /><span class="line"><span class="comment"> * Note : {<span class="doctag">@link</span> EnableDubbo} must base on Spring Framework 4.2 and above</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboComponentScan</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@Target</span>({ElementType.TYPE})</span><br /><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br /><span class="line"><span class="meta">@Inherited</span></span><br /><span class="line"><span class="meta">@Documented</span></span><br /><span class="line"><span class="meta">@EnableDubboConfig</span> <span class="comment">// 开启 Dubbo Config</span></span><br /><span class="line"><span class="meta">@DubboComponentScan</span> <span class="comment">// 扫描 Dubbo @Service 和 @Reference Bean</span></span><br /><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDubbo {</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 配置 <span class="doctag">@DubboComponentScan</span> 注解，扫描的包</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * Base packages to scan for annotated <span class="doctag">@Service</span> classes.</span></span><br /><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br /><span class="line"><span class="comment">     * Use {<span class="doctag">@link</span> #scanBasePackageClasses()} for a type-safe alternative to String-based</span></span><br /><span class="line"><span class="comment">     * package names.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> DubboComponentScan#basePackages()</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="meta">@AliasFor</span>(annotation = DubboComponentScan.class, attribute = <span class="string">"basePackages"</span>)</span><br /><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> {};</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 配置 <span class="doctag">@DubboComponentScan</span> 注解，扫描的类</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * Type-safe alternative to {<span class="doctag">@link</span> #scanBasePackages()} for specifying the packages to</span></span><br /><span class="line"><span class="comment">     * scan for annotated <span class="doctag">@Service</span> classes. The package of each class specified will be</span></span><br /><span class="line"><span class="comment">     * scanned.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> classes from the base packages to scan</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> DubboComponentScan#basePackageClasses</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="meta">@AliasFor</span>(annotation = DubboComponentScan.class, attribute = <span class="string">"basePackageClasses"</span>)</span><br /><span class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> {};</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 配置 <span class="doctag">@EnableDubboConfig</span> 注解，配置是否绑定到多个 Spring Bean 上</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * It indicates whether {<span class="doctag">@link</span> AbstractConfig} binding to multiple Spring Beans.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> the default value is &lt;code&gt;false&lt;/code&gt;</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> EnableDubboConfig#multiple()</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="meta">@AliasFor</span>(annotation = EnableDubboConfig.class, attribute = <span class="string">"multiple"</span>)</span><br /><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">multipleConfig</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>注意看下具体的注释。</li>
</ul>
<blockquote>
<p>通过&nbsp;<code>@EnableDubbo</code>&nbsp;可以在指定的包名下（通过&nbsp;<code>scanBasePackages</code>&nbsp;属性），或者指定的类中（通过&nbsp;<code>scanBasePackageClasses</code>&nbsp;属性）扫描 Dubbo 的服务提供者（以&nbsp;<code>@Service</code>&nbsp;注解）以及 Dubbo 的服务消费者（以&nbsp;<code>@Reference</code>&nbsp;注解）。</p>
<p>扫描到 Dubbo 的服务提供方和消费者之后，对其做相应的组装并初始化，并最终完成服务暴露或者引用的工作。</p>
</blockquote>
<h1 id="4-EnableDubboConfig">4. @EnableDubboConfig</h1>
<p><code>org.apache.dubbo.config.spring.context.annotation.@EnableDubboConfig</code>&nbsp;注解，开启 Dubbo 配置。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// EnableDubboConfig.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * As  a convenient and multiple {<span class="doctag">@link</span> EnableDubboConfigBinding}</span></span><br /><span class="line"><span class="comment"> * in default behavior , is equal to single bean bindings with below convention prefixes of properties:</span></span><br /><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> ApplicationConfig} binding to property : "dubbo.application"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> ModuleConfig} binding to property :  "dubbo.module"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> RegistryConfig} binding to property :  "dubbo.registry"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> ProtocolConfig} binding to property :  "dubbo.protocol"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> MonitorConfig} binding to property :  "dubbo.monitor"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> ProviderConfig} binding to property :  "dubbo.provider"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> ConsumerConfig} binding to property :  "dubbo.consumer"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br /><span class="line"><span class="comment"> * In contrast, on multiple bean bindings that requires to set {<span class="doctag">@link</span> #multiple()} to be &lt;code&gt;true&lt;/code&gt; :</span></span><br /><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> ApplicationConfig} binding to property : "dubbo.applications"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> ModuleConfig} binding to property :  "dubbo.modules"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> RegistryConfig} binding to property :  "dubbo.registries"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> ProtocolConfig} binding to property :  "dubbo.protocols"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> MonitorConfig} binding to property :  "dubbo.monitors"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> ProviderConfig} binding to property :  "dubbo.providers"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;li&gt;{<span class="doctag">@link</span> ConsumerConfig} binding to property :  "dubbo.consumers"&lt;/li&gt;</span></span><br /><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigConfiguration</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigConfigurationSelector</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@Target</span>({ElementType.TYPE})</span><br /><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br /><span class="line"><span class="meta">@Inherited</span></span><br /><span class="line"><span class="meta">@Documented</span></span><br /><span class="line"><span class="meta">@Import</span>(DubboConfigConfigurationRegistrar.class)</span><br /><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDubboConfig {</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * It indicates whether binding to multiple Spring Beans.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 配置是否绑定到多个 Spring Bean 上</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> the default value is &lt;code&gt;false&lt;/code&gt;</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@revised</span> 2.5.9</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">multiple</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>关于&nbsp;<code>multiple</code>&nbsp;属性，可能第一眼会有点懵逼，那咋整呢？
<ul>
<li>第一步，可以看看&nbsp;<a href="https://segmentfault.com/a/1190000012661402#articleHeader4" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 新编程模型之外部化配置 &mdash;&mdash;&nbsp;<code>@EnableDubboConfig</code>》</a>&nbsp;对&nbsp;<code>@EnableDubboConfig</code>&nbsp;注解的介绍。</li>
<li>第二步，我们在接下来会看具体的源码，会更易懂一些。</li>
</ul>
</li>
<li><code>@Import(DubboConfigConfigurationRegistrar.class)</code>&nbsp;注解，表明使用 DubboConfigConfigurationRegistrar 类进行导入。详细的，我们继续来看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「4.1 DubboConfigConfigurationRegistrar」</a>&nbsp;。</li>
</ul>
<h2 id="4-1-DubboConfigConfigurationRegistrar">4.1 DubboConfigConfigurationRegistrar</h2>
<p><code>org.apache.dubbo.config.spring.context.annotation.DubboConfigConfigurationRegistrar</code>&nbsp;，实现 ImportBeanDefinitionRegistrar 接口，处理&nbsp;<code>@EnableDubboConfig</code>&nbsp;注解，注册相应的 DubboConfigConfiguration 到 Spring 容器中。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigConfigurationRegistrar.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Dubbo {<span class="doctag">@link</span> AbstractConfig Config} {<span class="doctag">@link</span> ImportBeanDefinitionRegistrar register}, which order can be configured</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigConfiguration</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> Ordered</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigConfigurationRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>{</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">        <span class="comment">// 获得 @EnableDubboConfig 注解的属性</span></span><br /><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfig.class.getName()));</span><br /><span class="line">        <span class="comment">// 获得 multiple 属性</span></span><br /><span class="line">        <span class="keyword">boolean</span> multiple = attributes.getBoolean(<span class="string">"multiple"</span>);</span><br /><span class="line">        <span class="comment">// 如果为 true ，则注册 DubboConfigConfiguration.Multiple Bean 对象</span></span><br /><span class="line">        <span class="keyword">if</span> (multiple) {</span><br /><span class="line">            AnnotatedBeanDefinitionRegistryUtils.registerBeans(registry, DubboConfigConfiguration.Multiple.class);</span><br /><span class="line">        <span class="comment">// 如果为 false ，则注册 DubboConfigConfiguration.Single Bean 对象</span></span><br /><span class="line">        } <span class="keyword">else</span> {</span><br /><span class="line">            AnnotatedBeanDefinitionRegistryUtils.registerBeans(registry, DubboConfigConfiguration.Single.class);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// AnnotatedBeanDefinitionRegistryUtils.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeans</span><span class="params">(BeanDefinitionRegistry registry, Class&lt;?&gt;... annotatedClasses)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (ObjectUtils.isEmpty(annotatedClasses)) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br /><span class="line">    <span class="comment">// 创建 AnnotatedBeanDefinitionReader 对象</span></span><br /><span class="line">    AnnotatedBeanDefinitionReader reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(registry);</span><br /><span class="line">    <span class="keyword">if</span> (debugEnabled) {</span><br /><span class="line">        logger.debug(registry.getClass().getSimpleName() + <span class="string">" will register annotated classes : "</span> + Arrays.asList(annotatedClasses) + <span class="string">" ."</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 注册</span></span><br /><span class="line">    reader.register(annotatedClasses);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>根据&nbsp;<code>@EnableDubboConfig</code>&nbsp;注解上的&nbsp;<code>multiple</code>&nbsp;属性的不同，创建 DubboConfigConfiguration.Multiple 或 DubboConfigConfiguration.Single 对象，注册到 Spring 容器中。</li>
</ul>
<h2 id="4-2-DubboConfigConfiguration">4.2 DubboConfigConfiguration</h2>
<p><code>org.apache.dubbo.config.spring.beans.factory.annotation.DubboConfigConfiguration</code>&nbsp;，Dubbo AbstractConfig 配置类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigConfiguration.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Dubbo {<span class="doctag">@link</span> AbstractConfig Config} {<span class="doctag">@link</span> Configuration}</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> Configuration</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBindings</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> ApplicationConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> ModuleConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> RegistryConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> ProtocolConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> MonitorConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> ProviderConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConsumerConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.dubbo.config.ConfigCenterConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigConfiguration</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Single Dubbo {<span class="doctag">@link</span> AbstractConfig Config} Bean Binding</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="meta">@EnableDubboConfigBindings</span>({</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.application"</span>, type = ApplicationConfig.class),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.module"</span>, type = ModuleConfig.class),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.registry"</span>, type = RegistryConfig.class),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.protocol"</span>, type = ProtocolConfig.class),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.monitor"</span>, type = MonitorConfig.class),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.provider"</span>, type = ProviderConfig.class),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.consumer"</span>, type = ConsumerConfig.class),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.config-center"</span>, type = ConfigCenterBean.class),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.metadata-report"</span>, type = MetadataReportConfig.class)</span><br /><span class="line">    })</span><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>{</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Multiple Dubbo {<span class="doctag">@link</span> AbstractConfig Config} Bean Binding</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="meta">@EnableDubboConfigBindings</span>({</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.applications"</span>, type = ApplicationConfig.class, multiple = <span class="keyword">true</span>),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.modules"</span>, type = ModuleConfig.class, multiple = <span class="keyword">true</span>),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.registries"</span>, type = RegistryConfig.class, multiple = <span class="keyword">true</span>),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.protocols"</span>, type = ProtocolConfig.class, multiple = <span class="keyword">true</span>),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.monitors"</span>, type = MonitorConfig.class, multiple = <span class="keyword">true</span>),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.providers"</span>, type = ProviderConfig.class, multiple = <span class="keyword">true</span>),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.consumers"</span>, type = ConsumerConfig.class, multiple = <span class="keyword">true</span>),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.config-centers"</span>, type = ConfigCenterBean.class, multiple = <span class="keyword">true</span>),</span><br /><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.metadata-reports"</span>, type = MetadataReportConfig.class, multiple = <span class="keyword">true</span>)</span><br /><span class="line">    })</span><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiple</span> </span>{</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>乍眼一看，就是 Single 和 Multiple 内部类。其上都有&nbsp;<code>@@EnableDubboConfigBindings</code>&nbsp;和&nbsp;<code>@EnableDubboConfigBinding</code>&nbsp;注解。
<ul>
<li>前者 Single ，其上的注解，<code>prefix</code>&nbsp;都是单数。</li>
<li>后者 Multiple ，其上的注解，<code>prefix</code>&nbsp;都是复数，且有&nbsp;<code>multiple = true</code>&nbsp;。</li>
</ul>
</li>
<li>那么会有什么效果呢？我们继续往&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「4.3 @@EnableDubboConfigBindings」</a>&nbsp;和&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「4.4 @@EnableDubboConfigBinding」</a>&nbsp;看。</li>
</ul>
<h2 id="4-3-EnableDubboConfigBindings">4.3 @EnableDubboConfigBindings</h2>
<p><code>org.apache.dubbo.config.spring.context.annotation.@EnableDubboConfigBindings</code>&nbsp;注解，是&nbsp;<code>@EnableDubboConfigBinding</code>&nbsp;注解的数组。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// EnableDubboConfigBindings.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Multiple {<span class="doctag">@link</span> EnableDubboConfigBinding} {<span class="doctag">@link</span> Annotation}</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@Target</span>({ElementType.TYPE})</span><br /><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br /><span class="line"><span class="meta">@Documented</span></span><br /><span class="line"><span class="meta">@Import</span>(DubboConfigBindingsRegistrar.class)</span><br /><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDubboConfigBindings {</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * The value of {<span class="doctag">@link</span> EnableDubboConfigBindings}</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    EnableDubboConfigBinding[] value();</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>@Import(DubboConfigBindingsRegistrar.class)</code>&nbsp;注解，表明使用 DubboConfigBindingsRegistrar 类进行导入。详细的，我们继续来看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「4.3.1 DubboConfigBindingsRegistrar」</a>&nbsp;。</li>
</ul>
<h3 id="4-3-1-DubboConfigBindingsRegistrar">4.3.1 DubboConfigBindingsRegistrar</h3>
<p><code>org.apache.dubbo.config.spring.context.annotation.DubboConfigBindingsRegistrar</code>&nbsp;，实现 ImportBeanDefinitionRegistrar、EnvironmentAware 接口，处理&nbsp;<code>@EnableDubboConfigBindings</code>&nbsp;注解，注册相应的 Dubbo AbstractConfig 到 Spring 容器中。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigBindingsRegistrar.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * {<span class="doctag">@link</span> AbstractConfig Dubbo Config} binding Bean registrar for {<span class="doctag">@link</span> EnableDubboConfigBindings}</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBindings</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingRegistrar</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">        <span class="comment">// &lt;1.1&gt; 获得 @EnableDubboConfigBindings 注解</span></span><br /><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName()));</span><br /><span class="line">        <span class="comment">// &lt;1.2&gt; 获得内部的 @EnableDubboConfigBinding 注解的数组</span></span><br /><span class="line">        AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray(<span class="string">"value"</span>);</span><br /><span class="line">        <span class="comment">// &lt;2&gt; 创建 DubboConfigBindingRegistrar 对象，并设置 environment 属性</span></span><br /><span class="line">        DubboConfigBindingRegistrar registrar = <span class="keyword">new</span> DubboConfigBindingRegistrar();</span><br /><span class="line">        registrar.setEnvironment(environment);</span><br /><span class="line">        <span class="comment">// &lt;3&gt; 遍历 annotationAttributes 数组，使用 registrar 进行逐个 @EnableDubboConfigBinding 注解的注册对应的 Bean</span></span><br /><span class="line">        <span class="keyword">for</span> (AnnotationAttributes element : annotationAttributes) {</span><br /><span class="line">            registrar.registerBeanDefinitions(element, registry);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>{</span><br /><span class="line">        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);</span><br /><span class="line">        <span class="keyword">this</span>.environment = (ConfigurableEnvironment) environment;</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>&lt;1.1&gt;</code>、<code>&lt;1.2&gt;</code>&nbsp;处，获得&nbsp;<code>@EnableDubboConfigBindings</code>&nbsp;注解，从而后面获得内部的&nbsp;<code>@EnableDubboConfigBinding</code>&nbsp;注解的数组。</li>
<li><code>&lt;2&gt;</code>&nbsp;处，创建 DubboConfigBindingRegistrar 对象，并设置&nbsp;<code>environment</code>&nbsp;属性。</li>
<li><code>&lt;3&gt;</code>&nbsp;处，遍历&nbsp;<code>annotationAttributes</code>&nbsp;数组，使用&nbsp;<code>registrar</code>&nbsp;，调用&nbsp;<code>DubboConfigBindingRegistrar#registerBeanDefinitions(AnnotationAttributes attributes, BeanDefinitionRegistry registry)</code>&nbsp;方法，进行逐个&nbsp;<code>@EnableDubboConfigBinding</code>&nbsp;注解的注册对应的 Bean 。</li>
<li>在下文中，我们会看到 DubboConfigBindingRegistrar 本来就是用来处理&nbsp;<code>EnableDubboConfigBinding</code>&nbsp;注解。</li>
</ul>
<h2 id="4-4-EnableDubboConfigBinding">4.4 @EnableDubboConfigBinding</h2>
<p><code>org.apache.dubbo.config.spring.context.annotation.@EnableDubboConfigBinding</code>&nbsp;注解，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// EnableDubboConfigBinding.java</span></span><br /><br /><span class="line"><span class="meta">@Target</span>({ElementType.TYPE, ElementType.ANNOTATION_TYPE})</span><br /><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br /><span class="line"><span class="meta">@Documented</span></span><br /><span class="line"><span class="meta">@Repeatable</span>(EnableDubboConfigBindings.class)</span><br /><span class="line"><span class="meta">@Import</span>(DubboConfigBindingRegistrar.class)</span><br /><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDubboConfigBinding {</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * The name prefix of the properties that are valid to bind to {<span class="doctag">@link</span> AbstractConfig Dubbo Config}.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 配置前缀</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> the name prefix of the properties to bind</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span></span>;</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 配置类</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> The binding type of {<span class="doctag">@link</span> AbstractConfig Dubbo Config}.</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> AbstractConfig</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> ApplicationConfig</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> ModuleConfig</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> RegistryConfig</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    Class&lt;? extends AbstractConfig&gt; type();</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 是否 multiple</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * It indicates whether {<span class="doctag">@link</span> #prefix()} binding to multiple Spring Beans.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> the default value is &lt;code&gt;false&lt;/code&gt;</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">multiple</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>每个属性，看其上的代码注释。</li>
<li>
<ul>
<li><code>@Import(DubboConfigBindingRegistrar.class)</code>&nbsp;注解，表明使用 DubboConfigBindingRegistrar 类进行导入。详细的，我们继续来看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「4.4.1 DubboConfigBindingRegistrar」</a>&nbsp;。</li>
</ul>
</li>
</ul>
<h3 id="4-4-1-DubboConfigBindingRegistrar">4.4.1 DubboConfigBindingRegistrar</h3>
<p><code>org.apache.dubbo.config.spring.context.annotation.DubboConfigBindingRegistrar</code>&nbsp;，实现 ImportBeanDefinitionRegistrar、EnvironmentAware 接口，处理&nbsp;<code>@EnableDubboConfigBinding</code>&nbsp;注解，注册相应的 Dubbo AbstractConfig 到 Spring 容器中。</p>
<h4 id="4-4-1-1-registerBeanDefinitions">4.4.1.1 registerBeanDefinitions</h4>
<p>实现&nbsp;<code>#registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</code>&nbsp;方法，处理&nbsp;<code>@EnableDubboConfigBinding</code>&nbsp;注解，注册相应的 Dubbo AbstractConfig 到 Spring 容器中。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigBindingRegistrar.java</span></span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    <span class="comment">// &lt;1&gt; 获得 @EnableDubboConfigBinding 注解</span></span><br /><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding.class.getName()));</span><br /><span class="line">    <span class="comment">// &lt;2&gt; 注册配置对应的 Bean Definition 对象</span></span><br /><span class="line">    registerBeanDefinitions(attributes, registry);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationAttributes attributes, BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    <span class="comment">// &lt;2.1&gt; 获得 prefix 属性</span></span><br /><span class="line">    String prefix = environment.resolvePlaceholders(attributes.getString(<span class="string">"prefix"</span>)); <span class="comment">// 因为，有可能有占位符，所以要解析。</span></span><br /><span class="line">    <span class="comment">// &lt;2.2&gt; 获得 type 属性，即 AbstractConfig 的实现类</span></span><br /><span class="line">    Class&lt;? extends AbstractConfig&gt; configClass = attributes.getClass(<span class="string">"type"</span>);</span><br /><span class="line">    <span class="comment">// &lt;2.3&gt; 获得 multiple 属性</span></span><br /><span class="line">    <span class="keyword">boolean</span> multiple = attributes.getBoolean(<span class="string">"multiple"</span>);</span><br /><span class="line">    <span class="comment">// &lt;2.4&gt; 注册 Dubbo Config Bean 对象</span></span><br /><span class="line">    registerDubboConfigBeans(prefix, configClass, multiple, registry);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>&lt;1&gt;</code>&nbsp;处，获得&nbsp;<code>@EnableDubboConfigBinding</code>&nbsp;注解。</li>
<li><code>&lt;2&gt;</code>&nbsp;注册配置对应的 Bean Definition 对象。😈 这里有个知识点要补充下，Spring 在创建 Bean 之前，会将 XML 配置或者注解配置，先解析成对应的 BeanDefinition 对象，然后在创建 Bean 对象。
<ul>
<li><code>&lt;2.1&gt;</code>&nbsp;处，获得&nbsp;<code>prefix</code>&nbsp;属性。</li>
<li><code>&lt;2.2&gt;</code>&nbsp;处，获得&nbsp;<code>type</code>&nbsp;属性，即 AbstractConfig 的实现类。</li>
<li><code>&lt;2.3&gt;</code>&nbsp;处，获得&nbsp;<code>multiple</code>&nbsp;属性。</li>
<li><code>&lt;2.4&gt;</code>&nbsp;处，调用&nbsp;<code>#registerDubboConfigBeans(String prefix, Class&lt;? extends AbstractConfig&gt; configClass, boolean multiple, BeanDefinitionRegistry registry)</code>&nbsp;方法，注册 Dubbo Config Bean 对象。</li>
</ul>
</li>
</ul>
<h4 id="4-4-1-2-registerDubboConfigBeans">4.4.1.2 registerDubboConfigBeans</h4>
<p><code>#registerDubboConfigBeans(String prefix, Class&lt;? extends AbstractConfig&gt; configClass, boolean multiple, BeanDefinitionRegistry registry)</code>&nbsp;方法，注册 Dubbo Config Bean 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigBindingRegistrar.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBeans</span><span class="params">(String prefix, Class&lt;? extends AbstractConfig&gt; configClass, <span class="keyword">boolean</span> multiple,</span></span></span><br /><span class="line"><span class="function"><span class="params">                                      BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    <span class="comment">// &lt;1.1&gt; 获得 prefix 开头的配置属性</span></span><br /><span class="line">    Map&lt;String, Object&gt; properties = PropertySourcesUtils.getSubProperties(environment.getPropertySources(), prefix);</span><br /><span class="line">    <span class="comment">// &lt;1.2&gt; 如果配置属性为空，则无需创建</span></span><br /><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(properties)) {</span><br /><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br /><span class="line">            log.debug(<span class="string">"There is no property for binding to dubbo config class ["</span> + configClass.getName()</span><br /><span class="line">                    + <span class="string">"] within prefix ["</span> + prefix + <span class="string">"]"</span>);</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// &lt;2&gt; 获得配置属性对应的 Bean 名字的集合</span></span><br /><span class="line">    Set&lt;String&gt; beanNames = multiple ? resolveMultipleBeanNames(properties) :</span><br /><span class="line">            Collections.singleton(resolveSingleBeanName(properties, configClass, registry));</span><br /><span class="line">    <span class="comment">// &lt;3&gt; 遍历 beanNames 数组，逐个注册</span></span><br /><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br /><span class="line">        <span class="comment">// &lt;3.1&gt; 注注册 Dubbo Config Bean 对象</span></span><br /><span class="line">        registerDubboConfigBean(beanName, configClass, registry);</span><br /><span class="line">        <span class="comment">// &lt;3.2&gt; 注注册 Dubbo Config 对象对应的 DubboConfigBindingBeanPostProcessor 对象</span></span><br /><span class="line">        registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>&lt;1.1&gt;</code>&nbsp;处，调用&nbsp;<code>PropertySourcesUtils#getSubProperties(Iterable&lt;PropertySource&lt;?&gt;&gt; propertySources, String prefix)</code>&nbsp;方法，获得&nbsp;<code>prefix</code>&nbsp;开头的配置属性。因为，后续会用这个属性，设置到创建的 Bean 对象中。</li>
<li><code>&lt;1.2&gt;</code>&nbsp;处，如果配置属性为空，则无需创建。</li>
<li>
<p><code>&lt;2&gt;</code>&nbsp;处，根据&nbsp;<code>multiple</code>&nbsp;的值，调用不同的方法，获得配置属性对应的 Bean 名字的集合。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigBindingRegistrar.java</span></span><br /><br /><span class="line"><span class="comment">// 例如：dubbo.application.${beanName}.name=dubbo-demo-annotation-provider</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">resolveMultipleBeanNames</span><span class="params">(Map&lt;String, Object&gt; properties)</span> </span>{</span><br /><span class="line">    Set&lt;String&gt; beanNames = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br /><span class="line">    <span class="keyword">for</span> (String propertyName : properties.keySet()) {</span><br /><span class="line">        <span class="comment">// 获取上述示例的 ${beanName} 字符串</span></span><br /><span class="line">        <span class="keyword">int</span> index = propertyName.indexOf(<span class="string">"."</span>);</span><br /><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) {</span><br /><span class="line">            String beanName = propertyName.substring(<span class="number">0</span>, index);</span><br /><span class="line">            beanNames.add(beanName);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> beanNames;</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// 例如：dubbo.application.name=dubbo-demo-annotation-provider</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">resolveSingleBeanName</span><span class="params">(Map&lt;String, Object&gt; properties, Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br /><span class="line"><span class="function"><span class="params">                                     BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    <span class="comment">// 获得 Bean 的名字</span></span><br /><span class="line">    String beanName = (String) properties.get(<span class="string">"id"</span>);</span><br /><span class="line">    <span class="comment">// 如果定义，基于 Spring 提供的机制，生成对应的 Bean 的名字。例如说：org.apache.dubbo.config.ApplicationConfig#0</span></span><br /><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName)) {</span><br /><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(configClass);</span><br /><span class="line">        beanName = BeanDefinitionReaderUtils.generateBeanName(builder.getRawBeanDefinition(), registry);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> beanName;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>这两个方法，看看我提供的示例。</li>
<li>
<p><code>#resolveMultipleBeanNames(Map&lt;String, Object&gt; properties)</code>&nbsp;方法，可能比较难理解一点。胖友可以增加如下到配置文件中：</p>
<figure class="highlight plain">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"># application.properties</span><br /><span class="line">dubbo.applications.x.name=biu</span><br /><span class="line">dubbo.applications.y.name=biubiubiu</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>此时，你需要指定&nbsp;<code>@Service</code>&nbsp;Bean 使用哪个应用。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>&lt;3&gt;</code>&nbsp;处，遍历&nbsp;<code>beanNames</code>&nbsp;数组，逐个注册。</p>
<ul>
<li>
<p><code>&lt;3.1&gt;</code>&nbsp;处，调用&nbsp;<code>#registerDubboConfigBean(String beanName, Class&lt;? extends AbstractConfig&gt; configClass, BeanDefinitionRegistry registry)</code>&nbsp;方法，注册 Dubbo Config Bean 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigBindingRegistrar.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBean</span><span class="params">(String beanName, Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br /><span class="line"><span class="function"><span class="params">                                     BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 BeanDefinitionBuilder 对象</span></span><br /><span class="line">    BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(configClass);</span><br /><span class="line">    <span class="comment">// 获得 AbstractBeanDefinition 对象</span></span><br /><span class="line">    AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br /><span class="line">    <span class="comment">// 注册到 registry 中</span></span><br /><span class="line">    registry.registerBeanDefinition(beanName, beanDefinition);</span><br /><span class="line">    <span class="keyword">if</span> (log.isInfoEnabled()) {</span><br /><span class="line">        log.info(<span class="string">"The dubbo config bean definition [name : "</span> + beanName + <span class="string">", class : "</span> + configClass.getName() + <span class="string">"] has been registered."</span>);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>此时，仅仅是通过酱紫的方式，创建了一个 Dubbo Config Bean 对象，并没有将配置属性，设置到该对象中。答案在&nbsp;<code>&lt;3.2&gt;</code>&nbsp;中。</li>
</ul>
</li>
<li>
<p><code>&lt;3.2&gt;</code>&nbsp;处，调用&nbsp;<code>#registerDubboConfigBindingBeanPostProcessor(String prefix, String beanName, boolean multiple, BeanDefinitionRegistry registry)</code>&nbsp;方法，注册 Dubbo Config 对象对象的 DubboConfigBindingBeanPostProcessor 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigBindingRegistrar.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBindingBeanPostProcessor</span><span class="params">(String prefix, String beanName, <span class="keyword">boolean</span> multiple,</span></span></span><br /><span class="line"><span class="function"><span class="params">                                                         BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 BeanDefinitionBuilder 对象</span></span><br /><span class="line">    Class&lt;?&gt; processorClass = DubboConfigBindingBeanPostProcessor.class;</span><br /><span class="line">    BeanDefinitionBuilder builder = rootBeanDefinition(processorClass);</span><br /><span class="line">    <span class="comment">// 添加构造方法的参数为 actualPrefix 和 beanName 。即，创建 DubboConfigBindingBeanPostProcessor 对象，需要这两个构造参数</span></span><br /><span class="line">    String actualPrefix = multiple ? PropertySourcesUtils.normalizePrefix(prefix) + beanName : prefix;</span><br /><span class="line">    builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);</span><br /><span class="line">    <span class="comment">// 获得 AbstractBeanDefinition 对象</span></span><br /><span class="line">    AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br /><span class="line">    <span class="comment">// 设置 role 属性</span></span><br /><span class="line">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br /><span class="line">    <span class="comment">// 注册到 registry 中</span></span><br /><span class="line">    BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br /><span class="line">    <span class="keyword">if</span> (log.isInfoEnabled()) {</span><br /><span class="line">        log.info(<span class="string">"The BeanPostProcessor bean definition ["</span> + processorClass.getName() + <span class="string">"] for dubbo config bean [name : "</span> + beanName + <span class="string">"] has been registered."</span>);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>因为此时 Dubbo Config Bean 对象还未创建，所以需要等后续它真的创建之后，使用 DubboConfigBindingBeanPostProcessor 类，实现对对象（Bean 对象）的配置输入的设置。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>至此，我们发现，需要继续挖掘，让我们继续来看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「DubboConfigBindingBeanPostProcessor」</a>&nbsp;类。</p>
<h2 id="4-5-DubboConfigBindingBeanPostProcessor">4.5 DubboConfigBindingBeanPostProcessor</h2>
<p><code>org.apache.dubbo.config.spring.beans.factory.annotation.DubboConfigBindingBeanPostProcessor</code>&nbsp;，实现 BeanPostProcessor、ApplicationContextAware、InitializingBean 接口，处理 Dubbo AbstractConfig Bean 的配置属性注入。</p>
<h3 id="4-5-1-构造方法">4.5.1 构造方法</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigBindingBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * The prefix of Configuration Properties</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 配置属性的前缀</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Binding Bean Name</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * Bean 的名字</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br /><br /><span class="line"><span class="keyword">private</span> DubboConfigBinder dubboConfigBinder;</span><br /><br /><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否忽略位置的属性</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ignoreUnknownFields = <span class="keyword">true</span>;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否忽略类型不对的属性</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ignoreInvalidFields = <span class="keyword">true</span>;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> prefix   the prefix of Configuration Properties</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the binding Bean Name</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DubboConfigBindingBeanPostProcessor</span><span class="params">(String prefix, String beanName)</span> </span>{</span><br /><span class="line">    Assert.notNull(prefix, <span class="string">"The prefix of Configuration Properties must not be null"</span>);</span><br /><span class="line">    Assert.notNull(beanName, <span class="string">"The name of bean must not be null"</span>);</span><br /><span class="line">    <span class="keyword">this</span>.prefix = prefix;</span><br /><span class="line">    <span class="keyword">this</span>.beanName = beanName;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>所以，我们在上文中会看到，创建 DubboConfigBindingBeanPostProcessor Bean 时，会有&nbsp;<code>builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);</code>&nbsp;一段的代码。</li>
</ul>
<h3 id="4-5-2-afterPropertiesSet">4.5.2 afterPropertiesSet</h3>
<p><code>#afterPropertiesSet()</code>&nbsp;方法，设置&nbsp;<code>dubboConfigBinder</code>&nbsp;属性。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigBindingBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line">    <span class="comment">// 获得（创建）DubboConfigBinder 对象</span></span><br /><span class="line">    <span class="keyword">if</span> (dubboConfigBinder == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class);</span><br /><span class="line">        } <span class="keyword">catch</span> (BeansException ignored) {</span><br /><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br /><span class="line">                log.debug(<span class="string">"DubboConfigBinder Bean can't be found in ApplicationContext."</span>);</span><br /><span class="line">            }</span><br /><span class="line">            <span class="comment">// Use Default implementation</span></span><br /><span class="line">            dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 设置 ignoreUnknownFields、ignoreInvalidFields 属性</span></span><br /><span class="line">    dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);</span><br /><span class="line">    dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Create {<span class="doctag">@link</span> DubboConfigBinder} instance.</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> environment</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@link</span> DefaultDubboConfigBinder}</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> DubboConfigBinder <span class="title">createDubboConfigBinder</span><span class="params">(Environment environment)</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 DefaultDubboConfigBinder 对象</span></span><br /><span class="line">    DefaultDubboConfigBinder defaultDubboConfigBinder = <span class="keyword">new</span> DefaultDubboConfigBinder();</span><br /><span class="line">    <span class="comment">// 设置 environment 属性</span></span><br /><span class="line">    defaultDubboConfigBinder.setEnvironment(environment);</span><br /><span class="line">    <span class="keyword">return</span> defaultDubboConfigBinder;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>关于 DefaultDubboConfigBinder 类，我们在下面的小节先来瞅瞅。</li>
</ul>
<h4 id="4-5-2-1-DubboConfigBinder">4.5.2.1 DubboConfigBinder</h4>
<p><code>org.apache.dubbo.config.spring.context.properties.DubboConfigBinder</code>&nbsp;，继承 EnvironmentAware 接口，Dubbo Config Binder 接口。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigBinder.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * {<span class="doctag">@link</span> AbstractConfig DubboConfig} Binder</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> AbstractConfig</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnvironmentAware</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.11</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DubboConfigBinder</span> <span class="keyword">extends</span> <span class="title">EnvironmentAware</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Set whether to ignore unknown fields, that is, whether to ignore bind</span></span><br /><span class="line"><span class="comment">     * parameters that do not have corresponding fields in the target object.</span></span><br /><span class="line"><span class="comment">     * &lt;p&gt;Default is "true". Turn this off to enforce that all bind parameters</span></span><br /><span class="line"><span class="comment">     * must have a matching field in the target object.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> #bind</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIgnoreUnknownFields</span><span class="params">(<span class="keyword">boolean</span> ignoreUnknownFields)</span></span>;</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Set whether to ignore invalid fields, that is, whether to ignore bind</span></span><br /><span class="line"><span class="comment">     * parameters that have corresponding fields in the target object which are</span></span><br /><span class="line"><span class="comment">     * not accessible (for example because of null values in the nested path).</span></span><br /><span class="line"><span class="comment">     * &lt;p&gt;Default is "false".</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> #bind</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIgnoreInvalidFields</span><span class="params">(<span class="keyword">boolean</span> ignoreInvalidFields)</span></span>;</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Bind the properties to Dubbo Config Object under specified prefix.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> dubboConfig</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    &lt;C extends AbstractConfig&gt; <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(String prefix, C dubboConfig)</span></span>;</span><br />    <br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>后续的实现，我们会看到基于 Spring DataBinder 来实现。不了解 DataBinder 的胖友，可以看看&nbsp;<a href="https://my.oschina.net/u/2453016/blog/1512184" target="_blank" rel="external nofollow noopener noreferrer">《Spring 验证、数据绑定和类型转换》</a>&nbsp;文章。</li>
</ul>
<h4 id="4-5-2-2-DubboConfigBinder">4.5.2.2 DubboConfigBinder</h4>
<p><code>org.apache.dubbo.config.spring.context.properties.AbstractDubboConfigBinder</code>&nbsp;，实现 DubboConfigBinder 接口，DubboConfigBinder 的抽象基类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// AbstractDubboConfigBinder.java</span></span><br /><br /><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDubboConfigBinder</span> <span class="keyword">implements</span> <span class="title">DubboConfigBinder</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * PropertySource 数组（迭代）</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> Iterable&lt;PropertySource&lt;?&gt;&gt; propertySources;</span><br /><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ignoreUnknownFields = <span class="keyword">true</span>;</span><br /><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ignoreInvalidFields = <span class="keyword">false</span>;</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Get multiple {<span class="doctag">@link</span> PropertySource propertySources}</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> multiple {<span class="doctag">@link</span> PropertySource propertySources}</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">protected</span> Iterable&lt;PropertySource&lt;?&gt;&gt; getPropertySources() {</span><br /><span class="line">        <span class="keyword">return</span> propertySources;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIgnoreUnknownFields</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> ignoreUnknownFields;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIgnoreUnknownFields</span><span class="params">(<span class="keyword">boolean</span> ignoreUnknownFields)</span> </span>{</span><br /><span class="line">        <span class="keyword">this</span>.ignoreUnknownFields = ignoreUnknownFields;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIgnoreInvalidFields</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> ignoreInvalidFields;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIgnoreInvalidFields</span><span class="params">(<span class="keyword">boolean</span> ignoreInvalidFields)</span> </span>{</span><br /><span class="line">        <span class="keyword">this</span>.ignoreInvalidFields = ignoreInvalidFields;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>{</span><br /><span class="line">        <span class="keyword">if</span> (environment <span class="keyword">instanceof</span> ConfigurableEnvironment) {</span><br /><span class="line">            <span class="keyword">this</span>.propertySources = ((ConfigurableEnvironment) environment).getPropertySources();</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>提供默认的属性。</li>
</ul>
<h4 id="4-5-2-3-DefaultDubboConfigBinder">4.5.2.3 DefaultDubboConfigBinder</h4>
<p><code>org.apache.dubbo.config.spring.context.properties.DefaultDubboConfigBinder</code>&nbsp;，继承 AbstractDubboConfigBinder 抽象类，使用 Spring DataBinder ，将配置属性设置到 Dubbo Config 对象中。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DefaultDubboConfigBinder.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Default {<span class="doctag">@link</span> DubboConfigBinder} implementation based on Spring {<span class="doctag">@link</span> DataBinder}</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDubboConfigBinder</span> <span class="keyword">extends</span> <span class="title">AbstractDubboConfigBinder</span> </span>{</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> &lt;C extends AbstractConfig&gt; <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(String prefix, C dubboConfig)</span> </span>{</span><br /><span class="line">        <span class="comment">// 将 dubboConfig 包装成 DataBinder 对象</span></span><br /><span class="line">        DataBinder dataBinder = <span class="keyword">new</span> DataBinder(dubboConfig);</span><br /><span class="line">        <span class="comment">// Set ignored*</span></span><br /><span class="line">        <span class="comment">// 设置响应的 ignored* 属性</span></span><br /><span class="line">        dataBinder.setIgnoreInvalidFields(isIgnoreInvalidFields());</span><br /><span class="line">        dataBinder.setIgnoreUnknownFields(isIgnoreUnknownFields());</span><br /><span class="line">        <span class="comment">// Get properties under specified prefix from PropertySources</span></span><br /><span class="line">        <span class="comment">// 获得 prefix 开头的配置属性</span></span><br /><span class="line">        Map&lt;String, Object&gt; properties = PropertySourcesUtils.getSubProperties(getPropertySources(), prefix);</span><br /><span class="line">        <span class="comment">// Convert Map to MutablePropertyValues</span></span><br /><span class="line">        <span class="comment">// 创建 MutablePropertyValues 对象</span></span><br /><span class="line">        MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues(properties);</span><br /><span class="line">        <span class="comment">// Bind</span></span><br /><span class="line">        <span class="comment">// 绑定配置属性到 dubboConfig 中</span></span><br /><span class="line">        dataBinder.bind(propertyValues);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>比较简单，胖友自己瞅一眼代码即可。</li>
</ul>
<p>在&nbsp;<a href="http://www.iocoder.cn/Dubbo/spring-boot-integration/" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 源码分析 &mdash;&mdash; 集成 Spring Boot》</a>&nbsp;中，我们可以看到另外一个 AbstractDubboConfigBinder 的实现类 RelaxedDubboConfigBinder ，它是基于 Spring Boot&nbsp;<a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/properties/bind/Binder.html" target="_blank" rel="external nofollow noopener noreferrer">Binder</a>&nbsp;进行实现。😈 因为艿艿没有深入了解过 Spring Boot Binder 相关，所以还说不出和 Spring DataBinder 的区别在哪。orz</p>
<h3 id="4-5-3-postProcessBeforeInitialization">4.5.3 postProcessBeforeInitialization</h3>
<p>实现&nbsp;<code>#postProcessBeforeInitialization(Object bean, String beanName)</code>&nbsp;方法，设置配置属性到 Dubbo Config 中。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboConfigBindingBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br /><span class="line">    <span class="comment">// 判断必须是 beanName ，并且是 AbstractConfig 类型</span></span><br /><span class="line">    <span class="keyword">if</span> (beanName.equals(<span class="keyword">this</span>.beanName) &amp;&amp; bean <span class="keyword">instanceof</span> AbstractConfig) {</span><br /><span class="line">        AbstractConfig dubboConfig = (AbstractConfig) bean;</span><br /><span class="line">        <span class="comment">// 设置属性到 dubboConfig 中</span></span><br /><span class="line">        dubboConfigBinder.bind(prefix, dubboConfig);</span><br /><span class="line">        <span class="keyword">if</span> (log.isInfoEnabled()) {</span><br /><span class="line">            log.info(<span class="string">"The properties of bean [name : "</span> + beanName + <span class="string">"] have been binding by prefix of "</span> + <span class="string">"configuration properties : "</span> + prefix);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> bean;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p>至此，Dubbo Config 对象的创建和属性设置，已经完成。如果胖友还是有点懵逼，可以调试一次，没有什么复杂逻辑哟。</p>
<h1 id="5-DubboComponentScan">5. @DubboComponentScan</h1>
<p><code>org.apache.dubbo.config.spring.context.annotation.@DubboComponentScan</code>&nbsp;注解，配置要扫描&nbsp;<code>@Service</code>&nbsp;和&nbsp;<code>@Reference</code>&nbsp;注解的包或者类们，从而创建对应的 Bean 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboComponentScan.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Dubbo Component Scan {<span class="doctag">@link</span> Annotation},scans the classpath for annotated components that will be auto-registered as</span></span><br /><span class="line"><span class="comment"> * Spring beans. Dubbo-provided {<span class="doctag">@link</span> Service} and {<span class="doctag">@link</span> Reference}.</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> Service</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> Reference</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.7</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br /><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br /><span class="line"><span class="meta">@Documented</span></span><br /><span class="line"><span class="meta">@Import</span>(DubboComponentScanRegistrar.class)</span><br /><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan {</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 和 {<span class="doctag">@link</span> #basePackages()} 等价</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * Alias for the {<span class="doctag">@link</span> #basePackages()} attribute. Allows for more concise annotation</span></span><br /><span class="line"><span class="comment">     * declarations e.g.: {<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>("org.my.pkg")} instead of</span></span><br /><span class="line"><span class="comment">     * {<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>(basePackages="org.my.pkg")}.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String[] value() <span class="keyword">default</span> {};</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 要扫描的包的数组</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * Base packages to scan for annotated <span class="doctag">@Service</span> classes. {<span class="doctag">@link</span> #value()} is an</span></span><br /><span class="line"><span class="comment">     * alias for (and mutually exclusive with) this attribute.</span></span><br /><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br /><span class="line"><span class="comment">     * Use {<span class="doctag">@link</span> #basePackageClasses()} for a type-safe alternative to String-based</span></span><br /><span class="line"><span class="comment">     * package names.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String[] basePackages() <span class="keyword">default</span> {};</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 要扫描的类的数组</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * Type-safe alternative to {<span class="doctag">@link</span> #basePackages()} for specifying the packages to</span></span><br /><span class="line"><span class="comment">     * scan for annotated <span class="doctag">@Service</span> classes. The package of each class specified will be</span></span><br /><span class="line"><span class="comment">     * scanned.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> classes from the base packages to scan</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> {};</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>@Import(DubboComponentScanRegistrar.class)</code>&nbsp;注解，表明使用 DubboComponentScanRegistrar 类进行导入。详细的，我们继续来看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「5.1 DubboComponentScanRegistrar」</a>&nbsp;。</li>
</ul>
<h2 id="5-1-DubboComponentScanRegistrar">5.1 DubboComponentScanRegistrar</h2>
<p><code>org.apache.dubbo.config.spring.context.annotation.DubboComponentScanRegistrar</code>&nbsp;，实现 ImportBeanDefinitionRegistrar 接口，处理&nbsp;<code>@DubboComponentScan</code>&nbsp;注解，注册相应的 ServiceAnnotationBeanPostProcessor 和 ReferenceAnnotationBeanPostProcessor 到 Spring 容器中。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboComponentScanRegistrar.java</span></span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    <span class="comment">// &lt;1&gt; 获得要扫描的包</span></span><br /><span class="line">    Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br /><span class="line">    <span class="comment">// &lt;2&gt; 创建 ServiceAnnotationBeanPostProcessor Bean 对象，后续扫描 `@Service` 注解的类，创建对应的 Service Bean 对象</span></span><br /><span class="line">    registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);</span><br /><span class="line">    <span class="comment">// &lt;3&gt; 创建 ReferenceAnnotationBeanPostProcessor Bean 对象，后续扫描 `@Reference` 注解的类，创建对应的 Reference Bean 对象</span></span><br /><span class="line">    registerReferenceAnnotationBeanPostProcessor(registry);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// ... 省略稍后调用的方法。</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>&lt;1&gt;</code>&nbsp;处，调用&nbsp;<code>#getPackagesToScan(AnnotationMetadata metadata)</code>&nbsp;方法，获得要扫描的包。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboComponentScanRegistrar.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">getPackagesToScan</span><span class="params">(AnnotationMetadata metadata)</span> </span>{</span><br /><span class="line">    <span class="comment">// 获得 @DubboComponentScan 注解</span></span><br /><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(DubboComponentScan.class.getName()));</span><br /><span class="line">    <span class="comment">// 获得其上的属性</span></span><br /><span class="line">    String[] basePackages = attributes.getStringArray(<span class="string">"basePackages"</span>);</span><br /><span class="line">    Class&lt;?&gt;[] basePackageClasses = attributes.getClassArray(<span class="string">"basePackageClasses"</span>);</span><br /><span class="line">    String[] value = attributes.getStringArray(<span class="string">"value"</span>);</span><br /><span class="line">    <span class="comment">// Appends value array attributes</span></span><br /><span class="line">    <span class="comment">// 情况一，将属性添加到 packagesToScan 集合中</span></span><br /><span class="line">    Set&lt;String&gt; packagesToScan = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(Arrays.asList(value));</span><br /><span class="line">    packagesToScan.addAll(Arrays.asList(basePackages));</span><br /><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; basePackageClass : basePackageClasses) {</span><br /><span class="line">        packagesToScan.add(ClassUtils.getPackageName(basePackageClass));</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 情况二，如果 packagesToScan 为空，则默认使用注解类所在的包</span></span><br /><span class="line">    <span class="keyword">if</span> (packagesToScan.isEmpty()) {</span><br /><span class="line">        <span class="keyword">return</span> Collections.singleton(ClassUtils.getPackageName(metadata.getClassName()));</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> packagesToScan;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>有两种情况，胖友看的时候，要注意下。</li>
</ul>
</li>
<li>
<p><code>&lt;2&gt;</code>&nbsp;处，调用&nbsp;<code>#registerServiceAnnotationBeanPostProcessor(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</code>&nbsp;方法，创建 ServiceAnnotationBeanPostProcessor Bean 对象，后续扫描&nbsp;<code>@Service</code>&nbsp;注解的类，创建对应的 Service Bean 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboComponentScanRegistrar.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 BeanDefinitionBuilder 对象</span></span><br /><span class="line">    BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);</span><br /><span class="line">    <span class="comment">// 设置构造方法参数为 packagesToScan ，即 BeanDefinitionBuilder 扫描该包</span></span><br /><span class="line">    builder.addConstructorArgValue(packagesToScan);</span><br /><span class="line">    <span class="comment">// 设置 role 属性</span></span><br /><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br /><span class="line">    <span class="comment">// 获得 AbstractBeanDefinition 对象</span></span><br /><span class="line">    AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br /><span class="line">    <span class="comment">// 注册到 registry 中</span></span><br /><span class="line">    BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>关于 ServiceAnnotationBeanPostProcessor 类，我们在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「5.2 ServiceAnnotationBeanPostProcessor」</a>&nbsp;中，详细解析。</li>
</ul>
</li>
<li>
<p><code>&lt;3&gt;</code>&nbsp;处，调用&nbsp;<code>#registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry)</code>&nbsp;方法，创建 ReferenceAnnotationBeanPostProcessor Bean 对象，后续扫描&nbsp;<code>@Reference</code>&nbsp;注解的类，创建对应的 Reference Bean 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DubboComponentScanRegistrar.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerReferenceAnnotationBeanPostProcessor</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    <span class="comment">// Register @Reference Annotation Bean Processor</span></span><br /><span class="line">    BeanRegistrar.registerInfrastructureBean(registry, ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// BeanRegistrar.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerInfrastructureBean</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry,</span></span></span><br /><span class="line"><span class="function"><span class="params">                                              String beanName, Class&lt;?&gt; beanType)</span> </span>{</span><br /><span class="line">    <span class="comment">// 不存在 beanName 对应的 BeanDefinition 对象</span></span><br /><span class="line">    <span class="keyword">if</span> (!beanDefinitionRegistry.containsBeanDefinition(beanName)) {</span><br /><span class="line">        <span class="comment">// 创建 RootBeanDefinition 对象</span></span><br /><span class="line">        RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(beanType);</span><br /><span class="line">        <span class="comment">// 设置 role</span></span><br /><span class="line">        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br /><span class="line">        <span class="comment">// 注册到 beanDefinitionRegistry 中</span></span><br /><span class="line">        beanDefinitionRegistry.registerBeanDefinition(beanName, beanDefinition);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>关于 ReferenceAnnotationBeanPostProcessor 类，我们在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「5.3 ReferenceAnnotationBeanPostProcessor」</a>中，详细解析。</li>
</ul>
</li>
</ul>
<h2 id="5-2-ServiceAnnotationBeanPostProcessor">5.2 ServiceAnnotationBeanPostProcessor</h2>
<p><code>org.apache.dubbo.config.spring.beans.factory.annotation.ServiceAnnotationBeanPostProcessor</code>&nbsp;，实现 BeanDefinitionRegistryPostProcessor、EnvironmentAware、ResourceLoaderAware、BeanClassLoaderAware 接口，扫描&nbsp;<code>@Service</code>&nbsp;注解的类，创建对应的 Spring BeanDefinition 对象，从而创建 Dubbo Service Bean 对象。</p>
<h3 id="5-2-1-构造方法">5.2.1 构造方法</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 要扫描的包的集合</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; packagesToScan;</span><br /><br /><span class="line"><span class="keyword">private</span> Environment environment;</span><br /><br /><span class="line"><span class="keyword">private</span> ResourceLoader resourceLoader;</span><br /><br /><span class="line"><span class="keyword">private</span> ClassLoader classLoader;</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(String... packagesToScan)</span> </span>{ <span class="comment">// 上述文章使用到的构造方法</span></span><br /><span class="line">    <span class="keyword">this</span>(Arrays.asList(packagesToScan));</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(Collection&lt;String&gt; packagesToScan)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> LinkedHashSet&lt;String&gt;(packagesToScan));</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>.packagesToScan = packagesToScan;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="5-2-2-postProcessBeanDefinitionRegistry">5.2.2 postProcessBeanDefinitionRegistry</h3>
<p>实现&nbsp;<code>#postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)</code>&nbsp;方法，扫描&nbsp;<code>@Service</code>&nbsp;注解的类，创建对应的 Spring BeanDefinition 对象，从而创建 Dubbo Service Bean 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>{</span><br /><span class="line">    <span class="comment">// &lt;1&gt; 解析 packagesToScan 集合。因为，可能存在占位符</span></span><br /><span class="line">    Set&lt;String&gt; resolvedPackagesToScan = resolvePackagesToScan(packagesToScan);</span><br /><span class="line">    <span class="comment">// &lt;2&gt; 扫描 packagesToScan 包，创建对应的 Spring BeanDefinition 对象，从而创建 Dubbo Service Bean 对象。</span></span><br /><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(resolvedPackagesToScan)) {</span><br /><span class="line">        registerServiceBeans(resolvedPackagesToScan, registry);</span><br /><span class="line">    } <span class="keyword">else</span> {</span><br /><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br /><span class="line">            logger.warn(<span class="string">"packagesToScan is empty , ServiceBean registry will be ignored!"</span>);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>&lt;1&gt;</code>&nbsp;处，调用&nbsp;<code>#resolvePackagesToScan(Set&lt;String&gt; packagesToScan)</code>&nbsp;方法，解析&nbsp;<code>packagesToScan</code>&nbsp;集合。因为，可能存在占位符。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">resolvePackagesToScan</span><span class="params">(Set&lt;String&gt; packagesToScan)</span> </span>{</span><br /><span class="line">    Set&lt;String&gt; resolvedPackagesToScan = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(packagesToScan.size());</span><br /><span class="line">    <span class="comment">// 遍历 packagesToScan 数组</span></span><br /><span class="line">    <span class="keyword">for</span> (String packageToScan : packagesToScan) {</span><br /><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(packageToScan)) {</span><br /><span class="line">            <span class="comment">// 解析可能存在的占位符</span></span><br /><span class="line">            String resolvedPackageToScan = environment.resolvePlaceholders(packageToScan.trim());</span><br /><span class="line">            <span class="comment">// 添加到 resolvedPackagesToScan 中</span></span><br /><span class="line">            resolvedPackagesToScan.add(resolvedPackageToScan);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> resolvedPackagesToScan;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><code>&lt;2&gt;</code>&nbsp;处，调用&nbsp;<code>#registerServiceBeans(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</code>&nbsp;方法，扫描&nbsp;<code>packagesToScan</code>&nbsp;包，创建对应的 Spring BeanDefinition 对象，从而创建 Dubbo Service Bean 对象。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「5.2.3 resolvePackagesToScan」</a>&nbsp;中。</p>
</li>
</ul>
<h3 id="5-2-3-resolvePackagesToScan">5.2.3 resolvePackagesToScan</h3>
<p><code>#registerServiceBeans(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</code>&nbsp;方法，扫描&nbsp;<code>packagesToScan</code>&nbsp;包，创建对应的 Spring BeanDefinition 对象，从而创建 Dubbo Service Bean 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBeans</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    <span class="comment">// &lt;1.1&gt; 创建 DubboClassPathBeanDefinitionScanner 对象</span></span><br /><span class="line">    DubboClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);</span><br /><span class="line">    <span class="comment">// &lt;1.2&gt; 获得 BeanNameGenerator 对象，并设置 beanNameGenerator 到 scanner 中</span></span><br /><span class="line">    BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);</span><br /><span class="line">    scanner.setBeanNameGenerator(beanNameGenerator);</span><br /><span class="line">    <span class="comment">// &lt;1.3&gt; 设置过滤获得带有 @Service 注解的类</span></span><br /><span class="line">    scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(Service.class));</span><br /><br /><span class="line">    <span class="comment">// &lt;2&gt; 遍历 packagesToScan 数组</span></span><br /><span class="line">    <span class="keyword">for</span> (String packageToScan : packagesToScan) {</span><br /><span class="line">        <span class="comment">// Registers @Service Bean first</span></span><br /><span class="line">        <span class="comment">// &lt;2.1&gt; 执行扫描</span></span><br /><span class="line">        scanner.scan(packageToScan);</span><br /><span class="line">        <span class="comment">// Finds all BeanDefinitionHolders of @Service whether @ComponentScan scans or not.</span></span><br /><span class="line">        <span class="comment">// &lt;2.2&gt; 创建每个在 packageToScan 扫描到的类，对应的 BeanDefinitionHolder 对象，返回 BeanDefinitionHolder 集合</span></span><br /><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders = findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);</span><br /><span class="line">        <span class="comment">// &lt;2.3&gt; 注册到 registry 中</span></span><br /><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) {</span><br /><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) {</span><br /><span class="line">                registerServiceBean(beanDefinitionHolder, registry, scanner);</span><br /><span class="line">            }</span><br /><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line">                logger.info(beanDefinitionHolders.size() + <span class="string">" annotated Dubbo's @Service Components { "</span> + beanDefinitionHolders + <span class="string">" } were scanned under package["</span> + packageToScan + <span class="string">"]"</span>);</span><br /><span class="line">            }</span><br /><span class="line">        } <span class="keyword">else</span> {</span><br /><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br /><span class="line">                logger.warn(<span class="string">"No Spring Bean annotating Dubbo's @Service was found under package["</span> + packageToScan + <span class="string">"]"</span>);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>&lt;1.1&gt;</code>&nbsp;处，创建 DubboClassPathBeanDefinitionScanner 对象。它是用于扫描指定包下符合条件的类，用于将每个符合条件的类，创建对应的 BeanDefinition 对象，从而创建 Bean 。关于 DubboClassPathBeanDefinitionScanner 类，胖友点击&nbsp;<a href="https://github.com/apache/incubator-dubbo/blob/master/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ServiceAnnotationBeanPostProcessor.java" target="_blank" rel="external nofollow noopener noreferrer">链接</a>&nbsp;瞅一眼即可。</li>
<li>
<p><code>&lt;1.2&gt;</code>&nbsp;处，调用&nbsp;<code>#resolveBeanNameGenerator(BeanDefinitionRegistry registry)</code>&nbsp;方法，获得 BeanNameGenerator 对象，并设置&nbsp;<code>beanNameGenerator</code>&nbsp;到&nbsp;<code>scanner</code>&nbsp;中。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * It'd better to use BeanNameGenerator instance that should reference</span></span><br /><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ConfigurationClassPostProcessor#componentScanBeanNameGenerator},</span></span><br /><span class="line"><span class="comment"> * thus it maybe a potential problem on bean name generation.</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry {<span class="doctag">@link</span> BeanDefinitionRegistry}</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@link</span> BeanNameGenerator} instance</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> SingletonBeanRegistry</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotationConfigUtils#CONFIGURATION_BEAN_NAME_GENERATOR</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationClassPostProcessor#processConfigBeanDefinitions</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"><span class="function"><span class="keyword">private</span> BeanNameGenerator <span class="title">resolveBeanNameGenerator</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>{</span><br /><span class="line">    BeanNameGenerator beanNameGenerator = <span class="keyword">null</span>;</span><br /><span class="line">    <span class="comment">// 如果是 SingletonBeanRegistry 类型，从中获得对应的 BeanNameGenerator Bean 对象</span></span><br /><span class="line">    <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) {</span><br /><span class="line">        SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry.class.cast(registry);</span><br /><span class="line">        beanNameGenerator = (BeanNameGenerator) singletonBeanRegistry.getSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 如果不存在，则创建 AnnotationBeanNameGenerator 对象</span></span><br /><span class="line">    <span class="keyword">if</span> (beanNameGenerator == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line">            logger.info(<span class="string">"BeanNameGenerator bean can't be found in BeanFactory with name ["</span> + CONFIGURATION_BEAN_NAME_GENERATOR + <span class="string">"]"</span>);</span><br /><span class="line">            logger.info(<span class="string">"BeanNameGenerator will be a instance of "</span> + AnnotationBeanNameGenerator.class.getName() + <span class="string">" , it maybe a potential problem on bean name generation."</span>);</span><br /><span class="line">        }</span><br /><span class="line">        beanNameGenerator = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> beanNameGenerator;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><code>&lt;1.3&gt;</code>&nbsp;处，设置过滤获得带有&nbsp;<code>@Service</code>&nbsp;注解的类。关于&nbsp;<code>@Service</code>&nbsp;注解的具体的属性，本文就不过分介绍，胖友自己瞅瞅。</p>
</li>
<li><code>&lt;2&gt;</code>&nbsp;处，遍历&nbsp;<code>packagesToScan</code>&nbsp;数组。
<ul>
<li><code>&lt;2.1&gt;</code>&nbsp;处，调用&nbsp;<code>DubboClassPathBeanDefinitionScanner#scan(String... basePackages)</code>&nbsp;方法，执行扫描。</li>
<li><code>&lt;2.2&gt;</code>&nbsp;处，调用&nbsp;<code>#findServiceBeanDefinitionHolders(ClassPathBeanDefinitionScanner scanner, String packageToScan, BeanDefinitionRegistry registry, BeanNameGenerator beanNameGenerator)</code>&nbsp;方法，创建每个在&nbsp;<code>packageToScan</code>&nbsp;扫描到的类，对应的 BeanDefinitionHolder 对象，返回 BeanDefinitionHolder 集合。详细解析 ，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「5.2.4 findServiceBeanDefinitionHolders」</a>&nbsp;中。</li>
<li><code>&lt;2.3&gt;</code>&nbsp;处，调用&nbsp;<code>#registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry, DubboClassPathBeanDefinitionScanner scanner)</code>&nbsp;方法，注册到&nbsp;<code>registry</code>&nbsp;中。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「5.2.5 registerServiceBean」</a>&nbsp;中。</li>
</ul>
</li>
</ul>
<h3 id="5-2-4-findServiceBeanDefinitionHolders">5.2.4 findServiceBeanDefinitionHolders</h3>
<p><code>#findServiceBeanDefinitionHolders(ClassPathBeanDefinitionScanner scanner, String packageToScan, BeanDefinitionRegistry registry, BeanNameGenerator beanNameGenerator)</code>&nbsp;方法，创建每个在&nbsp;<code>packageToScan</code>&nbsp;扫描到的类，对应的 BeanDefinitionHolder 对象，返回 BeanDefinitionHolder 集合。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Finds a {<span class="doctag">@link</span> Set} of {<span class="doctag">@link</span> BeanDefinitionHolder BeanDefinitionHolders} whose bean type annotated</span></span><br /><span class="line"><span class="comment"> * {<span class="doctag">@link</span> Service} Annotation.</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> scanner       {<span class="doctag">@link</span> ClassPathBeanDefinitionScanner}</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageToScan pachage to scan</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry      {<span class="doctag">@link</span> BeanDefinitionRegistry}</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> non-null</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">findServiceBeanDefinitionHolders</span><span class="params">(</span></span></span><br /><span class="line"><span class="function"><span class="params">        ClassPathBeanDefinitionScanner scanner, String packageToScan, BeanDefinitionRegistry registry,</span></span></span><br /><span class="line"><span class="function"><span class="params">        BeanNameGenerator beanNameGenerator)</span> </span>{</span><br /><span class="line">    <span class="comment">// 获得 packageToScan 包下符合条件的 BeanDefinition 集合</span></span><br /><span class="line">    Set&lt;BeanDefinition&gt; beanDefinitions = scanner.findCandidateComponents(packageToScan);</span><br /><br /><span class="line">    <span class="comment">// 创建 BeanDefinitionHolder 集合</span></span><br /><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(beanDefinitions.size());</span><br /><span class="line">    <span class="comment">// 遍历 beanDefinitions 数组</span></span><br /><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitions) {</span><br /><span class="line">        <span class="comment">// 获得 Bean 的名字</span></span><br /><span class="line">        String beanName = beanNameGenerator.generateBeanName(beanDefinition, registry);</span><br /><span class="line">        <span class="comment">// 创建 BeanDefinitionHolder 对象</span></span><br /><span class="line">        BeanDefinitionHolder beanDefinitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName);</span><br /><span class="line">        <span class="comment">// 添加到 beanDefinitions 中</span></span><br /><span class="line">        beanDefinitionHolders.add(beanDefinitionHolder);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> beanDefinitionHolders;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="5-2-5-registerServiceBean">5.2.5 registerServiceBean</h3>
<p><code>#registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry, DubboClassPathBeanDefinitionScanner scanner)</code>&nbsp;方法，注册到&nbsp;<code>registry</code>&nbsp;中。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Registers {<span class="doctag">@link</span> ServiceBean} from new annotated {<span class="doctag">@link</span> Service} {<span class="doctag">@link</span> BeanDefinition}</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDefinitionHolder</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> scanner</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> ServiceBean</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanDefinition</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBean</span><span class="params">(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,</span></span></span><br /><span class="line"><span class="function"><span class="params">                                 DubboClassPathBeanDefinitionScanner scanner)</span> </span>{</span><br /><span class="line">    <span class="comment">// &lt;1.1&gt; 解析 Bean 的类</span></span><br /><span class="line">    Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder);</span><br /><span class="line">    <span class="comment">// &lt;1.2&gt; 获得 @Service 注解</span></span><br /><span class="line">    Service service = AnnotationUtils.findAnnotation(beanClass, Service.class);</span><br /><span class="line">    <span class="comment">// &lt;1.3&gt; 获得 Service 接口</span></span><br /><span class="line">    Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(beanClass, service);</span><br /><span class="line">    <span class="comment">// &lt;1.4&gt; 获得 Bean 的名字</span></span><br /><span class="line">    String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();</span><br /><span class="line">    <span class="comment">// &lt;1.5&gt; 创建 AbstractBeanDefinition 对象</span></span><br /><span class="line">    AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);</span><br /><br /><span class="line">    <span class="comment">// ServiceBean Bean name</span></span><br /><span class="line">    <span class="comment">// &lt;2&gt; 重新生成 Bean 的名字</span></span><br /><span class="line">    String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);</span><br /><span class="line">    <span class="comment">// &lt;3&gt; 校验在 scanner 中，已经存在 beanName 。若不存在，则进行注册。</span></span><br /><span class="line">    <span class="keyword">if</span> (scanner.checkCandidate(beanName, serviceBeanDefinition)) { <span class="comment">// check duplicated candidate bean</span></span><br /><span class="line">        registry.registerBeanDefinition(beanName, serviceBeanDefinition);</span><br /><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line">            logger.info(<span class="string">"The BeanDefinition["</span> + serviceBeanDefinition + <span class="string">"] of ServiceBean has been registered with name : "</span> + beanName);</span><br /><span class="line">        }</span><br /><span class="line">    } <span class="keyword">else</span> {</span><br /><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br /><span class="line">            logger.warn(<span class="string">"The Duplicated BeanDefinition["</span> + serviceBeanDefinition + <span class="string">"] of ServiceBean[ bean name : "</span> + beanName + <span class="string">"] was be found , Did @DubboComponentScan scan to same package in many times?"</span>);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>&lt;1.1&gt;</code>&nbsp;处，调用&nbsp;<code>#resolveClass(BeanDefinitionHolder beanDefinitionHolder)</code>&nbsp;方法，解析返回 Bean 的类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="keyword">private</span> Class&lt;?&gt; resolveClass(BeanDefinitionHolder beanDefinitionHolder) {</span><br /><span class="line">    BeanDefinition beanDefinition = beanDefinitionHolder.getBeanDefinition();</span><br /><span class="line">    <span class="keyword">return</span> resolveClass(beanDefinition);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="keyword">private</span> Class&lt;?&gt; resolveClass(BeanDefinition beanDefinition) {</span><br /><span class="line">    String beanClassName = beanDefinition.getBeanClassName();</span><br /><span class="line">    <span class="keyword">return</span> ClassUtils.resolveClassName(beanClassName, classLoader);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>因为 BeanDefinition 的&nbsp;<code>beanClassName</code>&nbsp;是 String 类型，所以得转换成 Class 类型。</li>
</ul>
</li>
<li>
<p><code>&lt;1.2&gt;</code>&nbsp;处，获得&nbsp;<code>@Service</code>&nbsp;注解。</p>
</li>
<li>
<p><code>&lt;1.3&gt;</code>&nbsp;处，调用&nbsp;<code>#resolveServiceInterfaceClass(Class&lt;?&gt; annotatedServiceBeanClass, Service service)</code>&nbsp;方法，获得 Service 接口。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"><span class="keyword">private</span> Class&lt;?&gt; resolveServiceInterfaceClass(Class&lt;?&gt; annotatedServiceBeanClass, Service service) {</span><br /><span class="line">    <span class="comment">// 首先，从注解本身上获得</span></span><br /><span class="line">    Class&lt;?&gt; interfaceClass = service.interfaceClass();</span><br /><span class="line">    <span class="keyword">if</span> (<span class="keyword">void</span>.class.equals(interfaceClass)) { <span class="comment">// 一般是满足的</span></span><br /><span class="line">        interfaceClass = <span class="keyword">null</span>;</span><br /><span class="line">        <span class="comment">// 获得 @Service 注解的 interfaceName 属性。</span></span><br /><span class="line">        String interfaceClassName = service.interfaceName();</span><br /><span class="line">        <span class="comment">// 如果存在，获得其对应的类</span></span><br /><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(interfaceClassName)) {</span><br /><span class="line">            <span class="keyword">if</span> (ClassUtils.isPresent(interfaceClassName, classLoader)) {</span><br /><span class="line">                interfaceClass = ClassUtils.resolveClassName(interfaceClassName, classLoader);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">// &lt;X&gt;【一般情况下，使用这个】获得不到，则从被注解的类上获得其实现的首个接口</span></span><br /><span class="line">    <span class="keyword">if</span> (interfaceClass == <span class="keyword">null</span>) {</span><br /><span class="line">        Class&lt;?&gt;[] allInterfaces = annotatedServiceBeanClass.getInterfaces();</span><br /><span class="line">        <span class="keyword">if</span> (allInterfaces.length &gt; <span class="number">0</span>) {</span><br /><span class="line">            interfaceClass = allInterfaces[<span class="number">0</span>];</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">    Assert.notNull(interfaceClass, <span class="string">"@Service interfaceClass() or interfaceName() or interface class must be present!"</span>);</span><br /><span class="line">    Assert.isTrue(interfaceClass.isInterface(), <span class="string">"The type that was annotated @Service is not an interface!"</span>);</span><br /><span class="line">    <span class="keyword">return</span> interfaceClass;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>虽然代码比较长，但是重点看&nbsp;<code>&lt;X&gt;</code>&nbsp;处，从被注解的类上获得其实现的首个接口。</li>
</ul>
</li>
<li>
<p><code>&lt;1.4&gt;</code>&nbsp;处，获得 Bean 的名字。</p>
</li>
<li>
<p><code>&lt;1.5&gt;</code>&nbsp;处，调用&nbsp;<code>#buildServiceBeanDefinition(Service service, Class&lt;?&gt; interfaceClass, String annotatedServiceBeanName)</code>&nbsp;方法，创建 AbstractBeanDefinition 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"><span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">buildServiceBeanDefinition</span><span class="params">(Service service, Class&lt;?&gt; interfaceClass, String annotatedServiceBeanName)</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 BeanDefinitionBuilder 对象</span></span><br /><span class="line">    BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceBean.class);</span><br /><span class="line">    <span class="comment">// 获得 AbstractBeanDefinition 对象</span></span><br /><span class="line">    AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br /><br /><span class="line">    <span class="comment">// 获得 MutablePropertyValues 属性。后续 ，通过向它添加属性，设置到 BeanDefinition 中，即 Service Bean 中。</span></span><br /><span class="line">    MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();</span><br /><br /><span class="line">    <span class="comment">// &lt;X&gt; 创建 AnnotationPropertyValuesAdapter 对象，添加到 propertyValues 中。</span></span><br /><span class="line">    <span class="comment">// 此处，是将注解上的属性，设置到 propertyValues 中</span></span><br /><span class="line">    String[] ignoreAttributeNames = of(<span class="string">"provider"</span>, <span class="string">"monitor"</span>, <span class="string">"application"</span>, <span class="string">"module"</span>, <span class="string">"registry"</span>, <span class="string">"protocol"</span>, <span class="string">"interface"</span>, <span class="string">"interfaceName"</span>); <span class="comment">// 忽略的属性，下面进行单独设置。</span></span><br /><span class="line">    propertyValues.addPropertyValues(<span class="keyword">new</span> AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));</span><br /><br /><span class="line">    <span class="comment">// References "ref" property to annotated-@Service Bean</span></span><br /><span class="line">    <span class="comment">// 设置 ref 属性指向的 Service Bean 名字</span></span><br /><span class="line">    addPropertyReference(builder, <span class="string">"ref"</span>, annotatedServiceBeanName);</span><br /><span class="line">    <span class="comment">// Set interface 设置 Service 接口类全类名</span></span><br /><span class="line">    builder.addPropertyValue(<span class="string">"interface"</span>, interfaceClass.getName());</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Add {<span class="doctag">@link</span> org.apache.dubbo.config.ProviderConfig} Bean reference</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 添加 provider 属性对应的 ProviderConfig Bean 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String providerConfigBeanName = service.provider();</span><br /><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(providerConfigBeanName)) {</span><br /><span class="line">        addPropertyReference(builder, <span class="string">"provider"</span>, providerConfigBeanName);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Add {<span class="doctag">@link</span> org.apache.dubbo.config.MonitorConfig} Bean reference</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 添加 monitor 属性对应的 MonitorConfig Bean 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String monitorConfigBeanName = service.monitor();</span><br /><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(monitorConfigBeanName)) {</span><br /><span class="line">        addPropertyReference(builder, <span class="string">"monitor"</span>, monitorConfigBeanName);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Add {<span class="doctag">@link</span> org.apache.dubbo.config.ApplicationConfig} Bean reference</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 添加 application 属性对应的 ApplicationConfig Bean 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String applicationConfigBeanName = service.application();</span><br /><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(applicationConfigBeanName)) {</span><br /><span class="line">        addPropertyReference(builder, <span class="string">"application"</span>, applicationConfigBeanName);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Add {<span class="doctag">@link</span> org.apache.dubbo.config.ModuleConfig} Bean reference</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 添加 module 属性对应的 ModuleConfig Bean 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String moduleConfigBeanName = service.<span class="keyword">module</span>();</span><br /><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(moduleConfigBeanName)) {</span><br /><span class="line">        addPropertyReference(builder, <span class="string">"module"</span>, moduleConfigBeanName);</span><br /><span class="line">    }</span><br /><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Add {<span class="doctag">@link</span> org.apache.dubbo.config.RegistryConfig} Bean reference</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 添加 registries 属性对应的 RegistryConfig Bean 数组（一个或多个）</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String[] registryConfigBeanNames = service.registry();</span><br /><span class="line">    List&lt;RuntimeBeanReference&gt; registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames);</span><br /><span class="line">    <span class="keyword">if</span> (!registryRuntimeBeanReferences.isEmpty()) {</span><br /><span class="line">        builder.addPropertyValue(<span class="string">"registries"</span>, registryRuntimeBeanReferences);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Add {<span class="doctag">@link</span> org.apache.dubbo.config.ProtocolConfig} Bean reference</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 添加 protocols 属性对应的 ProtocolConfig Bean 数组（一个或多个）</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String[] protocolConfigBeanNames = service.protocol();</span><br /><span class="line">    List&lt;RuntimeBeanReference&gt; protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames);</span><br /><span class="line">    <span class="keyword">if</span> (!protocolRuntimeBeanReferences.isEmpty()) {</span><br /><span class="line">        builder.addPropertyValue(<span class="string">"protocols"</span>, protocolRuntimeBeanReferences);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="keyword">return</span> builder.getBeanDefinition();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// RuntimeBeanReference ，在解析到依赖的Bean的时侯，解析器会依据依赖bean的name创建一个RuntimeBeanReference对像，将这个对像放入BeanDefinition的MutablePropertyValues中。</span></span><br /><span class="line"><span class="comment">// 此处，和上面不太一样的原因，因为是多个</span></span><br /><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"><span class="function"><span class="keyword">private</span> ManagedList&lt;RuntimeBeanReference&gt; <span class="title">toRuntimeBeanReferences</span><span class="params">(String... beanNames)</span> </span>{</span><br /><span class="line">    ManagedList&lt;RuntimeBeanReference&gt; runtimeBeanReferences = <span class="keyword">new</span> ManagedList&lt;RuntimeBeanReference&gt;();</span><br /><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(beanNames)) {</span><br /><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) {</span><br /><span class="line">            <span class="comment">// 解析真正的 Bean 名字，如果有占位符的话</span></span><br /><span class="line">            String resolvedBeanName = environment.resolvePlaceholders(beanName);</span><br /><span class="line">            runtimeBeanReferences.add(<span class="keyword">new</span> RuntimeBeanReference(resolvedBeanName));</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> runtimeBeanReferences;</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// 添加属性值是引用类型</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPropertyReference</span><span class="params">(BeanDefinitionBuilder builder, String propertyName, String beanName)</span> </span>{</span><br /><span class="line">    String resolvedBeanName = environment.resolvePlaceholders(beanName);</span><br /><span class="line">    builder.addPropertyReference(propertyName, resolvedBeanName);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>比较冗长，顺着往下看即可。</li>
<li><code>&lt;X&gt;</code>&nbsp;处，创建 AnnotationPropertyValuesAdapter 对象，添加到&nbsp;<code>propertyValues</code>&nbsp;中。此处，是将注解上的属性，设置到&nbsp;<code>propertyValues</code>&nbsp;中。也就是说，注解上的属性，自然的能够设置到后续创建的 Service Bean 的对象中。
<ul>
<li>举个例子，如果说&nbsp;<code>@Service(version="1.0.0")</code>&nbsp;，那么这个版本号（<code>version</code>），就可以设置到 Dubbo Service Bean 中去了。</li>
<li>关于&nbsp;<code>org.apache.dubbo.config.spring.beans.factory.annotation.AnnotationPropertyValuesAdapter</code>&nbsp;类，就是上述的用途，比较简单，胖友点击&nbsp;<a href="https://github.com/apache/incubator-dubbo/blob/ff0ce37c46523e9d0dfa13748fca339e68edc027/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/AnnotationPropertyValuesAdapter.java" target="_blank" rel="external nofollow noopener noreferrer">链接</a>&nbsp;查看即可。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>&lt;2&gt;</code>&nbsp;处，调用&nbsp;<code>#generateServiceBeanName(Service service, Class&lt;?&gt; interfaceClass, String annotatedServiceBeanName)</code>&nbsp;方法，重新生成 Bean 的名字。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateServiceBeanName</span><span class="params">(Service service, Class&lt;?&gt; interfaceClass, String annotatedServiceBeanName)</span> </span>{</span><br /><span class="line">    ServiceBeanNameBuilder builder = ServiceBeanNameBuilder.create(service, interfaceClass, environment);</span><br /><span class="line">    <span class="keyword">return</span> builder.build();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// ServiceBeanNameBuilder.java</span></span><br /><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SEPARATOR = <span class="string">":"</span>;</span><br /><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String interfaceClassName;</span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Environment environment;</span><br /><span class="line"><span class="comment">// Optional</span></span><br /><span class="line"><span class="keyword">private</span> String version;</span><br /><span class="line"><span class="keyword">private</span> String group;</span><br /><br /><span class="line"><span class="comment">// ServiceBean:${interfaceClassName}:${version}:${group}</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">build</span><span class="params">()</span> </span>{</span><br /><span class="line">    StringBuilder beanNameBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"ServiceBean"</span>);</span><br /><span class="line">    <span class="comment">// Required</span></span><br /><span class="line">    append(beanNameBuilder, interfaceClassName);</span><br /><span class="line">    <span class="comment">// Optional</span></span><br /><span class="line">    append(beanNameBuilder, version);</span><br /><span class="line">    append(beanNameBuilder, group);</span><br /><span class="line">    <span class="comment">// Build</span></span><br /><span class="line">    String rawBeanName = beanNameBuilder.toString();</span><br /><span class="line">    <span class="comment">// Resolve placeholders</span></span><br /><span class="line">    <span class="keyword">return</span> environment.resolvePlaceholders(rawBeanName);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(StringBuilder builder, String value)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(value)) {</span><br /><span class="line">        builder.append(SEPARATOR).append(value);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>结果示例如下：<img src="http://static2.iocoder.cn/images/Dubbo/2018_01_22/02.jpg" alt="&#96;beanName&#96;" /></li>
</ul>
</li>
<li>
<p><code>&lt;3&gt;</code>&nbsp;处，校验在&nbsp;<code>scanner</code>&nbsp;中，是否已经存在&nbsp;<code>beanName</code>&nbsp;。若不存在，则进行注册。</p>
</li>
</ul>
<p>😈 整个逻辑，有点长长滴。胖友辛苦上下滑动，在瞅瞅。</p>
<h2 id="5-3-ReferenceAnnotationBeanPostProcessor">5.3 ReferenceAnnotationBeanPostProcessor</h2>
<p><code>org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor</code>&nbsp;，继承 AnnotationInjectedBeanPostProcessor 抽象类，实现 ApplicationContextAware、ApplicationListener 接口，扫描&nbsp;<code>@Reference</code>&nbsp;注解的类，创建对应的 Spring BeanDefinition 对象，从而创建 Dubbo Reference Bean 对象。</p>
<blockquote>
<p>虽然&nbsp;<code>org.apache.dubbo.config.spring.beans.factory.annotation.AnnotationInjectedBeanPostProcessor</code>&nbsp;放在 Dubbo 项目中，但是是 clone 自&nbsp;<a href="https://github.com/alibaba/spring-context-support/blob/1.0.2/src/main/java/com/alibaba/spring/beans/factory/annotation/AnnotationInjectedBeanPostProcessor.java" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/alibaba/spring-context-support/blob/1.0.2/src/main/java/com/alibaba/spring/beans/factory/annotation/AnnotationInjectedBeanPostProcessor.java</a>类。所以呢，我们先不深究这个类，只要知道如下：</p>
<ul>
<li>英文：Abstract generic {@link BeanPostProcessor} implementation for customized annotation that annotated injected-object.</li>
<li>中文：BeanPostProcessor 的抽象实现类，用于支持使用自定义注解，注入对象的属性。</li>
</ul>
</blockquote>
<ul>
<li>此时，ReferenceAnnotationBeanPostProcessor 实现的就是 支持&nbsp;<code>@Reference</code>&nbsp;注解的属性注入。</li>
</ul>
<blockquote>
<p>相对来说，本节的 ReferenceAnnotationBeanPostProcessor ，会比上一节的 ServiceAnnotationBeanPostProcessor 复杂蛮多~ SO ，保持耐心哈。</p>
</blockquote>
<h3 id="5-3-1-构造方法">5.3.1 构造方法</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ReferenceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * The bean name of {<span class="doctag">@link</span> ReferenceAnnotationBeanPostProcessor}</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"referenceAnnotationBeanPostProcessor"</span>;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Cache size</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE = Integer.getInteger(BEAN_NAME + <span class="string">".cache.size"</span>, <span class="number">32</span>);</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * ReferenceBean 缓存 Map</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * KEY：Reference Bean 的名字</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ReferenceBean&lt;?&gt;&gt; referenceBeanCache = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE);</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * ReferenceBeanInvocationHandler 缓存 Map</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * KEY：Reference Bean 的名字</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt; localReferenceBeanInvocationHandlerCache = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt;(CACHE_SIZE);</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 使用属性进行注入的 <span class="doctag">@Reference</span> Bean 的缓存 Map</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 一般情况下，使用这个</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedFieldReferenceBeanCache = <span class="keyword">new</span> ConcurrentHashMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE);</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 使用方法进行注入的 <span class="doctag">@Reference</span> Bean 的缓存 Map</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedMethodReferenceBeanCache = <span class="keyword">new</span> ConcurrentHashMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE);</span><br /><br /><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>具体的每个变量的时候，结合下面来看。</li>
</ul>
<h3 id="5-3-2-doGetInjectedBean">5.3.2 doGetInjectedBean</h3>
<p>实现&nbsp;<code>#doGetInjectedBean(Reference reference, Object bean, String beanName, Class&lt;?&gt; injectedType, InjectionMetadata.InjectedElement injectedElement)</code>&nbsp;方法，获得要注入的&nbsp;<code>@Reference</code>&nbsp;Bean 。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ReferenceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetInjectedBean</span><span class="params">(Reference reference, Object bean, String beanName, Class&lt;?&gt; injectedType,</span></span></span><br /><span class="line"><span class="function"><span class="params">                                   InjectionMetadata.InjectedElement injectedElement)</span> <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line">    <span class="comment">// &lt;1&gt; 获得 Reference Bean 的名字</span></span><br /><span class="line">    String referencedBeanName = buildReferencedBeanName(reference, injectedType);</span><br /><span class="line">    <span class="comment">// &lt;2&gt; 创建 ReferenceBean 对象</span></span><br /><span class="line">    ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referencedBeanName, reference, injectedType, getClassLoader());</span><br /><span class="line">    <span class="comment">// &lt;3&gt; 缓存到 injectedFieldReferenceBeanCache or injectedMethodReferenceBeanCache 中</span></span><br /><span class="line">    cacheInjectedReferenceBean(referenceBean, injectedElement);</span><br /><span class="line">    <span class="comment">// &lt;4&gt; 创建 Proxy 代理对象</span></span><br /><span class="line">    <span class="keyword">return</span> buildProxy(referencedBeanName, referenceBean, injectedType);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>&lt;1&gt;</code>&nbsp;处，调用&nbsp;<code>#buildReferencedBeanName(Reference reference, Class&lt;?&gt; injectedType)</code>&nbsp;方法，获得 Reference Bean 的名字。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ReferenceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">buildReferencedBeanName</span><span class="params">(Reference reference, Class&lt;?&gt; injectedType)</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 Service Bean 的名字</span></span><br /><span class="line">    ServiceBeanNameBuilder builder = ServiceBeanNameBuilder.create(reference, injectedType, getEnvironment());</span><br /><span class="line">    <span class="keyword">return</span> getEnvironment().resolvePlaceholders(builder.build()); <span class="comment">// 这里，貌似重复解析占位符了。不过没啥影响~</span></span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>实际上，使用的就是 ServiceBeanNameBuilder 的逻辑，即和 Dubbo Service Bean 的名字，是 同一套。当然，这个也非常合理~</li>
</ul>
</li>
<li>
<p><code>&lt;2&gt;</code>&nbsp;处，调用&nbsp;<code>#buildReferenceBeanIfAbsent(String referencedBeanName, Reference reference, Class&lt;?&gt; referencedType, ClassLoader classLoader)</code>&nbsp;方法，创建（获得） ReferenceBean 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ReferenceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> ReferenceBean <span class="title">buildReferenceBeanIfAbsent</span><span class="params">(String referencedBeanName, Reference reference, Class&lt;?&gt; referencedType, ClassLoader classLoader)</span></span></span><br /><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line">    <span class="comment">// 首先，从 referenceBeanCache 缓存中，获得 referencedBeanName 对应的 ReferenceBean 对象</span></span><br /><span class="line">    ReferenceBean&lt;?&gt; referenceBean = referenceBeanCache.get(referencedBeanName);</span><br /><span class="line">    <span class="comment">// 然后，如果不存在，则进行创建。然后，添加到 referenceBeanCache 缓存中。</span></span><br /><span class="line">    <span class="keyword">if</span> (referenceBean == <span class="keyword">null</span>) {</span><br /><span class="line">        ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder</span><br /><span class="line">                .create(reference, classLoader, applicationContext)</span><br /><span class="line">                .interfaceClass(referencedType);</span><br /><span class="line">        referenceBean = beanBuilder.build();</span><br /><span class="line">        referenceBeanCache.put(referencedBeanName, referenceBean);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> referenceBean;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>其中，会使用 ReferenceBeanBuilder 类，构建 ReferenceBean 对象。关于它，我们稍后在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「5.3.4 ReferenceBeanBuilder」</a>&nbsp;来瞅瞅。实际上，和上面 ServiceBean 的构建，也差不了太多。</li>
</ul>
</li>
<li>
<p><code>&lt;3&gt;</code>&nbsp;处，调用&nbsp;<code>#cacheInjectedReferenceBean(String referencedBeanName, Reference reference, Class&lt;?&gt; referencedType, ClassLoader classLoader)</code>&nbsp;方法，缓存到&nbsp;<code>injectedFieldReferenceBeanCache</code>&nbsp;or&nbsp;<code>injectedMethodReferenceBeanCache</code>&nbsp;中。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ReferenceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheInjectedReferenceBean</span><span class="params">(ReferenceBean referenceBean, InjectionMetadata.InjectedElement injectedElement)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (injectedElement.getMember() <span class="keyword">instanceof</span> Field) {</span><br /><span class="line">        injectedFieldReferenceBeanCache.put(injectedElement, referenceBean);</span><br /><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (injectedElement.getMember() <span class="keyword">instanceof</span> Method) {</span><br /><span class="line">        injectedMethodReferenceBeanCache.put(injectedElement, referenceBean);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><code>&lt;4&gt;</code>&nbsp;处，调用&nbsp;<code>#buildProxy(String referencedBeanName, ReferenceBean referenceBean, Class&lt;?&gt; injectedType)</code>&nbsp;方法，创建 Proxy 代理对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ReferenceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">buildProxy</span><span class="params">(String referencedBeanName, ReferenceBean referenceBean, Class&lt;?&gt; injectedType)</span> </span>{</span><br /><span class="line">    InvocationHandler handler = buildInvocationHandler(referencedBeanName, referenceBean);</span><br /><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(getClassLoader(), <span class="keyword">new</span> Class[]{injectedType}, handler);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> InvocationHandler <span class="title">buildInvocationHandler</span><span class="params">(String referencedBeanName, ReferenceBean referenceBean)</span> </span>{</span><br /><span class="line">    <span class="comment">// 首先，从 localReferenceBeanInvocationHandlerCache 缓存中，获得 ReferenceBeanInvocationHandler 对象</span></span><br /><span class="line">    ReferenceBeanInvocationHandler handler = localReferenceBeanInvocationHandlerCache.get(referencedBeanName);</span><br /><span class="line">    <span class="comment">// 然后，如果不存在，则创建 ReferenceBeanInvocationHandler 对象</span></span><br /><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) {</span><br /><span class="line">        handler = <span class="keyword">new</span> ReferenceBeanInvocationHandler(referenceBean);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">// &lt;X&gt; 之后，根据引用的 Dubbo 服务是远程的还是本地的，做不同的处理。</span></span><br /><span class="line">    <span class="comment">// 【本地】判断如果 applicationContext 中已经初始化，说明是本地的 @Service Bean ，则添加到 localReferenceBeanInvocationHandlerCache 缓存中。</span></span><br /><span class="line">    <span class="comment">// 等到本地的 @Service Bean 暴露后，再进行初始化。</span></span><br /><span class="line">    <span class="keyword">if</span> (applicationContext.containsBean(referencedBeanName)) { <span class="comment">// Is local @Service Bean or not ?</span></span><br /><span class="line">        <span class="comment">// ReferenceBeanInvocationHandler's initialization has to wait for current local @Service Bean has been exported.</span></span><br /><span class="line">        localReferenceBeanInvocationHandlerCache.put(referencedBeanName, handler);</span><br /><span class="line">    <span class="comment">// 【远程】判断若果 applicationContext 中未初始化，说明是远程的 @Service Bean 对象，则立即进行初始化</span></span><br /><span class="line">    } <span class="keyword">else</span> {</span><br /><span class="line">        <span class="comment">// Remote Reference Bean should initialize immediately</span></span><br /><span class="line">        handler.init();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> handler;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>比较复杂的是，<code>&lt;X&gt;</code>&nbsp;处，根据引用的 Dubbo 服务是远程的还是本地的，做不同的处理。为什么呢？
<ul>
<li>远程的 Dubbo 服务，理论来说（不考虑对方挂掉的情况），是已经存在，此时可以进行加载引用。</li>
<li>本地的 Dubbo 服务，此时并未暴露，则先添加到&nbsp;<code>localReferenceBeanInvocationHandlerCache</code>&nbsp;中进行缓存。等后续的，通过 Spring 事件监听的功能，进行实现。详细的，我们在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「5.3.3 onApplicationEvent」</a>中会看到。</li>
</ul>
</li>
<li>
<p>ReferenceBeanInvocationHandler ，是 ReferenceAnnotationBeanPostProcessor 的内部静态类，实现 Dubbo InvocationHandler 接口，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ReferenceAnnotationBeanPostProcessor#ReferenceBeanInvocationHandler.java</span></span><br /><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * ReferenceBean 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReferenceBean referenceBean;</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Bean 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> Object bean;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ReferenceBeanInvocationHandler</span><span class="params">(ReferenceBean referenceBean)</span> </span>{</span><br /><span class="line">        <span class="keyword">this</span>.referenceBean = referenceBean;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br /><span class="line">        <span class="comment">// 调用 bean 的对应的方法</span></span><br /><span class="line">        <span class="keyword">return</span> method.invoke(bean, args);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">// 通过初始化方法，可以获得 `ReferenceBean.ref`</span></span><br /><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">this</span>.bean = referenceBean.get();</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>重心在于&nbsp;<code>#init()</code>&nbsp;方法，可以调用&nbsp;<code>ReferenceBean#get()</code>&nbsp;方法，进行引用的 Bean 的初始化，最后返回引用&nbsp;<code>ref</code>&nbsp;。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-3-3-onApplicationEvent">5.3.3 onApplicationEvent</h3>
<p>实现&nbsp;<code>#onApplicationEvent(ApplicationEvent event)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ReferenceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ServiceBeanExportedEvent) {</span><br /><span class="line">        onServiceBeanExportEvent((ServiceBeanExportedEvent) event);</span><br /><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) {</span><br /><span class="line">        onContextRefreshedEvent((ContextRefreshedEvent) event);</span><br /><span class="line">    }</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onServiceBeanExportEvent</span><span class="params">(ServiceBeanExportedEvent event)</span> </span>{</span><br /><span class="line">    <span class="comment">// 获得 ServiceBean 对象</span></span><br /><span class="line">    ServiceBean serviceBean = event.getServiceBean();</span><br /><span class="line">    <span class="comment">// 初始化对应的 ReferenceBeanInvocationHandler</span></span><br /><span class="line">    initReferenceBeanInvocationHandler(serviceBean);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initReferenceBeanInvocationHandler</span><span class="params">(ServiceBean serviceBean)</span> </span>{</span><br /><span class="line">    String serviceBeanName = serviceBean.getBeanName();</span><br /><span class="line">    <span class="comment">// Remove ServiceBean when it's exported</span></span><br /><span class="line">    <span class="comment">// 从 localReferenceBeanInvocationHandlerCache 缓存中，移除</span></span><br /><span class="line">    ReferenceBeanInvocationHandler handler = localReferenceBeanInvocationHandlerCache.remove(serviceBeanName);</span><br /><span class="line">    <span class="comment">// Initialize</span></span><br /><span class="line">    <span class="comment">// 执行初始化</span></span><br /><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) {</span><br /><span class="line">        handler.init();</span><br /><span class="line">    }</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextRefreshedEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>{</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>重点在于处理 ServiceBeanExportedEvent 事件。处理时，如果判断&nbsp;<code>localReferenceBeanInvocationHandlerCache</code>&nbsp;中存在 ReferenceBeanInvocationHandler 对象，说明有它未初始化。后续，调用&nbsp;<code>ReferenceBeanInvocationHandler#init()</code>&nbsp;方法，从而完成。这块，胖友结合&nbsp;<a href="http://svip.iocoder.cn/Dubbo/configuration-annotation/">「5.2.2 doGetInjectedBean」</a>&nbsp;一起，是不是就明白了。</li>
<li>
<p>在 ServiceBean 暴露服务完成后，会发布 ServiceBeanExportedEvent 事件。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ServiceBean.java</span></span><br /><br /><span class="line"><span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.6.5</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 暴露服务</span></span><br /><span class="line">    <span class="keyword">super</span>.export();</span><br /><span class="line">    <span class="comment">// Publish ServiceBeanExportedEvent</span></span><br /><span class="line">    <span class="comment">// 发布事件</span></span><br /><span class="line">    publishExportEvent();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.6.5</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishExportEvent</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 ServiceBeanExportedEvent 对象</span></span><br /><span class="line">    ServiceBeanExportedEvent exportEvent = <span class="keyword">new</span> ServiceBeanExportedEvent(<span class="keyword">this</span>);</span><br /><span class="line">    <span class="comment">// 发布事件</span></span><br /><span class="line">    applicationEventPublisher.publishEvent(exportEvent);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><code>org.apache.dubbo.config.spring.context.event.ServiceBeanExportedEvent</code>&nbsp;，Service Bean 暴露完成事件。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// BeanExportedEvent.java</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * A {<span class="doctag">@link</span> ApplicationEvent} after {<span class="doctag">@link</span> ServiceBean} {<span class="doctag">@link</span> ServiceBean#export() export} invocation</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> ApplicationEvent</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> ApplicationListener</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> ServiceBean</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.6.5</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBeanExportedEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Create a new ApplicationEvent.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceBean {<span class="doctag">@link</span> ServiceBean} bean</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceBeanExportedEvent</span><span class="params">(ServiceBean serviceBean)</span> </span>{</span><br /><span class="line">        <span class="keyword">super</span>(serviceBean);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Get {<span class="doctag">@link</span> ServiceBean} instance</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> ServiceBean <span class="title">getServiceBean</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> (ServiceBean) <span class="keyword">super</span>.getSource();</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<h3 id="5-3-4-ReferenceBeanBuilder">5.3.4 ReferenceBeanBuilder</h3>
<p><code>org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceBeanBuilder</code>&nbsp;，继承 AbstractAnnotationConfigBeanBuilder 抽象类，ReferenceBean 的构建器。</p>
<blockquote>
<p>考虑到 ReferenceBeanBuilder 类，就是&nbsp;<code>#build()</code>&nbsp;方法，我们就直接结合 AbstractAnnotationConfigBeanBuilder 抽象类，一起写了。</p>
</blockquote>
<h4 id="5-3-4-1-构造方法">5.3.4.1 构造方法</h4>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// AbstractAnnotationConfigBeanBuilder.java</span></span><br /><br /><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>, <span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractInterfaceConfig</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 注解</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> A annotation;</span><br />    <br /><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br />    <br /><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br />    <br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Bean 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">protected</span> Object bean;</span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 接口</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; interfaceClass;</span><br />    <br /><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span><span class="params">(A annotation, ClassLoader classLoader,</span></span></span><br /><span class="line"><span class="function"><span class="params">                                                  ApplicationContext applicationContext)</span> </span>{</span><br /><span class="line">        Assert.notNull(annotation, <span class="string">"The Annotation must not be null!"</span>);</span><br /><span class="line">        Assert.notNull(classLoader, <span class="string">"The ClassLoader must not be null!"</span>);</span><br /><span class="line">        Assert.notNull(applicationContext, <span class="string">"The ApplicationContext must not be null!"</span>);</span><br /><span class="line">        <span class="keyword">this</span>.annotation = annotation;</span><br /><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br /><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br /><span class="line">    }</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// ReferenceBeanBuilder.java</span></span><br /><br /><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">Reference</span>, <span class="title">ReferenceBean</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ReferenceBeanBuilder</span><span class="params">(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext)</span> </span>{</span><br /><span class="line">        <span class="keyword">super</span>(annotation, classLoader, applicationContext);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReferenceBeanBuilder <span class="title">create</span><span class="params">(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext)</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReferenceBeanBuilder(annotation, classLoader, applicationContext);</span><br /><span class="line">    }</span><br />    <br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>其中，泛型&nbsp;<code>A</code>&nbsp;对应&nbsp;<code>@Reference</code>&nbsp;注解，泛型&nbsp;<code>B</code>&nbsp;对应 ReferenceBean 类。</li>
</ul>
<h4 id="5-3-4-2-build">5.3.4.2 build</h4>
<p><code>#build()</code>&nbsp;方法，构造泛型&nbsp;<code>B</code>&nbsp;对象。此处，就是构造 ReferenceBean 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// AbstractAnnotationConfigBeanBuilder.java</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> B <span class="title">build</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line">    <span class="comment">// 校验依赖</span></span><br /><span class="line">    checkDependencies();</span><br /><span class="line">    <span class="comment">// 执行构造 Bean 对象</span></span><br /><span class="line">    B bean = doBuild();</span><br /><span class="line">    <span class="comment">// 配置 Bean 对象</span></span><br /><span class="line">    configureBean(bean);</span><br /><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line">        logger.info(<span class="string">"The bean[type:"</span> + bean.getClass().getSimpleName() + <span class="string">"] has been built."</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> bean;</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkDependencies</span><span class="params">()</span> </span>{</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Builds {<span class="doctag">@link</span> B Bean}</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@link</span> B Bean}</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> B <span class="title">doBuild</span><span class="params">()</span></span>;</span><br /><br /><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureBean</span><span class="params">(B bean)</span> <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line">    <span class="comment">// 前置配置</span></span><br /><span class="line">    preConfigureBean(annotation, bean);</span><br /><br /><span class="line">    <span class="comment">// 配置 RegistryConfig 属性</span></span><br /><span class="line">    configureRegistryConfigs(bean);</span><br /><span class="line">    <span class="comment">// 配置 MonitorConfig 属性</span></span><br /><span class="line">    configureMonitorConfig(bean);</span><br /><span class="line">    <span class="comment">// 配置 ApplicationConfig 属性</span></span><br /><span class="line">    configureApplicationConfig(bean);</span><br /><span class="line">    <span class="comment">// 配置 ModuleConfig 属性</span></span><br /><span class="line">    configureModuleConfig(bean);</span><br /><br /><span class="line">    <span class="comment">// 后置配置</span></span><br /><span class="line">    postConfigureBean(annotation, bean);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">preConfigureBean</span><span class="params">(A annotation, B bean)</span> <span class="keyword">throws</span> Exception</span>; <span class="comment">// 抽象方法</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureRegistryConfigs</span><span class="params">(B bean)</span> </span>{</span><br /><span class="line">    String[] registryConfigBeanIds = resolveRegistryConfigBeanNames(annotation);</span><br /><span class="line">    List&lt;RegistryConfig&gt; registryConfigs = BeanFactoryUtils.getBeans(applicationContext, registryConfigBeanIds, RegistryConfig.class);</span><br /><span class="line">    bean.setRegistries(registryConfigs);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureMonitorConfig</span><span class="params">(B bean)</span> </span>{</span><br /><span class="line">    String monitorBeanName = resolveMonitorConfigBeanName(annotation);</span><br /><span class="line">    MonitorConfig monitorConfig = BeanFactoryUtils.getOptionalBean(applicationContext, monitorBeanName, MonitorConfig.class);</span><br /><span class="line">    bean.setMonitor(monitorConfig);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureApplicationConfig</span><span class="params">(B bean)</span> </span>{</span><br /><span class="line">    String applicationConfigBeanName = resolveApplicationConfigBeanName(annotation);</span><br /><span class="line">    ApplicationConfig applicationConfig = BeanFactoryUtils.getOptionalBean(applicationContext, applicationConfigBeanName, ApplicationConfig.class);</span><br /><span class="line">    bean.setApplication(applicationConfig);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureModuleConfig</span><span class="params">(B bean)</span> </span>{</span><br /><span class="line">    String moduleConfigBeanName = resolveModuleConfigBeanName(annotation);</span><br /><span class="line">    ModuleConfig moduleConfig = BeanFactoryUtils.getOptionalBean(applicationContext, moduleConfigBeanName, ModuleConfig.class);</span><br /><span class="line">    bean.setModule(moduleConfig);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">resolveModuleConfigBeanName</span><span class="params">(A annotation)</span></span>; <span class="comment">// 抽象方法</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">resolveApplicationConfigBeanName</span><span class="params">(A annotation)</span></span>; <span class="comment">// 抽象方法</span></span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> String[] resolveRegistryConfigBeanNames(A annotation); <span class="comment">// 抽象方法</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">resolveMonitorConfigBeanName</span><span class="params">(A annotation)</span></span>; <span class="comment">// 抽象方法</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">postConfigureBean</span><span class="params">(A annotation, B bean)</span> <span class="keyword">throws</span> Exception</span>; <span class="comment">// 抽象方法</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>ReferenceBeanBuilder 主要对上面的抽象方法，进行具体实现。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ReferenceBeanBuilder.java</span></span><br /><br /><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] IGNORE_FIELD_NAMES = of(<span class="string">"application"</span>, <span class="string">"module"</span>, <span class="string">"consumer"</span>, <span class="string">"monitor"</span>, <span class="string">"registry"</span>)</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> ReferenceBean <span class="title">doBuild</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 ReferenceBean 对象</span></span><br /><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferenceBean&lt;&gt;();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preConfigureBean</span><span class="params">(Reference reference, ReferenceBean referenceBean)</span> </span>{</span><br /><span class="line">    Assert.notNull(interfaceClass, <span class="string">"The interface class must set first!"</span>);</span><br /><br /><span class="line">    <span class="comment">// 创建 DataBinder 对象</span></span><br /><span class="line">    DataBinder dataBinder = <span class="keyword">new</span> DataBinder(referenceBean);</span><br /><span class="line">    <span class="comment">// Register CustomEditors for special fields</span></span><br /><span class="line">    <span class="comment">// 注册指定属性的自定义 Editor</span></span><br /><span class="line">    dataBinder.registerCustomEditor(String.class, <span class="string">"filter"</span>, <span class="keyword">new</span> StringTrimmerEditor(<span class="keyword">true</span>));</span><br /><span class="line">    dataBinder.registerCustomEditor(String.class, <span class="string">"listener"</span>, <span class="keyword">new</span> StringTrimmerEditor(<span class="keyword">true</span>));</span><br /><span class="line">    dataBinder.registerCustomEditor(Map.class, <span class="string">"parameters"</span>, <span class="keyword">new</span> PropertyEditorSupport() {</span><br /><span class="line">        <span class="meta">@Override</span></span><br /><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> java.lang.IllegalArgumentException </span>{</span><br /><span class="line">            <span class="comment">// Trim all whitespace</span></span><br /><span class="line">            String content = StringUtils.trimAllWhitespace(text);</span><br /><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(content)) { <span class="comment">// No content , ignore directly</span></span><br /><span class="line">                <span class="keyword">return</span>;</span><br /><span class="line">            }</span><br /><span class="line">            <span class="comment">// replace "=" to ","</span></span><br /><span class="line">            content = StringUtils.replace(content, <span class="string">"="</span>, <span class="string">","</span>);</span><br /><span class="line">            <span class="comment">// replace ":" to ","</span></span><br /><span class="line">            content = StringUtils.replace(content, <span class="string">":"</span>, <span class="string">","</span>);</span><br /><span class="line">            <span class="comment">// String[] to Map</span></span><br /><span class="line">            Map&lt;String, String&gt; parameters = CollectionUtils.toStringMap(commaDelimitedListToStringArray(content));</span><br /><span class="line">            setValue(parameters);</span><br /><span class="line">        }</span><br /><span class="line">    });</span><br /><br /><span class="line">    <span class="comment">// Bind annotation attributes</span></span><br /><span class="line">    <span class="comment">// 将注解的属性，设置到 reference 中</span></span><br /><span class="line">    dataBinder.bind(<span class="keyword">new</span> AnnotationPropertyValuesAdapter(reference, applicationContext.getEnvironment(), IGNORE_FIELD_NAMES));</span><br /><span class="line">}</span><br /><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolveModuleConfigBeanName</span><span class="params">(Reference annotation)</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> annotation.<span class="keyword">module</span>();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolveApplicationConfigBeanName</span><span class="params">(Reference annotation)</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> annotation.application();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="keyword">protected</span> String[] resolveRegistryConfigBeanNames(Reference annotation) {</span><br /><span class="line">    <span class="keyword">return</span> annotation.registry();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolveMonitorConfigBeanName</span><span class="params">(Reference annotation)</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> annotation.monitor();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postConfigureBean</span><span class="params">(Reference annotation, ReferenceBean bean)</span> <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line">    <span class="comment">// 设置 applicationContext</span></span><br /><span class="line">    bean.setApplicationContext(applicationContext);</span><br /><span class="line">    <span class="comment">// 配置 interfaceClass</span></span><br /><span class="line">    configureInterface(annotation, bean);</span><br /><span class="line">    <span class="comment">// 配置 ConsumerConfig</span></span><br /><span class="line">    configureConsumerConfig(annotation, bean);</span><br /><br /><span class="line">    <span class="comment">// 执行 Bean 后置属性初始化</span></span><br /><span class="line">    bean.afterPropertiesSet();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureInterface</span><span class="params">(Reference reference, ReferenceBean referenceBean)</span> </span>{</span><br /><span class="line">    <span class="comment">// 首先，从 @Reference 获得 interfaceName 属性，从而获得 interfaceClass 类</span></span><br /><span class="line">    Class&lt;?&gt; interfaceClass = reference.interfaceClass();</span><br /><span class="line">    <span class="keyword">if</span> (<span class="keyword">void</span>.class.equals(interfaceClass)) {</span><br /><span class="line">        interfaceClass = <span class="keyword">null</span>;</span><br /><span class="line">        String interfaceClassName = reference.interfaceName();</span><br /><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(interfaceClassName)) {</span><br /><span class="line">            <span class="keyword">if</span> (ClassUtils.isPresent(interfaceClassName, classLoader)) {</span><br /><span class="line">                interfaceClass = ClassUtils.resolveClassName(interfaceClassName, classLoader);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">// 如果获得不到，则使用 interfaceClass 即可</span></span><br /><span class="line">    <span class="keyword">if</span> (interfaceClass == <span class="keyword">null</span>) {</span><br /><span class="line">        interfaceClass = <span class="keyword">this</span>.interfaceClass;</span><br /><span class="line">    }</span><br /><br /><span class="line">    Assert.isTrue(interfaceClass.isInterface(), <span class="string">"The class of field or method that was annotated @Reference is not an interface!"</span>);</span><br /><span class="line">    referenceBean.setInterface(interfaceClass);</span><br /><span class="line">}</span><br /><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureConsumerConfig</span><span class="params">(Reference reference, ReferenceBean&lt;?&gt; referenceBean)</span> </span>{</span><br /><span class="line">    <span class="comment">// 获得 ConsumerConfig 对象</span></span><br /><span class="line">    String consumerBeanName = reference.consumer();</span><br /><span class="line">    ConsumerConfig consumerConfig = getOptionalBean(applicationContext, consumerBeanName, ConsumerConfig.class);</span><br /><span class="line">    <span class="comment">// 设置到 referenceBean 中</span></span><br /><span class="line">    referenceBean.setConsumer(consumerConfig);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>~</li>
</ul>
</li>
</ul>
<p>😈 写的相对简略。胖友注意看每一个的注释哈~</p>
<h3 id="5-3-5-destroy">5.3.5 destroy</h3>
<p>实现&nbsp;<code>#destroy()</code>&nbsp;方法，执行销毁逻辑。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ReferenceAnnotationBeanPostProcessor.java</span></span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line">    <span class="comment">// 父类销毁</span></span><br /><span class="line">    <span class="keyword">super</span>.destroy();</span><br /><span class="line">    <span class="comment">// 清空缓存</span></span><br /><span class="line">    <span class="keyword">this</span>.referenceBeanCache.clear();</span><br /><span class="line">    <span class="keyword">this</span>.localReferenceBeanInvocationHandlerCache.clear();</span><br /><span class="line">    <span class="keyword">this</span>.injectedFieldReferenceBeanCache.clear();</span><br /><span class="line">    <span class="keyword">this</span>.injectedMethodReferenceBeanCache.clear();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</div>