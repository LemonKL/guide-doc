关键字
    transient
    instanceof
    volatile
    synchronized
    final
    static
    const
    
##### transient
    transient的用途及使用方法
    用途
    　　我们知道，当一个对象实现了Serilizable接口，这个对象就可以被序列化，我们不关心其内在的原理，只需要了解这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。而在开发过程中，我们可能要求：当对象被序列化时（写入字节序列到目标文件）时，有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 
    　所以，transient的用途在于：阻止实例中那些用此关键字声明的变量持久化；当对象被反序列化时（从源文件读取字节序列进行重构），这样的实例变量值不会被持久化和恢复。例如，当反序列化对象——数据流（例如，文件）可能不存在时，原因是你的对象中存在类型为java.io.InputStream的变量，序列化时这些变量引用的输入流无法被打开。
    2，使用方法
    序列化的时候，将不需要序列化的属性前添加关键字transient即可。 
    示例：
    package newDay.day13;
    
    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.io.ObjectInputStream;
    import java.io.ObjectOutputStream;
    import java.io.Serializable;
    
    class UserInfo implements Serializable {  
        private static final long serialVersionUID = 996890129747019948L;  
        private String name;  
        private transient String psw;  
    
        public UserInfo(String name, String psw) {  
            this.name = name;  
            this.psw = psw;  
        }  
    
        public String toString() {  
            return "name=" + name + ", psw=" + psw;  
        }  
    }  
    public class TestTransient {
        public static void main(String[] args) {  
            UserInfo userInfo = new UserInfo("张三", "123456");  
            System.out.println(userInfo);  
            try {  
                // 序列化，被设置为transient的属性没有被序列化  
                ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream("UserInfo.txt"));  
                o.writeObject(userInfo);  
                o.close();  
            } catch (Exception e) {  
                // TODO: handle exception  
                e.printStackTrace();  
            }  
            try {  
                // 重新读取内容  
                ObjectInputStream in = new ObjectInputStream(new FileInputStream("UserInfo.txt"));  
                UserInfo readUserInfo = (UserInfo) in.readObject();  
                //读取后psw的内容为null  
                System.out.println(readUserInfo.toString());  
            } catch (Exception e) {  
                // TODO: handle exception  
                e.printStackTrace();  
            }  
    
    运行结果：
    name=张三, psw=123456
    name=张三, psw=null
    　　密码字段为null，说明被标记为transient的属性在对象被序列化的时候不会被保存。
    使用小结：
    　　1，一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 
    　　2，transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 
    　　3，被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 
    　　对于第三点，加上static之后，依然能把姓名输出。这是因为：反序列化后类中static型变量name的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的。下例可说明，其值时JVM中得到的而不是反序列化得到的：
    package newDay.day13;
    
    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.io.ObjectInputStream;
    import java.io.ObjectOutputStream;
    import java.io.Serializable;
    
    class UserInfo implements Serializable {  
        private static final long serialVersionUID = 996890129747019948L;  
        private static String name;  
        private transient String psw;  
    
        public UserInfo(String name, String psw) {  
            this.name = name;  
            this.psw = psw;  
        }  
    
        public static String getName() {
            return name;
        }
    
        public static void setName(String name) {
            UserInfo.name = name;
        }
    
        public String getPsw() {
            return psw;
        }
    
        public void setPsw(String psw) {
            this.psw = psw;
        }
    
        public String toString() {  
            return "name=" + name + ", psw=" + psw;  
        }  
    }  
    public class TestTransient {
        public static void main(String[] args) {  
            UserInfo userInfo = new UserInfo("张三", "123456"); 
            System.out.println(userInfo);  
            try {  
                // 序列化，被设置为transient的属性没有被序列化  
                ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream("UserInfo.txt"));  
                o.writeObject(userInfo);  
                o.close();  
            } catch (Exception e) {  
                // TODO: handle exception  
                e.printStackTrace();  
            }  
            try {  
                //在反序列化之前改变name的值
                userInfo.setName("hello");
                // 重新读取内容  
                ObjectInputStream in = new ObjectInputStream(new FileInputStream("UserInfo.txt"));  
                UserInfo readUserInfo = (UserInfo) in.readObject();  
                //读取后psw的内容为null  
                System.out.println(readUserInfo.toString());  
            } catch (Exception e) {  
                // TODO: handle exception  
                e.printStackTrace();  
            }  
        }  
    }
    运行结果：
    name=张三, psw=123456
    name=hello, psw=null
    这说明反序列化后类中static型变量name的值为当前JVM中对应static变量的值，为修改后hello，而不是序列化时的值“张三”

#### instanceof
    java 中的instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。
    
    用法： 
    result = object instanceof class 
    参数： 
    Result：布尔类型。 
    Object：必选项。任意对象表达式。 
    Class：必选项。任意已定义的对象类。 
    说明： 
    如果 object 是 class 的一个实例，则 instanceof 运算符返回 true。如果 object 不是指定类的一个实例，或者 object 是 null，则返回 false。
    
    但是instanceof在Java的编译状态和运行状态是有区别的：
    
    在编译状态中，class可以是object对象的父类，自身类，子类。在这三种情况下Java编译时不会报错。
    
    在运行转态中，class可以是object对象的父类，自身类，不能是子类。在前两种情况下result的结果为true，最后一种为false。但是class为子类时编译不会报错。运行结果为false。
    
    例子：
    
    接口Person
    
    public interface Person {
    public void eat();
    }
    
    实现类People
    
    public class People implements Person {
    private int a=0;
     @Override
     public void eat() {
      System.out.println("======"+a);
      
     }
    
    }
    
    子类xiaoming：
    
    public class xiaoming extends People {
    private String name;
    
    @Override
    public void eat() {
     System.out.println("+++++++++");
    }
    }
    
    主函数
    
    public static void main(String[] args) {
      People p=new People();
      xiaoming x=new xiaoming();
      System.out.println(p instanceof Person);
      System.out.println(p instanceof xiaoming); -----2
      System.out.println(x instanceof Person);
      System.out.println(x instanceof People);
     }
    
    注意：上面2处的代码在编译时不会报错。
    
    运行结果：
    
    true
    false
    true
    true
    
#### volatile

    　　语义：
        一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
    
    　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
    
    　　2）禁止进行指令重排序。
    
        场景：
        第一：使用volatile关键字会强制将修改的值立即写入主存；
        
        第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
        
        第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
        
详见[volatile关键字](/4.keyword(关键字)/volatile.md)

synchronized


final
static
const
