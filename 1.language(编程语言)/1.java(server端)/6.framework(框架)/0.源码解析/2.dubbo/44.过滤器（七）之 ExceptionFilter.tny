<header class="article-header">
<h1 class="article-title">过滤器（七）之 ExceptionFilter</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>本文分享异常过滤器 ExceptionFilter ，用于服务<strong>提供者</strong>中。用途如下：</p>
<blockquote>
<p>FROM ExceptionFilter 上的注释：</p>
<ol>
<li>不期望的异常打 ERROR 日志( Provider端 )。不期望的日志即是，没有的接口上声明的Unchecked异常。</li>
<li>异常不在 API 包中，则 Wrap 一层 RuntimeException 。RPC 对于第一层异常会直接序列化传输( Cause 异常会 String 化) ，避免异常在 Client 出不能<strong>反序列化</strong>问题。</li>
</ol>
</blockquote>
<p>🙂 和我们平时业务写的用于<strong>捕捉异常</strong>的过滤器或者拦截器<strong>不太一样</strong>，而是关注点在服务消费者会不会出现不存在该异常类，导致反序列化的问题。</p>
<h1 id="2-ExceptionFilter">2. ExceptionFilter</h1>
<p><code>com.alibaba.dubbo.rpc.filter.ExceptionFilter</code>&nbsp;，实现 Filter 接口，异常过滤器实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Activate</span>(group = Constants.PROVIDER)</span><br /><span class="line"> <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>{</span><br /><span class="line"> <span class="number">3</span>: </span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Logger logger;</span><br /><span class="line"> <span class="number">5</span>: </span><br /><span class="line"> <span class="number">6</span>:     <span class="function"><span class="keyword">public</span> <span class="title">ExceptionFilter</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">this</span>(LoggerFactory.getLogger(ExceptionFilter.class));</span><br /><span class="line"> <span class="number">8</span>:     }</span><br /><span class="line"> <span class="number">9</span>: </span><br /><span class="line"><span class="number">10</span>:     <span class="function"><span class="keyword">public</span> <span class="title">ExceptionFilter</span><span class="params">(Logger logger)</span> </span>{</span><br /><span class="line"><span class="number">11</span>:         <span class="keyword">this</span>.logger = logger;</span><br /><span class="line"><span class="number">12</span>:     }</span><br /><span class="line"><span class="number">13</span>: </span><br /><span class="line"><span class="number">14</span>:     <span class="meta">@Override</span></span><br /><span class="line"><span class="number">15</span>:     <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"><span class="number">16</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">17</span>:             <span class="comment">// 服务调用</span></span><br /><span class="line"><span class="number">18</span>:             Result result = invoker.invoke(invocation);</span><br /><span class="line"><span class="number">19</span>:             <span class="comment">// 有异常，并且非泛化调用</span></span><br /><span class="line"><span class="number">20</span>:             <span class="keyword">if</span> (result.hasException() &amp;&amp; GenericService.class != invoker.getInterface()) {</span><br /><span class="line"><span class="number">21</span>:                 <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">22</span>:                     Throwable exception = result.getException();</span><br /><span class="line"><span class="number">23</span>: </span><br /><span class="line"><span class="number">24</span>:                     <span class="comment">// directly throw if it's checked exception</span></span><br /><span class="line"><span class="number">25</span>:                     <span class="comment">// 如果是checked异常，直接抛出</span></span><br /><span class="line"><span class="number">26</span>:                     <span class="keyword">if</span> (!(exception <span class="keyword">instanceof</span> RuntimeException) &amp;&amp; (exception <span class="keyword">instanceof</span> Exception)) {</span><br /><span class="line"><span class="number">27</span>:                         <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">28</span>:                     }</span><br /><span class="line"><span class="number">29</span>:                     <span class="comment">// directly throw if the exception appears in the signature</span></span><br /><span class="line"><span class="number">30</span>:                     <span class="comment">// 在方法签名上有声明，直接抛出</span></span><br /><span class="line"><span class="number">31</span>:                     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">32</span>:                         Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes());</span><br /><span class="line"><span class="number">33</span>:                         Class&lt;?&gt;[] exceptionClassses = method.getExceptionTypes();</span><br /><span class="line"><span class="number">34</span>:                         <span class="keyword">for</span> (Class&lt;?&gt; exceptionClass : exceptionClassses) {</span><br /><span class="line"><span class="number">35</span>:                             <span class="keyword">if</span> (exception.getClass().equals(exceptionClass)) {</span><br /><span class="line"><span class="number">36</span>:                                 <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">37</span>:                             }</span><br /><span class="line"><span class="number">38</span>:                         }</span><br /><span class="line"><span class="number">39</span>:                     } <span class="keyword">catch</span> (NoSuchMethodException e) {</span><br /><span class="line"><span class="number">40</span>:                         <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">41</span>:                     }</span><br /><span class="line"><span class="number">42</span>: </span><br /><span class="line"><span class="number">43</span>:                     <span class="comment">// 未在方法签名上定义的异常，在服务器端打印 ERROR 日志</span></span><br /><span class="line"><span class="number">44</span>:                     <span class="comment">// for the exception not found in method's signature, print ERROR message in server's log.</span></span><br /><span class="line"><span class="number">45</span>:                     logger.error(<span class="string">"Got unchecked and undeclared exception which called by "</span> + RpcContext.getContext().getRemoteHost()</span><br /><span class="line"><span class="number">46</span>:                             + <span class="string">". service: "</span> + invoker.getInterface().getName() + <span class="string">", method: "</span> + invocation.getMethodName()</span><br /><span class="line"><span class="number">47</span>:                             + <span class="string">", exception: "</span> + exception.getClass().getName() + <span class="string">": "</span> + exception.getMessage(), exception);</span><br /><span class="line"><span class="number">48</span>: </span><br /><span class="line"><span class="number">49</span>:                     <span class="comment">// 异常类和接口类在同一 jar 包里，直接抛出</span></span><br /><span class="line"><span class="number">50</span>:                     <span class="comment">// directly throw if exception class and interface class are in the same jar file.</span></span><br /><span class="line"><span class="number">51</span>:                     String serviceFile = ReflectUtils.getCodeBase(invoker.getInterface());</span><br /><span class="line"><span class="number">52</span>:                     String exceptionFile = ReflectUtils.getCodeBase(exception.getClass());</span><br /><span class="line"><span class="number">53</span>:                     <span class="keyword">if</span> (serviceFile == <span class="keyword">null</span> || exceptionFile == <span class="keyword">null</span> || serviceFile.equals(exceptionFile)) {</span><br /><span class="line"><span class="number">54</span>:                         <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">55</span>:                     }</span><br /><span class="line"><span class="number">56</span>:                     <span class="comment">// 是JDK自带的异常，直接抛出</span></span><br /><span class="line"><span class="number">57</span>:                     <span class="comment">// directly throw if it's JDK exception</span></span><br /><span class="line"><span class="number">58</span>:                     String className = exception.getClass().getName();</span><br /><span class="line"><span class="number">59</span>:                     <span class="keyword">if</span> (className.startsWith(<span class="string">"java."</span>) || className.startsWith(<span class="string">"javax."</span>)) {</span><br /><span class="line"><span class="number">60</span>:                         <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">61</span>:                     }</span><br /><span class="line"><span class="number">62</span>:                     <span class="comment">// 是Dubbo本身的异常，直接抛出</span></span><br /><span class="line"><span class="number">63</span>:                     <span class="comment">// directly throw if it's dubbo exception</span></span><br /><span class="line"><span class="number">64</span>:                     <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RpcException) {</span><br /><span class="line"><span class="number">65</span>:                         <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">66</span>:                     }</span><br /><span class="line"><span class="number">67</span>: </span><br /><span class="line"><span class="number">68</span>:                     <span class="comment">// 否则，包装成RuntimeException抛给客户端</span></span><br /><span class="line"><span class="number">69</span>:                     <span class="comment">// otherwise, wrap with RuntimeException and throw back to the client</span></span><br /><span class="line"><span class="number">70</span>:                     <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(<span class="keyword">new</span> RuntimeException(StringUtils.toString(exception)));</span><br /><span class="line"><span class="number">71</span>:                 } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">72</span>:                     logger.warn(<span class="string">"Fail to ExceptionFilter when called by "</span> + RpcContext.getContext().getRemoteHost()</span><br /><span class="line"><span class="number">73</span>:                             + <span class="string">". service: "</span> + invoker.getInterface().getName() + <span class="string">", method: "</span> + invocation.getMethodName()</span><br /><span class="line"><span class="number">74</span>:                             + <span class="string">", exception: "</span> + e.getClass().getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br /><span class="line"><span class="number">75</span>:                     <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">76</span>:                 }</span><br /><span class="line"><span class="number">77</span>:             }</span><br /><span class="line"><span class="number">78</span>:             <span class="comment">// 返回</span></span><br /><span class="line"><span class="number">79</span>:             <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">80</span>:         } <span class="keyword">catch</span> (RuntimeException e) {</span><br /><span class="line"><span class="number">81</span>:             logger.error(<span class="string">"Got unchecked and undeclared exception which called by "</span> + RpcContext.getContext().getRemoteHost()</span><br /><span class="line"><span class="number">82</span>:                     + <span class="string">". service: "</span> + invoker.getInterface().getName() + <span class="string">", method: "</span> + invocation.getMethodName()</span><br /><span class="line"><span class="number">83</span>:                     + <span class="string">", exception: "</span> + e.getClass().getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br /><span class="line"><span class="number">84</span>:             <span class="keyword">throw</span> e;</span><br /><span class="line"><span class="number">85</span>:         }</span><br /><span class="line"><span class="number">86</span>:     }</span><br /><span class="line"><span class="number">87</span>: </span><br /><span class="line"><span class="number">88</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 18 行：调用&nbsp;<code>Invoker#invoke(invocation)</code>&nbsp;方法，服务调用。</li>
<li>第 21 行：调用结果有异常，并且非<strong>泛化调用</strong>。</li>
<li>第 24 至 28 行：如果是 checked 异常，直接返回。因为，checked 异常，肯定定义在接口上了。</li>
<li>第 29 至 41 行：在接口方法的签名有生命，直接返回结果。</li>
<li>第 45 至 47 行：未在方法签名上定义的异常，在服务器端打印 ERROR 日志。</li>
<li>
<p>第 49 至 55 行：异常类和接口类在同一&nbsp;<strong>jar</strong>&nbsp;包里，直接返回结果。因为，服务消费者可以反序列化该异常。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCodeBase</span><span class="params">(Class&lt;?&gt; cls)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (cls == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">    }</span><br /><span class="line">    ProtectionDomain domain = cls.getProtectionDomain();</span><br /><span class="line">    <span class="keyword">if</span> (domain == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">    }</span><br /><span class="line">    CodeSource source = domain.getCodeSource();</span><br /><span class="line">    <span class="keyword">if</span> (source == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">    }</span><br /><span class="line">    URL location = source.getLocation();</span><br /><span class="line">    <span class="keyword">if</span> (location == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> location.getFile();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>第 56 至 61 行：是 JDK 自带的异常，直接返回结果。</p>
</li>
<li>第 62 至 66 行：是 Dubbo 本身的异常，直接返回结果。</li>
<li>
<p>第 70 行：否则，包装成 RuntimeException 异常返回给服务消费者，同时把异常堆栈给包进去。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(Throwable e)</span> </span>{</span><br /><span class="line">    UnsafeStringWriter w = <span class="keyword">new</span> UnsafeStringWriter();</span><br /><span class="line">    PrintWriter p = <span class="keyword">new</span> PrintWriter(w);</span><br /><span class="line">    p.print(e.getClass().getName());</span><br /><span class="line">    <span class="keyword">if</span> (e.getMessage() != <span class="keyword">null</span>) {</span><br /><span class="line">        p.print(<span class="string">": "</span> + e.getMessage());</span><br /><span class="line">    }</span><br /><span class="line">    p.println();</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        e.printStackTrace(p);</span><br /><span class="line">        <span class="keyword">return</span> w.toString();</span><br /><span class="line">    } <span class="keyword">finally</span> {</span><br /><span class="line">        p.close();</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<h1 id="666-彩蛋">666. 彩蛋</h1>
<p>😜 一开始想错了，怪不得觉得好奇怪。</p>
<p>另外，笔者有个想法。我们在实际使用时，可能会定义通用的 BusinessException ，并且每个接口，实际都会抛出该异常。那么要求开发每个接口都定义抛出 BusinessException 是比较&ldquo;麻烦&rdquo;的。<br />但是，按照 ExceptionFilter 的逻辑，会打印异常日志。<br />所以，笔者的想法是，重写 ExceptionFilter ，定义一些通用异常，允许直接返回结果。🙂</p>
</div>