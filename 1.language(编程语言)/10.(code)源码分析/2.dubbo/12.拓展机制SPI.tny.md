<header class="article-header">
<h1 class="article-title">源码分析 &mdash;&mdash; 拓展机制 SPI</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC&nbsp;<strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC&nbsp;<strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr />
<h1 id="1-概述">1. 概述</h1>
<blockquote>
<p>艿艿的友情提示：</p>
<p>这是一篇相对长的文章。</p>
<p>胖友可以带着这样的思维来理解 Dubbo SPI ，它提供了 Spring IOC、AOP 的功能。😈</p>
</blockquote>
<p>本文主要分享&nbsp;<strong>Dubbo 的拓展机制 SPI</strong>。</p>
<p>想要理解 Dubbo ，理解 Dubbo SPI 是非常必须的。在 Dubbo 中，提供了大量的<strong>拓展点</strong>，基于 Dubbo SPI 机制加载。如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_03_04/01.png" alt="Dubbo 拓展点" /></p>
<h1 id="2-改进">2. 改进</h1>
<p>在看具体的 Dubbo SPI 实现之前，我们先理解 Dubbo SPI 产生的背景：</p>
<blockquote>
<p>FROM&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/dev/SPI.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 开发指南 &mdash;&mdash; 拓展点加载》</a></p>
<p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。</p>
<p>Dubbo 改进了 JDK 标准的 SPI 的以下问题：</p>
<ol>
<li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。</li>
<li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。</li>
<li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>
</ol>
</blockquote>
<ul>
<li>Dubbo 自己实现了一套 SPI 机制，而不是使用 Java 标准的 SPI 。</li>
<li>第一点问题，Dubbo 有很多的拓展点，例如 Protocol、Filter 等等。并且每个拓展点有多种的实现，例如 Protocol 有 DubboProtocol、InjvmProtocol、RestProtocol 等等。那么使用 JDK SPI 机制，会初始化无用的拓展点及其实现，造成不必要的耗时与资源浪费。
<ul>
<li>如果无法理解的胖友，跟着&nbsp;<a href="http://blog.csdn.net/top_code/article/details/51934459" target="_blank" rel="external nofollow noopener noreferrer">《Java SPI(Service Provider Interface)简介》</a>&nbsp;文章，<strong>写多个拓展实现</strong>，就很容易理解了。🙂 这就是概念呀。</li>
</ul>
</li>
<li>第二点问题，【TODO 8009】ScriptEngine 没看明白，不影响本文理解。</li>
<li>第三点问题，严格来说，这不算问题，<strong>而是增加了功能特性</strong>，在下文我们会看到。</li>
</ul>
<h1 id="3-代码结构">3. 代码结构</h1>
<p>Dubbo SPI 在&nbsp;<code>dubbo-common</code>&nbsp;的&nbsp;<a href="https://github.com/YunaiV/dubbo/tree/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension" target="_blank" rel="external nofollow noopener noreferrer"><code>extension</code></a>&nbsp;包实现，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_03_04/02.png" alt="代码结构" /></p>
<h1 id="4-ExtensionLoader">4. ExtensionLoader</h1>
<p><a href="http://svip.iocoder.cn/Dubbo/spi/ExtensionLoader"><code>com.alibaba.dubbo.common.extension.ExtensionLoader</code></a>&nbsp;，拓展加载器。这是 Dubbo SPI 的<strong>核心</strong>。</p>
<h2 id="4-1-属性">4.1 属性</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">  <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICES_DIRECTORY = <span class="string">"META-INF/services/"</span>;</span><br /><span class="line">  <span class="number">2</span>: </span><br /><span class="line">  <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_DIRECTORY = <span class="string">"META-INF/dubbo/"</span>;</span><br /><span class="line">  <span class="number">4</span>: </span><br /><span class="line">  <span class="number">5</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + <span class="string">"internal/"</span>;</span><br /><span class="line">  <span class="number">6</span>: </span><br /><span class="line">  <span class="number">7</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern NAME_SEPARATOR = Pattern.compile(<span class="string">"\\s*[,]+\\s*"</span>);</span><br /><span class="line">  <span class="number">8</span>: </span><br /><span class="line">  <span class="number">9</span>: <span class="comment">// ============================== 静态属性 ==============================</span></span><br /><span class="line"> <span class="number">10</span>: </span><br /><span class="line"> <span class="number">11</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 12:  * 拓展加载器集合</span></span><br /><span class="line"><span class="comment"> 13:  *</span></span><br /><span class="line"><span class="comment"> 14:  * key：拓展接口</span></span><br /><span class="line"><span class="comment"> 15:  */</span></span><br /><span class="line"> <span class="number">16</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();</span><br /><span class="line"> <span class="number">17</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 18:  * 拓展实现类集合</span></span><br /><span class="line"><span class="comment"> 19:  *</span></span><br /><span class="line"><span class="comment"> 20:  * key：拓展实现类</span></span><br /><span class="line"><span class="comment"> 21:  * value：拓展对象。</span></span><br /><span class="line"><span class="comment"> 22:  *</span></span><br /><span class="line"><span class="comment"> 23:  * 例如，key 为 Class&lt;AccessLogFilter&gt;</span></span><br /><span class="line"><span class="comment"> 24:  *  value 为 AccessLogFilter 对象</span></span><br /><span class="line"><span class="comment"> 25:  */</span></span><br /><span class="line"> <span class="number">26</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br /><span class="line"> <span class="number">27</span>: </span><br /><span class="line"> <span class="number">28</span>: <span class="comment">// ============================== 对象属性 ==============================</span></span><br /><span class="line"> <span class="number">29</span>: </span><br /><span class="line"> <span class="number">30</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 31:  * 拓展接口。</span></span><br /><span class="line"><span class="comment"> 32:  * 例如，Protocol</span></span><br /><span class="line"><span class="comment"> 33:  */</span></span><br /><span class="line"> <span class="number">34</span>: <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br /><span class="line"> <span class="number">35</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 36:  * 对象工厂</span></span><br /><span class="line"><span class="comment"> 37:  *</span></span><br /><span class="line"><span class="comment"> 38:  * 用于调用 {<span class="doctag">@link</span> #injectExtension(Object)} 方法，向拓展对象注入依赖属性。</span></span><br /><span class="line"><span class="comment"> 39:  *</span></span><br /><span class="line"><span class="comment"> 40:  * 例如，StubProxyFactoryWrapper 中有 `Protocol protocol` 属性。</span></span><br /><span class="line"><span class="comment"> 41:  */</span></span><br /><span class="line"> <span class="number">42</span>: <span class="keyword">private</span> <span class="keyword">final</span> ExtensionFactory objectFactory;</span><br /><span class="line"> <span class="number">43</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 44:  * 缓存的拓展名与拓展类的映射。</span></span><br /><span class="line"><span class="comment"> 45:  *</span></span><br /><span class="line"><span class="comment"> 46:  * 和 {<span class="doctag">@link</span> #cachedClasses} 的 KV 对调。</span></span><br /><span class="line"><span class="comment"> 47:  *</span></span><br /><span class="line"><span class="comment"> 48:  * 通过 {<span class="doctag">@link</span> #loadExtensionClasses} 加载</span></span><br /><span class="line"><span class="comment"> 49:  */</span></span><br /><span class="line"> <span class="number">50</span>: <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br /><span class="line"> <span class="number">51</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 52:  * 缓存的拓展实现类集合。</span></span><br /><span class="line"><span class="comment"> 53:  *</span></span><br /><span class="line"><span class="comment"> 54:  * 不包含如下两种类型：</span></span><br /><span class="line"><span class="comment"> 55:  *  1. 自适应拓展实现类。例如 AdaptiveExtensionFactory</span></span><br /><span class="line"><span class="comment"> 56:  *  2. 带唯一参数为拓展接口的构造方法的实现类，或者说拓展 Wrapper 实现类。例如，ProtocolFilterWrapper 。</span></span><br /><span class="line"><span class="comment"> 57:  *   拓展 Wrapper 实现类，会添加到 {<span class="doctag">@link</span> #cachedWrapperClasses} 中</span></span><br /><span class="line"><span class="comment"> 58:  *</span></span><br /><span class="line"><span class="comment"> 59:  * 通过 {<span class="doctag">@link</span> #loadExtensionClasses} 加载</span></span><br /><span class="line"><span class="comment"> 60:  */</span></span><br /><span class="line"> <span class="number">61</span>: <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();</span><br /><span class="line"> <span class="number">62</span>: </span><br /><span class="line"> <span class="number">63</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 64:  * 拓展名与 <span class="doctag">@Activate</span> 的映射</span></span><br /><span class="line"><span class="comment"> 65:  *</span></span><br /><span class="line"><span class="comment"> 66:  * 例如，AccessLogFilter。</span></span><br /><span class="line"><span class="comment"> 67:  *</span></span><br /><span class="line"><span class="comment"> 68:  * 用于 {<span class="doctag">@link</span> #getActivateExtension(URL, String)}</span></span><br /><span class="line"><span class="comment"> 69:  */</span></span><br /><span class="line"> <span class="number">70</span>: <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Activate&gt; cachedActivates = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Activate&gt;();</span><br /><span class="line"> <span class="number">71</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 72:  * 缓存的拓展对象集合</span></span><br /><span class="line"><span class="comment"> 73:  *</span></span><br /><span class="line"><span class="comment"> 74:  * key：拓展名</span></span><br /><span class="line"><span class="comment"> 75:  * value：拓展对象</span></span><br /><span class="line"><span class="comment"> 76:  *</span></span><br /><span class="line"><span class="comment"> 77:  * 例如，Protocol 拓展</span></span><br /><span class="line"><span class="comment"> 78:  *      key：dubbo value：DubboProtocol</span></span><br /><span class="line"><span class="comment"> 79:  *      key：injvm value：InjvmProtocol</span></span><br /><span class="line"><span class="comment"> 80:  *</span></span><br /><span class="line"><span class="comment"> 81:  * 通过 {<span class="doctag">@link</span> #loadExtensionClasses} 加载</span></span><br /><span class="line"><span class="comment"> 82:  */</span></span><br /><span class="line"> <span class="number">83</span>: <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();</span><br /><span class="line"> <span class="number">84</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 85:  * 缓存的自适应( Adaptive )拓展对象</span></span><br /><span class="line"><span class="comment"> 86:  */</span></span><br /><span class="line"> <span class="number">87</span>: <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;Object&gt;();</span><br /><span class="line"> <span class="number">88</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 89:  * 缓存的自适应拓展对象的类</span></span><br /><span class="line"><span class="comment"> 90:  *</span></span><br /><span class="line"><span class="comment"> 91:  * {<span class="doctag">@link</span> #getAdaptiveExtensionClass()}</span></span><br /><span class="line"><span class="comment"> 92:  */</span></span><br /><span class="line"> <span class="number">93</span>: <span class="keyword">private</span> <span class="keyword">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br /><span class="line"> <span class="number">94</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 95:  * 缓存的默认拓展名</span></span><br /><span class="line"><span class="comment"> 96:  *</span></span><br /><span class="line"><span class="comment"> 97:  * 通过 {<span class="doctag">@link</span> SPI} 注解获得</span></span><br /><span class="line"><span class="comment"> 98:  */</span></span><br /><span class="line"> <span class="number">99</span>: <span class="keyword">private</span> String cachedDefaultName;</span><br /><span class="line"><span class="number">100</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">101:  * 创建 {<span class="doctag">@link</span> #cachedAdaptiveInstance} 时发生的异常。</span></span><br /><span class="line"><span class="comment">102:  *</span></span><br /><span class="line"><span class="comment">103:  * 发生异常后，不再创建，参见 {<span class="doctag">@link</span> #createAdaptiveExtension()}</span></span><br /><span class="line"><span class="comment">104:  */</span></span><br /><span class="line"><span class="number">105</span>: <span class="keyword">private</span> <span class="keyword">volatile</span> Throwable createAdaptiveInstanceError;</span><br /><span class="line"><span class="number">106</span>: </span><br /><span class="line"><span class="number">107</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">108:  * 拓展 Wrapper 实现类集合</span></span><br /><span class="line"><span class="comment">109:  *</span></span><br /><span class="line"><span class="comment">110:  * 带唯一参数为拓展接口的构造方法的实现类</span></span><br /><span class="line"><span class="comment">111:  *</span></span><br /><span class="line"><span class="comment">112:  * 通过 {<span class="doctag">@link</span> #loadExtensionClasses} 加载</span></span><br /><span class="line"><span class="comment">113:  */</span></span><br /><span class="line"><span class="number">114</span>: <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br /><span class="line"><span class="number">115</span>: </span><br /><span class="line"><span class="number">116</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">117:  * 拓展名 与 加载对应拓展类发生的异常 的 映射</span></span><br /><span class="line"><span class="comment">118:  *</span></span><br /><span class="line"><span class="comment">119:  * key：拓展名</span></span><br /><span class="line"><span class="comment">120:  * value：异常</span></span><br /><span class="line"><span class="comment">121:  *</span></span><br /><span class="line"><span class="comment">122:  * 在 {<span class="doctag">@link</span> #loadFile(Map, String)} 时，记录</span></span><br /><span class="line"><span class="comment">123:  */</span></span><br /><span class="line"><span class="number">124</span>: <span class="keyword">private</span> Map&lt;String, IllegalStateException&gt; exceptions = <span class="keyword">new</span> ConcurrentHashMap&lt;String, IllegalStateException&gt;();</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 1 至 5 行：在&nbsp;<code>META-INF/dubbo/internal/</code>&nbsp;和&nbsp;<code>META-INF/dubbo/</code>&nbsp;目录下，放置&nbsp;<strong>接口全限定名</strong>&nbsp;配置文件，<strong>每行</strong>内容为：<strong>拓展名=拓展实现类全限定名</strong>。
<ul>
<li><code>META-INF/dubbo/internal/</code>&nbsp;目录下，从名字上可以看出，用于 Dubbo&nbsp;<strong>内部</strong>提供的拓展实现。下图是一个例子：<img src="http://static2.iocoder.cn/images/Dubbo/2018_03_04/03.png" alt="META-INF/dubbo/internal/ 例子" /></li>
<li><code>META-INF/dubbo/</code>&nbsp;目录下，用于用户<strong>自定义</strong>的拓展实现。</li>
<li><code>META-INF/service/</code>&nbsp;目录下，Java SPI 的配置目录。在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「4.2 加载拓展配置」</a>&nbsp;中，我们会看到 Dubbo SPI 对 Java SPI 做了<strong>兼容</strong>。</li>
</ul>
</li>
<li>第 7 行：<code>NAME_SEPARATOR</code>&nbsp;，拓展名分隔符，使用<strong>逗号</strong>。</li>
<li><strong>第 9 至 124 行</strong>，我们将属性分成了两类：1）静态属性；2）对象属性。这是为啥呢？
<ul>
<li>【静态属性】一方面，ExtensionLoader 是 ExtensionLoader 的<strong>管理容器</strong>。一个拓展( 拓展接口 )对应一个 ExtensionLoader 对象。例如，Protocol 和 Filter&nbsp;<strong>分别</strong>对应一个 ExtensionLoader 对象。</li>
<li>【对象属性】另一方面，一个拓展通过其 ExtensionLoader 对象，加载它的<strong>拓展实现们</strong>。我们会发现多个属性都是 &ldquo;<strong>cached</strong>&ldquo; 开头。ExtensionLoader 考虑到性能和资源的优化，读取拓展配置后，会首先进行<strong>缓存</strong>。等到 Dubbo 代码<strong>真正</strong>用到对应的拓展实现时，进行拓展实现的对象的初始化。并且，初始化完成后，也会进行<strong>缓存</strong>。也就是说：
<ul>
<li>缓存加载的拓展配置</li>
<li>缓存创建的拓展实现对象</li>
</ul>
</li>
</ul>
</li>
<li>🙂 胖友先看下属性的代码注释，有一个整体的印象。下面我们在读实现代码时，会进一步解析说明。</li>
</ul>
<hr />
<p>考虑到胖友能更好的理解下面的代码实现，推荐先阅读下&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/dev/SPI.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 开发指南 &mdash;&mdash; 扩展点加载》</a>&nbsp;文档，建立下对 ExtensionLoader 特点的初步理解：</p>
<ul>
<li>扩展点自动包装
<ul>
<li>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「4.4.2 createExtension」</a>&nbsp;详细解析。</li>
</ul>
</li>
<li>扩展点自动装配
<ul>
<li>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「4.4.3 injectExtension」</a>&nbsp;详细解析。</li>
</ul>
</li>
<li>扩展点自适应
<ul>
<li>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「4.5 获得自适应的拓展对象」</a>&nbsp;详细解析。</li>
</ul>
</li>
<li>扩展点自动激活
<ul>
<li>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「4.6 获得激活的拓展对象数组」</a>&nbsp;详细解析。</li>
</ul>
</li>
</ul>
<h2 id="4-2-获得拓展配置">4.2 获得拓展配置</h2>
<h3 id="4-2-1-getExtensionClasses">4.2.1 getExtensionClasses</h3>
<p><code>#getExtensionClasses()</code>&nbsp;方法，获得拓展实现类数组。</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();</span><br /><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br /><br /><span class="line"><span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  2:  * 获得拓展实现类数组</span></span><br /><span class="line"><span class="comment">  3:  *</span></span><br /><span class="line"><span class="comment">  4:  * <span class="doctag">@return</span> 拓展实现类数组</span></span><br /><span class="line"><span class="comment">  5:  */</span></span><br /><span class="line">  <span class="number">6</span>: <span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() {</span><br /><span class="line">  <span class="number">7</span>:     <span class="comment">// 从缓存中，获得拓展实现类数组</span></span><br /><span class="line">  <span class="number">8</span>:     Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br /><span class="line">  <span class="number">9</span>:     <span class="keyword">if</span> (classes == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">10</span>:         <span class="keyword">synchronized</span> (cachedClasses) {</span><br /><span class="line"> <span class="number">11</span>:             classes = cachedClasses.get();</span><br /><span class="line"> <span class="number">12</span>:             <span class="keyword">if</span> (classes == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">13</span>:                 <span class="comment">// 从配置文件中，加载拓展实现类数组</span></span><br /><span class="line"> <span class="number">14</span>:                 classes = loadExtensionClasses();</span><br /><span class="line"> <span class="number">15</span>:                 <span class="comment">// 设置到缓存中</span></span><br /><span class="line"> <span class="number">16</span>:                 cachedClasses.set(classes);</span><br /><span class="line"> <span class="number">17</span>:             }</span><br /><span class="line"> <span class="number">18</span>:         }</span><br /><span class="line"> <span class="number">19</span>:     }</span><br /><span class="line"> <span class="number">20</span>:     <span class="keyword">return</span> classes;</span><br /><span class="line"> <span class="number">21</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>cachedClasses</code>&nbsp;属性，缓存的拓展实现类集合。它不包含如下两种类型的拓展实现：
<ul>
<li><strong>自适应</strong>拓展实现类。例如 AdaptiveExtensionFactory 。
<ul>
<li>拓展 Adaptive 实现类，会添加到&nbsp;<code>cachedAdaptiveClass</code>&nbsp;属性中。</li>
</ul>
</li>
<li>带<strong>唯一参数为拓展接口</strong>的构造方法的实现类，或者说拓展 Wrapper 实现类。例如，ProtocolFilterWrapper 。
<ul>
<li>拓展 Wrapper 实现类，会添加到&nbsp;<code>cachedWrapperClasses</code>&nbsp;属性中。</li>
</ul>
</li>
<li>总结来说，<code>cachedClasses</code>&nbsp;+&nbsp;<code>cachedAdaptiveClass</code>&nbsp;+&nbsp;<code>cachedWrapperClasses</code>&nbsp;才是<strong>完整</strong>缓存的拓展实现类的配置。</li>
</ul>
</li>
<li>第 7 至 11 行：从缓存中，获得拓展实现类数组。</li>
<li>第 12 至 14 行：当缓存不存在时，调用&nbsp;<code>#loadExtensionClasses()</code>&nbsp;方法，从配置文件中，加载拓展实现类数组。</li>
<li>第 16 行：设置加载的实现类数组，到缓存中。</li>
</ul>
<h3 id="4-2-2-loadExtensionClasses">4.2.2 loadExtensionClasses</h3>
<p><code>#loadExtensionClasses()</code>&nbsp;方法，从<strong>多个</strong>配置文件中，加载拓展实现类数组。</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 加载拓展实现类数组</span></span><br /><span class="line"><span class="comment"> 3:  *</span></span><br /><span class="line"><span class="comment"> 4:  * 无需声明 synchronized ，因为唯一调用该方法的 {<span class="doctag">@link</span> #getExtensionClasses()} 已经声明。</span></span><br /><span class="line"><span class="comment"> 5:  * // synchronized in getExtensionClasses</span></span><br /><span class="line"><span class="comment"> 6:  *</span></span><br /><span class="line"><span class="comment"> 7:  * <span class="doctag">@return</span> 拓展实现类数组</span></span><br /><span class="line"><span class="comment"> 8:  */</span></span><br /><span class="line"> <span class="number">9</span>: <span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {</span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// 通过 @SPI 注解，获得默认的拓展实现类名</span></span><br /><span class="line"><span class="number">11</span>:     <span class="keyword">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);</span><br /><span class="line"><span class="number">12</span>:     <span class="keyword">if</span> (defaultAnnotation != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">13</span>:         String value = defaultAnnotation.value();</span><br /><span class="line"><span class="number">14</span>:         <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">15</span>:             String[] names = NAME_SEPARATOR.split(value);</span><br /><span class="line"><span class="number">16</span>:             <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) {</span><br /><span class="line"><span class="number">17</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"more than 1 default extension name on extension "</span> + type.getName()</span><br /><span class="line"><span class="number">18</span>:                         + <span class="string">": "</span> + Arrays.toString(names));</span><br /><span class="line"><span class="number">19</span>:             }</span><br /><span class="line"><span class="number">20</span>:             <span class="keyword">if</span> (names.length == <span class="number">1</span>) cachedDefaultName = names[<span class="number">0</span>];</span><br /><span class="line"><span class="number">21</span>:         }</span><br /><span class="line"><span class="number">22</span>:     }</span><br /><span class="line"><span class="number">23</span>: </span><br /><span class="line"><span class="number">24</span>:     <span class="comment">// 从配置文件中，加载拓展实现类数组</span></span><br /><span class="line"><span class="number">25</span>:     Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br /><span class="line"><span class="number">26</span>:     loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br /><span class="line"><span class="number">27</span>:     loadFile(extensionClasses, DUBBO_DIRECTORY);</span><br /><span class="line"><span class="number">28</span>:     loadFile(extensionClasses, SERVICES_DIRECTORY);</span><br /><span class="line"><span class="number">29</span>:     <span class="keyword">return</span> extensionClasses;</span><br /><span class="line"><span class="number">30</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 10 至 22 行：通过&nbsp;<code>@SPI</code>&nbsp;注解，获得拓展接口对应的<strong>默认的</strong>拓展实现类名。在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「5. @SPI」</a>&nbsp;详细解析。</li>
<li>第 25 至 29 行：调用&nbsp;<code>#loadFile(extensionClasses, dir)</code>&nbsp;方法，从配置文件中，加载拓展实现类数组。<strong>注意</strong>，此处配置文件的加载顺序。</li>
</ul>
<h3 id="4-2-3-loadFile">4.2.3 loadFile</h3>
<p><code>#loadFile(extensionClasses, dir)</code>&nbsp;方法，从<strong>一个</strong>配置文件中，加载拓展实现类数组。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 缓存的自适应拓展对象的类</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #getAdaptiveExtensionClass()}</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 拓展 Wrapper 实现类集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 带唯一参数为拓展接口的构造方法的实现类</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 通过 {<span class="doctag">@link</span> #loadExtensionClasses} 加载</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 拓展名与 <span class="doctag">@Activate</span> 的映射</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 例如，AccessLogFilter。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 用于 {<span class="doctag">@link</span> #getActivateExtension(URL, String)}</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Activate&gt; cachedActivates = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Activate&gt;();</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 缓存的拓展名与拓展类的映射。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 和 {<span class="doctag">@link</span> #cachedClasses} 的 KV 对调。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 通过 {<span class="doctag">@link</span> #loadExtensionClasses} 加载</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 拓展名 与 加载对应拓展类发生的异常 的 映射</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key：拓展名</span></span><br /><span class="line"><span class="comment"> * value：异常</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 在 {<span class="doctag">@link</span> #loadFile(Map, String)} 时，记录</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Map&lt;String, IllegalStateException&gt; exceptions = <span class="keyword">new</span> ConcurrentHashMap&lt;String, IllegalStateException&gt;();</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  2:  * 从一个配置文件中，加载拓展实现类数组。</span></span><br /><span class="line"><span class="comment">  3:  *</span></span><br /><span class="line"><span class="comment">  4:  * <span class="doctag">@param</span> extensionClasses 拓展类名数组</span></span><br /><span class="line"><span class="comment">  5:  * <span class="doctag">@param</span> dir 文件名</span></span><br /><span class="line"><span class="comment">  6:  */</span></span><br /><span class="line">  <span class="number">7</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFile</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> </span>{</span><br /><span class="line">  <span class="number">8</span>:     <span class="comment">// 完整的文件名</span></span><br /><span class="line">  <span class="number">9</span>:     String fileName = dir + type.getName();</span><br /><span class="line"> <span class="number">10</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">11</span>:         Enumeration&lt;java.net.URL&gt; urls;</span><br /><span class="line"> <span class="number">12</span>:         <span class="comment">// 获得文件名对应的所有文件数组</span></span><br /><span class="line"> <span class="number">13</span>:         ClassLoader classLoader = findClassLoader();</span><br /><span class="line"> <span class="number">14</span>:         <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">15</span>:             urls = classLoader.getResources(fileName);</span><br /><span class="line"> <span class="number">16</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">17</span>:             urls = ClassLoader.getSystemResources(fileName);</span><br /><span class="line"> <span class="number">18</span>:         }</span><br /><span class="line"> <span class="number">19</span>:         <span class="comment">// 遍历文件数组</span></span><br /><span class="line"> <span class="number">20</span>:         <span class="keyword">if</span> (urls != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">21</span>:             <span class="keyword">while</span> (urls.hasMoreElements()) {</span><br /><span class="line"> <span class="number">22</span>:                 java.net.URL url = urls.nextElement();</span><br /><span class="line"> <span class="number">23</span>:                 <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">24</span>:                     BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(url.openStream(), <span class="string">"utf-8"</span>));</span><br /><span class="line"> <span class="number">25</span>:                     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">26</span>:                         String line;</span><br /><span class="line"> <span class="number">27</span>:                         <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">28</span>:                             <span class="comment">// 跳过当前被注释掉的情况，例如 #spring=xxxxxxxxx</span></span><br /><span class="line"> <span class="number">29</span>:                             <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">'#'</span>);</span><br /><span class="line"> <span class="number">30</span>:                             <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) line = line.substring(<span class="number">0</span>, ci);</span><br /><span class="line"> <span class="number">31</span>:                             line = line.trim();</span><br /><span class="line"> <span class="number">32</span>:                             <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">33</span>:                                 <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">34</span>:                                     <span class="comment">// 拆分，key=value 的配置格式</span></span><br /><span class="line"> <span class="number">35</span>:                                     String name = <span class="keyword">null</span>;</span><br /><span class="line"> <span class="number">36</span>:                                     <span class="keyword">int</span> i = line.indexOf(<span class="string">'='</span>);</span><br /><span class="line"> <span class="number">37</span>:                                     <span class="keyword">if</span> (i &gt; <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">38</span>:                                         name = line.substring(<span class="number">0</span>, i).trim();</span><br /><span class="line"> <span class="number">39</span>:                                         line = line.substring(i + <span class="number">1</span>).trim();</span><br /><span class="line"> <span class="number">40</span>:                                     }</span><br /><span class="line"> <span class="number">41</span>:                                     <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">42</span>:                                         <span class="comment">// 判断拓展实现，是否实现拓展接口</span></span><br /><span class="line"> <span class="number">43</span>:                                         Class&lt;?&gt; clazz = Class.forName(line, <span class="keyword">true</span>, classLoader);</span><br /><span class="line"> <span class="number">44</span>:                                         <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) {</span><br /><span class="line"> <span class="number">45</span>:                                             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error when load extension class(interface: "</span> +</span><br /><span class="line"> <span class="number">46</span>:                                                     type + <span class="string">", class line: "</span> + clazz.getName() + <span class="string">"), class "</span></span><br /><span class="line"> <span class="number">47</span>:                                                     + clazz.getName() + <span class="string">"is not subtype of interface."</span>);</span><br /><span class="line"> <span class="number">48</span>:                                         }</span><br /><span class="line"> <span class="number">49</span>:                                         <span class="comment">// 缓存自适应拓展对象的类到 `cachedAdaptiveClass`</span></span><br /><span class="line"> <span class="number">50</span>:                                         <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) {</span><br /><span class="line"> <span class="number">51</span>:                                             <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">52</span>:                                                 cachedAdaptiveClass = clazz;</span><br /><span class="line"> <span class="number">53</span>:                                             } <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) {</span><br /><span class="line"> <span class="number">54</span>:                                                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"More than 1 adaptive class found: "</span></span><br /><span class="line"> <span class="number">55</span>:                                                         + cachedAdaptiveClass.getClass().getName()</span><br /><span class="line"> <span class="number">56</span>:                                                         + <span class="string">", "</span> + clazz.getClass().getName());</span><br /><span class="line"> <span class="number">57</span>:                                             }</span><br /><span class="line"> <span class="number">58</span>:                                         } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">59</span>:                                             <span class="comment">// 缓存拓展 Wrapper 实现类到 `cachedWrapperClasses`</span></span><br /><span class="line"> <span class="number">60</span>:                                             <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">61</span>:                                                 clazz.getConstructor(type);</span><br /><span class="line"> <span class="number">62</span>:                                                 Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br /><span class="line"> <span class="number">63</span>:                                                 <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">64</span>:                                                     cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br /><span class="line"> <span class="number">65</span>:                                                     wrappers = cachedWrapperClasses;</span><br /><span class="line"> <span class="number">66</span>:                                                 }</span><br /><span class="line"> <span class="number">67</span>:                                                 wrappers.add(clazz);</span><br /><span class="line"> <span class="number">68</span>:                                             <span class="comment">// 缓存拓展实现类到 `extensionClasses`</span></span><br /><span class="line"> <span class="number">69</span>:                                             } <span class="keyword">catch</span> (NoSuchMethodException e) {</span><br /><span class="line"> <span class="number">70</span>:                                                 clazz.getConstructor();</span><br /><span class="line"> <span class="number">71</span>:                                                 <span class="comment">// 未配置拓展名，自动生成。例如，DemoFilter 为 demo 。主要用于兼容 Java SPI 的配置。</span></span><br /><span class="line"> <span class="number">72</span>:                                                 <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">73</span>:                                                     name = findAnnotationName(clazz);</span><br /><span class="line"> <span class="number">74</span>:                                                     <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">75</span>:                                                         <span class="keyword">if</span> (clazz.getSimpleName().length() &gt; type.getSimpleName().length()</span><br /><span class="line"> <span class="number">76</span>:                                                                 &amp;&amp; clazz.getSimpleName().endsWith(type.getSimpleName())) {</span><br /><span class="line"> <span class="number">77</span>:                                                             name = clazz.getSimpleName().substring(<span class="number">0</span>, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();</span><br /><span class="line"> <span class="number">78</span>:                                                         } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">79</span>:                                                             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension name for the class "</span> + clazz.getName() + <span class="string">" in the config "</span> + url);</span><br /><span class="line"> <span class="number">80</span>:                                                         }</span><br /><span class="line"> <span class="number">81</span>:                                                     }</span><br /><span class="line"> <span class="number">82</span>:                                                 }</span><br /><span class="line"> <span class="number">83</span>:                                                 <span class="comment">// 获得拓展名，可以是数组，有多个拓展名。</span></span><br /><span class="line"> <span class="number">84</span>:                                                 String[] names = NAME_SEPARATOR.split(name);</span><br /><span class="line"> <span class="number">85</span>:                                                 <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">86</span>:                                                     <span class="comment">// 缓存 @Activate 到 `cachedActivates` 。</span></span><br /><span class="line"> <span class="number">87</span>:                                                     Activate activate = clazz.getAnnotation(Activate.class);</span><br /><span class="line"> <span class="number">88</span>:                                                     <span class="keyword">if</span> (activate != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">89</span>:                                                         cachedActivates.put(names[<span class="number">0</span>], activate);</span><br /><span class="line"> <span class="number">90</span>:                                                     }</span><br /><span class="line"> <span class="number">91</span>:                                                     <span class="keyword">for</span> (String n : names) {</span><br /><span class="line"> <span class="number">92</span>:                                                         <span class="comment">// 缓存到 `cachedNames`</span></span><br /><span class="line"> <span class="number">93</span>:                                                         <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) {</span><br /><span class="line"> <span class="number">94</span>:                                                             cachedNames.put(clazz, n);</span><br /><span class="line"> <span class="number">95</span>:                                                         }</span><br /><span class="line"> <span class="number">96</span>:                                                         <span class="comment">// 缓存拓展实现类到 `extensionClasses`</span></span><br /><span class="line"> <span class="number">97</span>:                                                         Class&lt;?&gt; c = extensionClasses.get(n);</span><br /><span class="line"> <span class="number">98</span>:                                                         <span class="keyword">if</span> (c == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">99</span>:                                                             extensionClasses.put(n, clazz);</span><br /><span class="line"><span class="number">100</span>:                                                         } <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) {</span><br /><span class="line"><span class="number">101</span>:                                                             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate extension "</span> + type.getName() + <span class="string">" name "</span> + n + <span class="string">" on "</span> + c.getName() + <span class="string">" and "</span> + clazz.getName());</span><br /><span class="line"><span class="number">102</span>:                                                         }</span><br /><span class="line"><span class="number">103</span>:                                                     }</span><br /><span class="line"><span class="number">104</span>:                                                 }</span><br /><span class="line"><span class="number">105</span>:                                             }</span><br /><span class="line"><span class="number">106</span>:                                         }</span><br /><span class="line"><span class="number">107</span>:                                     }</span><br /><span class="line"><span class="number">108</span>:                                 } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">109</span>:                                     <span class="comment">// 发生异常，记录到异常集合</span></span><br /><span class="line"><span class="number">110</span>:                                     IllegalStateException e = <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to load extension class(interface: "</span> + type + <span class="string">", class line: "</span> + line + <span class="string">") in "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br /><span class="line"><span class="number">111</span>:                                     exceptions.put(line, e);</span><br /><span class="line"><span class="number">112</span>:                                 }</span><br /><span class="line"><span class="number">113</span>:                             }</span><br /><span class="line"><span class="number">114</span>:                         } <span class="comment">// end of while read lines</span></span><br /><span class="line"><span class="number">115</span>:                     } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">116</span>:                         reader.close();</span><br /><span class="line"><span class="number">117</span>:                     }</span><br /><span class="line"><span class="number">118</span>:                 } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">119</span>:                     logger.error(<span class="string">"Exception when load extension class(interface: "</span> +</span><br /><span class="line"><span class="number">120</span>:                             type + <span class="string">", class file: "</span> + url + <span class="string">") in "</span> + url, t);</span><br /><span class="line"><span class="number">121</span>:                 }</span><br /><span class="line"><span class="number">122</span>:             } <span class="comment">// end of while urls</span></span><br /><span class="line"><span class="number">123</span>:         }</span><br /><span class="line"><span class="number">124</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">125</span>:         logger.error(<span class="string">"Exception when load extension class(interface: "</span> +</span><br /><span class="line"><span class="number">126</span>:                 type + <span class="string">", description file: "</span> + fileName + <span class="string">")."</span>, t);</span><br /><span class="line"><span class="number">127</span>:     }</span><br /><span class="line"><span class="number">128</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 9 行：获得完整的文件名( 相对路径 )。例如：<code>"META-INF/dubbo/internal/com.alibaba.dubbo.common.extension.ExtensionFactory"</code>&nbsp;。</li>
<li>第 12 至 18 行：获得文件名对应的所有文件 URL 数组。例如：<img src="http://static2.iocoder.cn/images/Dubbo/2018_03_04/04.png" alt="ExtensionFactory 的配置文件" /></li>
<li>第 21 至 24 行：逐个<strong>文件</strong>&nbsp;URL 遍历。</li>
<li>第 27 行：逐<strong>行</strong>遍历。</li>
<li>第 29 至 32 行：跳过当前被&nbsp;<code>"#"</code>&nbsp;注释掉的情况，例如&nbsp;<code>#spring=xxxxxxxxx</code>&nbsp;。</li>
<li>第 34 至 40 行：按照&nbsp;<code>key=value</code>&nbsp;的配置拆分。其中&nbsp;<code>name</code>&nbsp;为拓展名，<code>line</code>&nbsp;为拓展实现类名。<strong>注意</strong>，上文我们提到过 Dubbo SPI 会兼容 Java SPI 的配置格式，那么按照此处的解析方式，<code>name</code>&nbsp;会为空。这种情况下，拓展名会自动生成，详细见第 71 至 82 行的代码。</li>
<li>第 42 至 48 行：判断拓展实现类，需要实现拓展接口。</li>
<li>第 50 至 57 行：缓存自适应拓展对象的类到&nbsp;<code>cachedAdaptiveClass</code>&nbsp;属性。在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「6. @Adaptive」</a>&nbsp;详细解析。</li>
<li>第 59 至 67 行：缓存拓展 Wrapper 实现类到&nbsp;<code>cachedWrapperClasses</code>&nbsp;属性。
<ul>
<li>第 61 行：调用&nbsp;<code>Class#getConstructor(Class&lt;?&gt;... parameterTypes)</code>&nbsp;方法，通过<strong>反射</strong>的方式，参数为拓展接口，判断当前配置的拓展实现类为<strong>拓展 Wrapper 实现类</strong>。若成功（未抛出异常），则代表符合条件。例如，<a href="https://github.com/alibaba/dubbo/blob/master/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper.java#L39-L44" target="_blank" rel="external nofollow noopener noreferrer">ProtocolFilterWrapper(Protocol protocol)</a>&nbsp;这个构造方法。</li>
</ul>
</li>
<li>第 69 至 105 行：若获得构造方法失败，则代表是普通的拓展实现类，缓存到&nbsp;<code>extensionClasses</code>&nbsp;<strong>变量</strong>中。
<ul>
<li>第 70 行：调用&nbsp;<code>Class#getConstructor(Class&lt;?&gt;... parameterTypes)</code>&nbsp;方法，获得参数为空的构造方法。</li>
<li>第 72 至 82 行：未配置拓展名，自动生成。<strong>适用于 Java SPI 的配置方式</strong>。例如，xxx.yyy.DemoFilter 生成的拓展名为&nbsp;<code>demo</code>&nbsp;。
<ul>
<li>第 73 行：通过&nbsp;<code>@Extension</code>&nbsp;注解的方式设置拓展名的方式已经<strong>废弃</strong>，胖友可以无视该方法。</li>
</ul>
</li>
</ul>
</li>
<li>第 84 行：获得拓展名。使用逗号进行分割，即多个拓展名可以对应同一个拓展实现类。</li>
<li>第 86 至 90 行：缓存&nbsp;<code>@Activate</code>&nbsp;到&nbsp;<code>cachedActivates</code>&nbsp;。在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「7. @Activate」</a>&nbsp;详细解析。</li>
<li>第 93 至 95 行：缓存到&nbsp;<code>cachedNames</code>&nbsp;属性。</li>
<li>第 96 至 102 行：缓存拓展实现类到&nbsp;<code>extensionClasses</code>&nbsp;变量。<strong>注意</strong>，相同拓展名，不能对应多个不同的拓展实现。</li>
<li>第 108 至 112 行：若发生异常，记录到异常集合&nbsp;<code>exceptions</code>&nbsp;属性。</li>
</ul>
<h3 id="4-2-4-其他方法">4.2.4 其他方法</h3>
<p>如下方法，和该流程无关，胖友可自行查看。</p>
<ul>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L537-L546" target="_blank" rel="external nofollow noopener noreferrer"><code>#getExtensionClass(name)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L459-L482" target="_blank" rel="external nofollow noopener noreferrer"><code>#findException(name)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L129-L131" target="_blank" rel="external nofollow noopener noreferrer"><code>#getExtensionName(extensionInstance)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L133-L135" target="_blank" rel="external nofollow noopener noreferrer"><code>#getExtensionName(extensionClass)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L277-L286" target="_blank" rel="external nofollow noopener noreferrer"><code>#getSupportedExtensions()</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L344-L350" target="_blank" rel="external nofollow noopener noreferrer"><code>#getDefaultExtensionName()</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L337" target="_blank" rel="external nofollow noopener noreferrer"><code>#hasExtension(name)</code></a></li>
</ul>
<h2 id="4-3-获得拓展加载器">4.3 获得拓展加载器</h2>
<p>在 Dubbo 的代码里，常常能看到如下的代码：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name)</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="4-3-1-getExtensionLoader">4.3.1 getExtensionLoader</h3>
<p><code>#getExtensionLoader(type)</code>&nbsp;<strong>静态</strong>方法，根据拓展点的接口，获得拓展加载器。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 拓展加载器集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key：拓展接口</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"> <span class="comment">// 【静态属性】</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;(); </span><br /><br /><span class="line">  <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  2:  * 根据拓展点的接口，获得拓展加载器</span></span><br /><span class="line"><span class="comment">  3:  *</span></span><br /><span class="line"><span class="comment">  4:  * <span class="doctag">@param</span> type 接口</span></span><br /><span class="line"><span class="comment">  5:  * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br /><span class="line"><span class="comment">  6:  * <span class="doctag">@return</span> 加载器</span></span><br /><span class="line"><span class="comment">  7:  */</span></span><br /><span class="line">  <span class="number">8</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br /><span class="line">  <span class="number">9</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>{</span><br /><span class="line"> <span class="number">10</span>:     <span class="keyword">if</span> (type == <span class="keyword">null</span>)</span><br /><span class="line"> <span class="number">11</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type == null"</span>);</span><br /><span class="line"> <span class="number">12</span>:     <span class="comment">// 必须是接口</span></span><br /><span class="line"> <span class="number">13</span>:     <span class="keyword">if</span> (!type.isInterface()) {</span><br /><span class="line"> <span class="number">14</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type("</span> + type + <span class="string">") is not interface!"</span>);</span><br /><span class="line"> <span class="number">15</span>:     }</span><br /><span class="line"> <span class="number">16</span>:     <span class="comment">// 必须包含 @SPI 注解</span></span><br /><span class="line"> <span class="number">17</span>:     <span class="keyword">if</span> (!withExtensionAnnotation(type)) {</span><br /><span class="line"> <span class="number">18</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type("</span> + type +</span><br /><span class="line"> <span class="number">19</span>:                 <span class="string">") is not extension, because WITHOUT @"</span> + SPI.class.getSimpleName() + <span class="string">" Annotation!"</span>);</span><br /><span class="line"> <span class="number">20</span>:     }</span><br /><span class="line"> <span class="number">21</span>: </span><br /><span class="line"> <span class="number">22</span>:     <span class="comment">// 获得接口对应的拓展点加载器</span></span><br /><span class="line"> <span class="number">23</span>:     ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br /><span class="line"> <span class="number">24</span>:     <span class="keyword">if</span> (loader == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">25</span>:         EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br /><span class="line"> <span class="number">26</span>:         loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br /><span class="line"> <span class="number">27</span>:     }</span><br /><span class="line"> <span class="number">28</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 12 至 15 行：必须是接口。</li>
<li>第 16 至 20 行：调用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L101-L103" target="_blank" rel="external nofollow noopener noreferrer"><code>#withExtensionAnnotation()</code></a>&nbsp;方法，校验必须使用&nbsp;<code>@SPI</code>&nbsp;注解标记。</li>
<li>第 22 至 27 行：从&nbsp;<code>EXTENSION_LOADERS</code>&nbsp;<strong>静态</strong>中获取拓展接口对应的 ExtensionLoader 对象。若不存在，则创建 ExtensionLoader 对象，并添加到&nbsp;<code>EXTENSION_LOADERS</code>。</li>
</ul>
<h3 id="4-3-2-构造方法">4.3.2 构造方法</h3>
<p>构造方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 拓展接口。</span></span><br /><span class="line"><span class="comment"> * 例如，Protocol</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 对象工厂</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 用于调用 {<span class="doctag">@link</span> #injectExtension(Object)} 方法，向拓展对象注入依赖属性。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 例如，StubProxyFactoryWrapper 中有 `Protocol protocol` 属性。</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExtensionFactory objectFactory;</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>{</span><br /><span class="line">  <span class="number">2</span>:     <span class="keyword">this</span>.type = type;</span><br /><span class="line">  <span class="number">3</span>:     objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br /><span class="line">  <span class="number">4</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>objectFactory</code>&nbsp;属性，对象工厂，<strong>功能上和 Spring IOC 一致</strong>。
<ul>
<li>用于调用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L510-L535" target="_blank" rel="external nofollow noopener noreferrer"><code>#injectExtension(instance)</code></a>&nbsp;方法时，向创建的拓展注入其依赖的属性。例如，<a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-filter/dubbo-filter-cache/src/main/java/com/alibaba/dubbo/cache/filter/CacheFilter.java#L38" target="_blank" rel="external nofollow noopener noreferrer"><code>CacheFilter.cacheFactory</code></a>&nbsp;属性。</li>
<li>第 3 行：当拓展接口非 ExtensionFactory 时( 如果不加这个判断，会是一个死循环 )，调用&nbsp;<code>ExtensionLoader#getAdaptiveExtension()</code>&nbsp;方法，获得 ExtensionFactory 拓展接口的<strong>自适应</strong>拓展实现对象。<strong>为什么呢</strong>？在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「8. ExtensionFactory」</a>&nbsp;详细解析。</li>
</ul>
</li>
</ul>
<h2 id="4-4-获得指定拓展对象">4.4 获得指定拓展对象</h2>
<p>在 Dubbo 的代码里，常常能看到如下的代码：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name)</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="4-4-1-getExtension">4.4.1 getExtension</h3>
<p><code>#getExtension()</code>&nbsp;方法，返回指定名字的扩展对象。如果指定名字的扩展不存在，则抛异常 IllegalStateException 。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 缓存的拓展对象集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key：拓展名</span></span><br /><span class="line"><span class="comment"> * value：拓展对象</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 例如，Protocol 拓展</span></span><br /><span class="line"><span class="comment"> *          key：dubbo value：DubboProtocol</span></span><br /><span class="line"><span class="comment"> *          key：injvm value：InjvmProtocol</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 通过 {<span class="doctag">@link</span> #loadExtensionClasses} 加载</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  2:  * Find the extension with the given name. If the specified name is not found, then {<span class="doctag">@link</span> IllegalStateException}</span></span><br /><span class="line"><span class="comment">  3:  * will be thrown.</span></span><br /><span class="line"><span class="comment">  4:  */</span></span><br /><span class="line">  <span class="number">5</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  6:  * 返回指定名字的扩展对象。如果指定名字的扩展不存在，则抛异常 {<span class="doctag">@link</span> IllegalStateException}.</span></span><br /><span class="line"><span class="comment">  7:  *</span></span><br /><span class="line"><span class="comment">  8:  * <span class="doctag">@param</span> name 拓展名</span></span><br /><span class="line"><span class="comment">  9:  * <span class="doctag">@return</span> 拓展对象</span></span><br /><span class="line"><span class="comment"> 10:  */</span></span><br /><span class="line"> <span class="number">11</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br /><span class="line"> <span class="number">12</span>: <span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>{</span><br /><span class="line"> <span class="number">13</span>:     <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>)</span><br /><span class="line"> <span class="number">14</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br /><span class="line"> <span class="number">15</span>:     <span class="comment">// 查找 默认的 拓展对象</span></span><br /><span class="line"> <span class="number">16</span>:     <span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) {</span><br /><span class="line"> <span class="number">17</span>:         <span class="keyword">return</span> getDefaultExtension();</span><br /><span class="line"> <span class="number">18</span>:     }</span><br /><span class="line"> <span class="number">19</span>:     <span class="comment">// 从 缓存中 获得对应的拓展对象</span></span><br /><span class="line"> <span class="number">20</span>:     Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br /><span class="line"> <span class="number">21</span>:     <span class="keyword">if</span> (holder == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">22</span>:         cachedInstances.putIfAbsent(name, <span class="keyword">new</span> Holder&lt;Object&gt;());</span><br /><span class="line"> <span class="number">23</span>:         holder = cachedInstances.get(name);</span><br /><span class="line"> <span class="number">24</span>:     }</span><br /><span class="line"> <span class="number">25</span>:     Object instance = holder.get();</span><br /><span class="line"> <span class="number">26</span>:     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">27</span>:         <span class="keyword">synchronized</span> (holder) {</span><br /><span class="line"> <span class="number">28</span>:             instance = holder.get();</span><br /><span class="line"> <span class="number">29</span>:             <span class="comment">// 从 缓存中 未获取到，进行创建缓存对象。</span></span><br /><span class="line"> <span class="number">30</span>:             <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">31</span>:                 instance = createExtension(name);</span><br /><span class="line"> <span class="number">32</span>:                 <span class="comment">// 设置创建对象到缓存中</span></span><br /><span class="line"> <span class="number">33</span>:                 holder.set(instance);</span><br /><span class="line"> <span class="number">34</span>:             }</span><br /><span class="line"> <span class="number">35</span>:         }</span><br /><span class="line"> <span class="number">36</span>:     }</span><br /><span class="line"> <span class="number">37</span>:     <span class="keyword">return</span> (T) instance;</span><br /><span class="line"> <span class="number">38</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 15 至 18 行：调用&nbsp;<code>#getDefaultExtension()</code>&nbsp;方法，查询<strong>默认的</strong>拓展对象。在该方法的实现代码中，简化代码为&nbsp;<code>getExtension(cachedDefaultName);</code>&nbsp;。</li>
<li>第 19 至 28 行：从缓存中，获得拓展对象。</li>
<li>第 29 至 31 行：当缓存不存在时，调用&nbsp;<code>#createExtension(name)</code>&nbsp;方法，创建拓展对象。</li>
<li>第 33 行：添加创建的拓展对象，到缓存中。</li>
</ul>
<h3 id="4-4-2-createExtension">4.4.2 createExtension</h3>
<p><code>#createExtension(name)</code>&nbsp;方法，创建拓展名的拓展对象，并缓存。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 拓展实现类集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key：拓展实现类</span></span><br /><span class="line"><span class="comment"> * value：拓展对象。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 例如，key 为 Class&lt;AccessLogFilter&gt;</span></span><br /><span class="line"><span class="comment"> *      value 为 AccessLogFilter 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br />    <br /><span class="line">  <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  2:  * 创建拓展名的拓展对象，并缓存。</span></span><br /><span class="line"><span class="comment">  3:  *</span></span><br /><span class="line"><span class="comment">  4:  * <span class="doctag">@param</span> name 拓展名</span></span><br /><span class="line"><span class="comment">  5:  * <span class="doctag">@return</span> 拓展对象</span></span><br /><span class="line"><span class="comment">  6:  */</span></span><br /><span class="line">  <span class="number">7</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br /><span class="line">  <span class="number">8</span>: <span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>{</span><br /><span class="line">  <span class="number">9</span>:     <span class="comment">// 获得拓展名对应的拓展实现类</span></span><br /><span class="line"> <span class="number">10</span>:     Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br /><span class="line"> <span class="number">11</span>:     <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">12</span>:         <span class="keyword">throw</span> findException(name); <span class="comment">// 抛出异常</span></span><br /><span class="line"> <span class="number">13</span>:     }</span><br /><span class="line"> <span class="number">14</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">15</span>:         <span class="comment">// 从缓存中，获得拓展对象。</span></span><br /><span class="line"> <span class="number">16</span>:         T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br /><span class="line"> <span class="number">17</span>:         <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">18</span>:             <span class="comment">// 当缓存不存在时，创建拓展对象，并添加到缓存中。</span></span><br /><span class="line"> <span class="number">19</span>:             EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br /><span class="line"> <span class="number">20</span>:             instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br /><span class="line"> <span class="number">21</span>:         }</span><br /><span class="line"> <span class="number">22</span>:         <span class="comment">// 注入依赖的属性</span></span><br /><span class="line"> <span class="number">23</span>:         injectExtension(instance);</span><br /><span class="line"> <span class="number">24</span>:         <span class="comment">// 创建 Wrapper 拓展对象</span></span><br /><span class="line"> <span class="number">25</span>:         Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br /><span class="line"> <span class="number">26</span>:         <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) {</span><br /><span class="line"> <span class="number">27</span>:             <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) {</span><br /><span class="line"> <span class="number">28</span>:                 instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br /><span class="line"> <span class="number">29</span>:             }</span><br /><span class="line"> <span class="number">30</span>:         }</span><br /><span class="line"> <span class="number">31</span>:         <span class="keyword">return</span> instance;</span><br /><span class="line"> <span class="number">32</span>:     } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"> <span class="number">33</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance(name: "</span> + name + <span class="string">", class: "</span> +</span><br /><span class="line"> <span class="number">34</span>:                 type + <span class="string">")  could not be instantiated: "</span> + t.getMessage(), t);</span><br /><span class="line"> <span class="number">35</span>:     }</span><br /><span class="line"> <span class="number">36</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 9 至 13 行：获得拓展名对应的拓展实现类。若不存在，调用&nbsp;<code>#findException(name)</code>&nbsp;方法，抛出异常。</li>
<li>第 16 行：从缓存&nbsp;<code>EXTENSION_INSTANCES</code>&nbsp;<strong>静态</strong>属性中，获得拓展对象。</li>
<li>第 17 至 21 行：当缓存不存在时，创建拓展对象，并添加到&nbsp;<code>EXTENSION_INSTANCES</code>&nbsp;中。因为&nbsp;<code>#getExtension(name)</code>&nbsp;方法中已经加&nbsp;<code>synchronized</code>&nbsp;修饰，所以此处不用同步。</li>
<li>第 23 行：调用&nbsp;<code>#injectExtension(instance)</code>&nbsp;方法，向创建的拓展注入其依赖的属性。</li>
<li>
<p>第 24 至 30 行：创建 Wrapper 拓展对象，将&nbsp;<code>instance</code>&nbsp;<strong>包装在其中</strong>。在&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/dev/SPI.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 开发指南 &mdash;&mdash; 扩展点加载》</a>&nbsp;文章中，如此介绍 Wrapper 类：</p>
<blockquote>
<p>Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。它的用途主要是用于从 ExtensionLoader 返回扩展点时，包装在真正的扩展点实现外。即从 ExtensionLoader 中返回的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类。</p>
<p>扩展点的 Wrapper 类可以有多个，也可以根据需要新增。</p>
<p>通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。</p>
</blockquote>
<ul>
<li>例如：<a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/listener/ListenerExporterWrapper.java" target="_blank" rel="external nofollow noopener noreferrer">ListenerExporterWrapper</a>、<a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper.java" target="_blank" rel="external nofollow noopener noreferrer">ProtocolFilterWrapper</a>&nbsp;。</li>
</ul>
</li>
</ul>
<h3 id="4-4-3-injectExtension">4.4.3 injectExtension</h3>
<p><code>#injectExtension(instance)</code>&nbsp;方法，注入依赖的属性。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 注入依赖的属性</span></span><br /><span class="line"><span class="comment"> 3:  *</span></span><br /><span class="line"><span class="comment"> 4:  * <span class="doctag">@param</span> instance 拓展对象</span></span><br /><span class="line"><span class="comment"> 5:  * <span class="doctag">@return</span> 拓展对象</span></span><br /><span class="line"><span class="comment"> 6:  */</span></span><br /><span class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>{</span><br /><span class="line"> <span class="number">8</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">10</span>:             <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) {</span><br /><span class="line"><span class="number">11</span>:                 <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br /><span class="line"><span class="number">12</span>:                         &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br /><span class="line"><span class="number">13</span>:                         &amp;&amp; Modifier.isPublic(method.getModifiers())) { <span class="comment">// setting &amp;&amp; public 方法</span></span><br /><span class="line"><span class="number">14</span>:                     <span class="comment">// 获得属性的类型</span></span><br /><span class="line"><span class="number">15</span>:                     Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br /><span class="line"><span class="number">16</span>:                     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">17</span>:                         <span class="comment">// 获得属性</span></span><br /><span class="line"><span class="number">18</span>:                         String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br /><span class="line"><span class="number">19</span>:                         <span class="comment">// 获得属性值</span></span><br /><span class="line"><span class="number">20</span>:                         Object object = objectFactory.getExtension(pt, property);</span><br /><span class="line"><span class="number">21</span>:                         <span class="comment">// 设置属性值</span></span><br /><span class="line"><span class="number">22</span>:                         <span class="keyword">if</span> (object != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">23</span>:                             method.invoke(instance, object);</span><br /><span class="line"><span class="number">24</span>:                         }</span><br /><span class="line"><span class="number">25</span>:                     } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line"><span class="number">26</span>:                         logger.error(<span class="string">"fail to inject via method "</span> + method.getName()</span><br /><span class="line"><span class="number">27</span>:                                 + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br /><span class="line"><span class="number">28</span>:                     }</span><br /><span class="line"><span class="number">29</span>:                 }</span><br /><span class="line"><span class="number">30</span>:             }</span><br /><span class="line"><span class="number">31</span>:         }</span><br /><span class="line"><span class="number">32</span>:     } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line"><span class="number">33</span>:         logger.error(e.getMessage(), e);</span><br /><span class="line"><span class="number">34</span>:     }</span><br /><span class="line"><span class="number">35</span>:     <span class="keyword">return</span> instance;</span><br /><span class="line"><span class="number">36</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 9 行：必须有&nbsp;<code>objectFactory</code>&nbsp;属性，即 ExtensionFactory 的拓展对象，不需要注入依赖的属性。</li>
<li>第 10 至 13 行：反射获得所有的方法，仅仅处理&nbsp;<code>public setting</code>&nbsp;方法。</li>
<li>第 15 行：获得属性的类型。</li>
<li>第 18 行：获得属性名。</li>
<li>第 20 行：获得<strong>属性值</strong>。<strong>注意</strong>，此处虽然调用的是&nbsp;<code>ExtensionFactory#getExtension(type, name)</code>&nbsp;方法，实际获取的不仅仅是拓展对象，也可以是 Spring Bean 对象。答案在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「8. ExtensionFactory」</a>&nbsp;揭晓。</li>
<li>第 21 至 24 行：设置属性值。</li>
</ul>
<h3 id="4-4-4-其他方法">4.4.4 其他方法</h3>
<p>如下方法，和该流程无关，胖友可自行查看。</p>
<ul>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L257-L275" target="_blank" rel="external nofollow noopener noreferrer"><code>#getLoadedExtension(name)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L277-L286" target="_blank" rel="external nofollow noopener noreferrer"><code>#getLoadedExtensions()</code></a></li>
</ul>
<h2 id="4-5-获得自适应的拓展对象">4.5 获得自适应的拓展对象</h2>
<p>在 Dubbo 的代码里，常常能看到如下的代码：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<blockquote>
<p>友情提示，胖友先看下&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「6. Adaptive」</a>&nbsp;的内容，在回到此处。</p>
</blockquote>
<h3 id="4-5-1-getAdaptiveExtension">4.5.1 getAdaptiveExtension</h3>
<p><code>#getAdaptiveExtension()</code>&nbsp;方法，获得自适应拓展对象。</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 缓存的自适应( Adaptive )拓展对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;Object&gt;();</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 创建 {<span class="doctag">@link</span> #cachedAdaptiveInstance} 时发生的异常。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 发生异常后，不再创建，参见 {<span class="doctag">@link</span> #createAdaptiveExtension()}</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Throwable createAdaptiveInstanceError;</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">  2:  * 获得自适应拓展对象</span></span><br /><span class="line"><span class="comment">  3:  *</span></span><br /><span class="line"><span class="comment">  4:  * <span class="doctag">@return</span> 拓展对象</span></span><br /><span class="line"><span class="comment">  5:  */</span></span><br /><span class="line">  <span class="number">6</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br /><span class="line">  <span class="number">7</span>: <span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>{</span><br /><span class="line">  <span class="number">8</span>:     <span class="comment">// 从缓存中，获得自适应拓展对象</span></span><br /><span class="line">  <span class="number">9</span>:     Object instance = cachedAdaptiveInstance.get();</span><br /><span class="line"> <span class="number">10</span>:     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">11</span>:         <span class="comment">// 若之前未创建报错，</span></span><br /><span class="line"> <span class="number">12</span>:         <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">13</span>:             <span class="keyword">synchronized</span> (cachedAdaptiveInstance) {</span><br /><span class="line"> <span class="number">14</span>:                 instance = cachedAdaptiveInstance.get();</span><br /><span class="line"> <span class="number">15</span>:                 <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">16</span>:                     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">17</span>:                         <span class="comment">// 创建自适应拓展对象</span></span><br /><span class="line"> <span class="number">18</span>:                         instance = createAdaptiveExtension();</span><br /><span class="line"> <span class="number">19</span>:                         <span class="comment">// 设置到缓存</span></span><br /><span class="line"> <span class="number">20</span>:                         cachedAdaptiveInstance.set(instance);</span><br /><span class="line"> <span class="number">21</span>:                     } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"> <span class="number">22</span>:                         <span class="comment">// 记录异常</span></span><br /><span class="line"> <span class="number">23</span>:                         createAdaptiveInstanceError = t;</span><br /><span class="line"> <span class="number">24</span>:                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adaptive instance: "</span> + t.toString(), t);</span><br /><span class="line"> <span class="number">25</span>:                     }</span><br /><span class="line"> <span class="number">26</span>:                 }</span><br /><span class="line"> <span class="number">27</span>:             }</span><br /><span class="line"> <span class="number">28</span>:         <span class="comment">// 若之前创建报错，则抛出异常 IllegalStateException</span></span><br /><span class="line"> <span class="number">29</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">30</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adaptive instance: "</span> + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);</span><br /><span class="line"> <span class="number">31</span>:         }</span><br /><span class="line"> <span class="number">32</span>:     }</span><br /><span class="line"> <span class="number">33</span>:     <span class="keyword">return</span> (T) instance;</span><br /><span class="line"> <span class="number">34</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 9 行：从缓存&nbsp;<code>cachedAdaptiveInstance</code>&nbsp;属性中，获得自适应拓展对象。</li>
<li>第 28 至 30 行：若之前创建报错，则抛出异常 IllegalStateException 。</li>
<li>第 14 至 20 行：当缓存不存在时，调用&nbsp;<code>#createAdaptiveExtension()</code>&nbsp;方法，创建自适应拓展对象，并添加到&nbsp;<code>cachedAdaptiveInstance</code>&nbsp;中。</li>
<li>第 22 至 24 行：若创建发生异常，记录异常到&nbsp;<code>createAdaptiveInstanceError</code>&nbsp;，并抛出异常 IllegalStateException 。</li>
</ul>
<h3 id="4-5-2-createAdaptiveExtension">4.5.2 createAdaptiveExtension</h3>
<p><code>#createAdaptiveExtension()</code>&nbsp;方法，创建自适应拓展对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 创建自适应拓展对象</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 拓展对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br /><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br /><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create adaptive extension "</span> + type + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>调用&nbsp;<code>#getAdaptiveExtensionClass()</code>&nbsp;方法，获得自适应拓展类。</li>
<li>调用&nbsp;<code>Class#newInstance()</code>&nbsp;方法，创建自适应拓展对象。</li>
<li>调用&nbsp;<code>#injectExtension(instance)</code>&nbsp;方法，向创建的自适应拓展对象，注入依赖的属性。</li>
</ul>
<h3 id="4-5-3-getAdaptiveExtensionClass">4.5.3 getAdaptiveExtensionClass</h3>
<p><code>#getAdaptiveExtensionClass()</code>&nbsp;方法，获得自适应拓展类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * <span class="doctag">@return</span> 自适应拓展类</span></span><br /><span class="line"><span class="comment"> 3:  */</span></span><br /><span class="line"> <span class="number">4</span>: <span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() {</span><br /><span class="line"> <span class="number">5</span>:     getExtensionClasses();</span><br /><span class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">return</span> cachedAdaptiveClass;</span><br /><span class="line"> <span class="number">8</span>:     }</span><br /><span class="line"> <span class="number">9</span>:     <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br /><span class="line"><span class="number">10</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>【<code>@Adaptive</code>&nbsp;的第一种】第 6 至 8 行：若&nbsp;<code>cachedAdaptiveClass</code>&nbsp;已存在，直接返回。的第一种情况。</li>
<li>【<code>@Adaptive</code>&nbsp;的第二种】第 9 行：调用&nbsp;<code>#createAdaptiveExtensionClass()</code>&nbsp;方法，<strong>自动生成</strong>自适应拓展的代码实现，并<strong>编译</strong>后返回该类。</li>
</ul>
<h3 id="4-5-4-createAdaptiveExtensionClassCode">4.5.4 createAdaptiveExtensionClassCode</h3>
<p><code>#createAdaptiveExtensionClassCode()</code>&nbsp;方法，自动生成自适应拓展的代码实现，并编译后返回该类。</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 自动生成自适应拓展的代码实现，并编译后返回该类。</span></span><br /><span class="line"><span class="comment"> 3:  *</span></span><br /><span class="line"><span class="comment"> 4:  * <span class="doctag">@return</span> 类</span></span><br /><span class="line"><span class="comment"> 5:  */</span></span><br /><span class="line"> <span class="number">6</span>: <span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() {</span><br /><span class="line"> <span class="number">7</span>:     <span class="comment">// 自动生成自适应拓展的代码实现的字符串</span></span><br /><span class="line"> <span class="number">8</span>:     String code = createAdaptiveExtensionClassCode();</span><br /><span class="line"> <span class="number">9</span>:     <span class="comment">// 编译代码，并返回该类</span></span><br /><span class="line"><span class="number">10</span>:     ClassLoader classLoader = findClassLoader();</span><br /><span class="line"><span class="number">11</span>:     com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br /><span class="line"><span class="number">12</span>:     <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br /><span class="line"><span class="number">13</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 8 行：调用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L1012-L1253" target="_blank" rel="external nofollow noopener noreferrer"><code>#createAdaptiveExtensionClassCode</code></a>&nbsp;方法，自动生成自适应拓展的代码实现的字符串。
<ul>
<li>🙂 代码比较简单，已经添加详细注释，胖友点击查看。</li>
<li>如下是 ProxyFactory 的自适应拓展的代码实现的字符串生成<strong>例子</strong>&nbsp;<img src="http://static2.iocoder.cn/images/Dubbo/2018_03_04/05.png" alt="自适应拓展的代码实现的字符串生成例子" /></li>
</ul>
</li>
<li>第 9 至 12 行：使用 Dubbo SPI 加载 Compier 拓展接口对应的拓展实现对象，后调用&nbsp;<code>Compiler#compile(code, classLoader)</code>&nbsp;方法，进行编译。🙂 因为不是本文的重点，后续另开文章分享。</li>
</ul>
<h2 id="4-6-获得激活的拓展对象数组">4.6 获得激活的拓展对象数组</h2>
<p>在 Dubbo 的代码里，看到使用代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="4-6-1-getExtensionLoader">4.6.1 getExtensionLoader</h3>
<p><code>#getExtensionLoader(url, key, group)</code>&nbsp;方法，获得符合自动激活条件的拓展对象数组。</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * This is equivalent to {<span class="doctag">@code</span> getActivateExtension(url, url.getParameter(key).split(","), null)}</span></span><br /><span class="line"><span class="comment"> 3:  *</span></span><br /><span class="line"><span class="comment"> 4:  * 获得符合自动激活条件的拓展对象数组</span></span><br /><span class="line"><span class="comment"> 5:  *</span></span><br /><span class="line"><span class="comment"> 6:  * <span class="doctag">@param</span> url   url</span></span><br /><span class="line"><span class="comment"> 7:  * <span class="doctag">@param</span> key   url parameter key which used to get extension point names</span></span><br /><span class="line"><span class="comment"> 8:  *              Dubbo URL 参数名</span></span><br /><span class="line"><span class="comment"> 9:  * <span class="doctag">@param</span> group group</span></span><br /><span class="line"><span class="comment">10:  *              过滤分组名</span></span><br /><span class="line"><span class="comment">11:  * <span class="doctag">@return</span> extension list which are activated.</span></span><br /><span class="line"><span class="comment">12:  * <span class="doctag">@see</span> #getActivateExtension(com.alibaba.dubbo.common.URL, String[], String)</span></span><br /><span class="line"><span class="comment">13:  */</span></span><br /><span class="line"><span class="number">14</span>: <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String key, String group)</span> </span>{</span><br /><span class="line"><span class="number">15</span>:     <span class="comment">// 从 Dubbo URL 获得参数值</span></span><br /><span class="line"><span class="number">16</span>:     String value = url.getParameter(key);</span><br /><span class="line"><span class="number">17</span>:     <span class="comment">// 获得符合自动激活条件的拓展对象数组</span></span><br /><span class="line"><span class="number">18</span>:     <span class="keyword">return</span> getActivateExtension(url, value == <span class="keyword">null</span> || value.length() == <span class="number">0</span> ? <span class="keyword">null</span> : Constants.COMMA_SPLIT_PATTERN.split(value), group);</span><br /><span class="line"><span class="number">19</span>: }</span><br /><span class="line"><span class="number">20</span>: </span><br /><span class="line"><span class="number">21</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">22:  * Get activate extensions.</span></span><br /><span class="line"><span class="comment">23:  *</span></span><br /><span class="line"><span class="comment">24:  * 获得符合自动激活条件的拓展对象数组</span></span><br /><span class="line"><span class="comment">25:  *</span></span><br /><span class="line"><span class="comment">26:  * <span class="doctag">@param</span> url    url</span></span><br /><span class="line"><span class="comment">27:  * <span class="doctag">@param</span> values extension point names</span></span><br /><span class="line"><span class="comment">28:  * <span class="doctag">@param</span> group  group</span></span><br /><span class="line"><span class="comment">29:  * <span class="doctag">@return</span> extension list which are activated</span></span><br /><span class="line"><span class="comment">30:  * <span class="doctag">@see</span> com.alibaba.dubbo.common.extension.Activate</span></span><br /><span class="line"><span class="comment">31:  */</span></span><br /><span class="line"><span class="number">32</span>: <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>{</span><br /><span class="line"><span class="number">33</span>:     List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br /><span class="line"><span class="number">34</span>:     List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br /><span class="line"><span class="number">35</span>:     <span class="comment">// 处理自动激活的拓展对象们</span></span><br /><span class="line"><span class="number">36</span>:     <span class="comment">// 判断不存在配置 `"-name"` 。例如，&lt;dubbo:service filter="-default" /&gt; ，代表移除所有默认过滤器。</span></span><br /><span class="line"><span class="number">37</span>:     <span class="keyword">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) {</span><br /><span class="line"><span class="number">38</span>:         <span class="comment">// 获得拓展实现类数组</span></span><br /><span class="line"><span class="number">39</span>:         getExtensionClasses();</span><br /><span class="line"><span class="number">40</span>:         <span class="comment">// 循环</span></span><br /><span class="line"><span class="number">41</span>:         <span class="keyword">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) {</span><br /><span class="line"><span class="number">42</span>:             String name = entry.getKey();</span><br /><span class="line"><span class="number">43</span>:             Activate activate = entry.getValue();</span><br /><span class="line"><span class="number">44</span>:             <span class="keyword">if</span> (isMatchGroup(group, activate.group())) { <span class="comment">// 匹配分组</span></span><br /><span class="line"><span class="number">45</span>:                 <span class="comment">// 获得拓展对象</span></span><br /><span class="line"><span class="number">46</span>:                 T ext = getExtension(name);</span><br /><span class="line"><span class="number">47</span>:                 <span class="keyword">if</span> (!names.contains(name) <span class="comment">// 不包含在自定义配置里。如果包含，会在下面的代码处理。</span></span><br /><span class="line"><span class="number">48</span>:                         &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name) <span class="comment">// 判断是否配置移除。例如 &lt;dubbo:service filter="-monitor" /&gt;，则 MonitorFilter 会被移除</span></span><br /><span class="line"><span class="number">49</span>:                         &amp;&amp; isActive(activate, url)) { <span class="comment">// 判断是否激活</span></span><br /><span class="line"><span class="number">50</span>:                     exts.add(ext);</span><br /><span class="line"><span class="number">51</span>:                 }</span><br /><span class="line"><span class="number">52</span>:             }</span><br /><span class="line"><span class="number">53</span>:         }</span><br /><span class="line"><span class="number">54</span>:         <span class="comment">// 排序</span></span><br /><span class="line"><span class="number">55</span>:         Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br /><span class="line"><span class="number">56</span>:     }</span><br /><span class="line"><span class="number">57</span>:     <span class="comment">// 处理自定义配置的拓展对象们。例如在 &lt;dubbo:service filter="demo" /&gt; ，代表需要加入 DemoFilter （这个是笔者自定义的）。</span></span><br /><span class="line"><span class="number">58</span>:     List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br /><span class="line"><span class="number">59</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) {</span><br /><span class="line"><span class="number">60</span>:         String name = names.get(i);</span><br /><span class="line"><span class="number">61</span>:         <span class="keyword">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX) &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) { <span class="comment">// 判断非移除的</span></span><br /><span class="line"><span class="number">62</span>:             <span class="comment">// 将配置的自定义在自动激活的拓展对象们前面。例如，&lt;dubbo:service filter="demo,default,demo2" /&gt; ，则 DemoFilter 就会放在默认的过滤器前面。</span></span><br /><span class="line"><span class="number">63</span>:             <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(name)) {</span><br /><span class="line"><span class="number">64</span>:                 <span class="keyword">if</span> (!usrs.isEmpty()) {</span><br /><span class="line"><span class="number">65</span>:                     exts.addAll(<span class="number">0</span>, usrs);</span><br /><span class="line"><span class="number">66</span>:                     usrs.clear();</span><br /><span class="line"><span class="number">67</span>:                 }</span><br /><span class="line"><span class="number">68</span>:             } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">69</span>:                 <span class="comment">// 获得拓展对象</span></span><br /><span class="line"><span class="number">70</span>:                 T ext = getExtension(name);</span><br /><span class="line"><span class="number">71</span>:                 usrs.add(ext);</span><br /><span class="line"><span class="number">72</span>:             }</span><br /><span class="line"><span class="number">73</span>:         }</span><br /><span class="line"><span class="number">74</span>:     }</span><br /><span class="line"><span class="number">75</span>:     <span class="comment">// 添加到结果集</span></span><br /><span class="line"><span class="number">76</span>:     <span class="keyword">if</span> (!usrs.isEmpty()) {</span><br /><span class="line"><span class="number">77</span>:         exts.addAll(usrs);</span><br /><span class="line"><span class="number">78</span>:     }</span><br /><span class="line"><span class="number">79</span>:     <span class="keyword">return</span> exts;</span><br /><span class="line"><span class="number">80</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 16 行：从 Dubbo URL 获得参数值。例如说，若 XML 配置 Service&nbsp;<code>&lt;dubbo:service filter="demo, demo2" /&gt;</code>&nbsp;，并且在获得 Filter 自动激活拓展时，此处就能解析到&nbsp;<code>value=demo,demo2</code>&nbsp;。另外，<code>value</code>&nbsp;可以根据<strong>逗号</strong>拆分。</li>
<li>第 18 行：调用&nbsp;<code>#getActivateExtension(url, values, group)</code>&nbsp;方法，获得符合自动激活条件的拓展对象数组。</li>
<li>第 35 至 56 行：处理自动激活的拓展对象们。
<ul>
<li><a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L357-L378" target="_blank" rel="external nofollow noopener noreferrer"><code>#isMatchGroup(group, groups)</code></a>&nbsp;方法，匹配分组。</li>
<li><a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L380-L403" target="_blank" rel="external nofollow noopener noreferrer"><code>#isActive(Activate, url)</code></a>&nbsp;方法，是否激活，通过 Dubbo URL 中是否存在参数名为&nbsp;<a href="mailto:%60@Activate.value" target="_blank" rel="external nofollow noopener noreferrer">`@Activate.value</a>` ，并且参数值非空。</li>
</ul>
</li>
<li>第 57 至 74 行：处理自定义配置的拓展对象们。</li>
<li>第 75 至 78 行：将&nbsp;<code>usrs</code>&nbsp;合并到&nbsp;<code>exts</code>&nbsp;<strong>尾部</strong>。</li>
<li>🙂 代码比较简单，胖友直接看注释。</li>
</ul>
<h3 id="4-6-2-ActivateComparator">4.6.2 ActivateComparator</h3>
<p><a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/support/ActivateComparator.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.common.extension.support.ActivateComparator</code></a>&nbsp;，自动激活拓展对象排序器。</p>
<ul>
<li>🙂 代码比较简单，胖友直接看注释。</li>
</ul>
<h1 id="5-SPI">5. @SPI</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/SPI.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.common.extension.@SPI</code></a>&nbsp;，扩展点接口的标识。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Documented</span></span><br /><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br /><span class="line"><span class="meta">@Target</span>({ElementType.TYPE})</span><br /><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SPI {</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * default extension name</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>value</code>&nbsp;，默认拓展实现类的名字。例如，Protocol 拓展接口，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>{</span><br /><span class="line">    <span class="comment">// ... 省略代码</span></span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>其中&nbsp;<code>"dubbo"</code>&nbsp;指的是 DubboProtocol ，Protocol 默认的拓展实现类。</li>
</ul>
</li>
</ul>
<h1 id="6-Adaptive">6. @Adaptive</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/Adaptive.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.common.extension.@Adaptive</code></a>&nbsp;，自适应拓展信息的标记。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Documented</span></span><br /><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br /><span class="line"><span class="meta">@Target</span>({ElementType.TYPE, ElementType.METHOD})</span><br /><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive {</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Decide which target extension to be injected. The name of the target extension is decided by the parameter passed</span></span><br /><span class="line"><span class="comment">     * in the URL, and the parameter names are given by this method.</span></span><br /><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br /><span class="line"><span class="comment">     * If the specified parameters are not found from {<span class="doctag">@link</span> URL}, then the default extension will be used for</span></span><br /><span class="line"><span class="comment">     * dependency injection (specified in its interface's {<span class="doctag">@link</span> SPI}).</span></span><br /><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br /><span class="line"><span class="comment">     * For examples, given &lt;code&gt;String[] {"key1", "key2"}&lt;/code&gt;:</span></span><br /><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br /><span class="line"><span class="comment">     * &lt;li&gt;find parameter 'key1' in URL, use its value as the extension's name&lt;/li&gt;</span></span><br /><span class="line"><span class="comment">     * &lt;li&gt;try 'key2' for extension's name if 'key1' is not found (or its value is empty) in URL&lt;/li&gt;</span></span><br /><span class="line"><span class="comment">     * &lt;li&gt;use default extension if 'key2' doesn't appear either&lt;/li&gt;</span></span><br /><span class="line"><span class="comment">     * &lt;li&gt;otherwise, throw {<span class="doctag">@link</span> IllegalStateException}&lt;/li&gt;</span></span><br /><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br /><span class="line"><span class="comment">     * If default extension's name is not give on interface's {<span class="doctag">@link</span> SPI}, then a name is generated from interface's</span></span><br /><span class="line"><span class="comment">     * class name with the rule: divide classname from capital char into several parts, and separate the parts with</span></span><br /><span class="line"><span class="comment">     * dot '.', for example: for {<span class="doctag">@code</span> com.alibaba.dubbo.xxx.YyyInvokerWrapper}, its default name is</span></span><br /><span class="line"><span class="comment">     * &lt;code&gt;String[] {"yyy.invoker.wrapper"}&lt;/code&gt;. This name will be used to search for parameter from URL.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> parameter key names in URL</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 从 {<span class="doctag">@link</span> URL }的 Key 名，对应的 Value 作为要 Adapt 成的 Extension 名。</span></span><br /><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br /><span class="line"><span class="comment">     * 如果 {<span class="doctag">@link</span> URL} 这些 Key 都没有 Value ，使用 缺省的扩展（在接口的{<span class="doctag">@link</span> SPI}中设定的值）。&lt;br&gt;</span></span><br /><span class="line"><span class="comment">     * 比如，&lt;code&gt;String[] {"key1", "key2"}&lt;/code&gt;，表示</span></span><br /><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br /><span class="line"><span class="comment">     *      &lt;li&gt;先在URL上找key1的Value作为要Adapt成的Extension名；</span></span><br /><span class="line"><span class="comment">     *      &lt;li&gt;key1没有Value，则使用key2的Value作为要Adapt成的Extension名。</span></span><br /><span class="line"><span class="comment">     *      &lt;li&gt;key2没有Value，使用缺省的扩展。</span></span><br /><span class="line"><span class="comment">     *      &lt;li&gt;如果没有设定缺省扩展，则方法调用会抛出{<span class="doctag">@link</span> IllegalStateException}。</span></span><br /><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br /><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br /><span class="line"><span class="comment">     * 如果不设置则缺省使用Extension接口类名的点分隔小写字串。&lt;br&gt;</span></span><br /><span class="line"><span class="comment">     * 即对于Extension接口 {<span class="doctag">@code</span> com.alibaba.dubbo.xxx.YyyInvokerWrapper} 的缺省值为 &lt;code&gt;String[] {"yyy.invoker.wrapper"}&lt;/code&gt;</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> SPI#value()</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String[] value() <span class="keyword">default</span> {};</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p><code>@Adaptive</code>&nbsp;注解，可添加<strong>类</strong>或<strong>方法</strong>上，分别代表了两种不同的使用方式。</p>
<blockquote>
<p>友情提示：一个拓展接口，有且仅有一个 Adaptive 拓展实现类。</p>
</blockquote>
<ul>
<li>第一种，标记在<strong>类</strong>上，代表<strong>手动实现</strong>它是一个拓展接口的 Adaptive 拓展实现类。目前 Dubbo 项目里，只有 ExtensionFactory 拓展的实现类 AdaptiveExtensionFactory 有这么用。详细解析见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「8.1 AdaptiveExtensionFactory」</a>。</li>
<li>第二种，标记在拓展接口的<strong>方法</strong>上，代表<strong>自动生成代码实现</strong>该接口的 Adaptive 拓展实现类。
<ul>
<li><code>value</code>&nbsp;，从 Dubbo URL 获取参数中，使用键名( Key )，获取键值。该值为<strong>真正的</strong>拓展名。
<ul>
<li>自适应拓展实现类，会获取拓展名对应的<strong>真正</strong>的拓展对象。通过该对象，执行真正的逻辑。</li>
<li>可以设置<strong>多个</strong>键名( Key )，顺序获取直到<strong>有值</strong>。若最终获取不到，使用<strong>默认拓展名</strong>。</li>
</ul>
</li>
<li>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「4.5.4 createAdaptiveExtensionClassCode」</a>&nbsp;详细解析。</li>
</ul>
</li>
</ul>
<h1 id="7-Activate">7. @Activate</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/Activate.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.common.extension.@Activate</code></a>&nbsp;，自动激活条件的标记。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Documented</span></span><br /><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br /><span class="line"><span class="meta">@Target</span>({ElementType.TYPE, ElementType.METHOD})</span><br /><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activate {</span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Activate the current extension when one of the groups matches. The group passed into</span></span><br /><span class="line"><span class="comment">     * {<span class="doctag">@link</span> ExtensionLoader#getActivateExtension(URL, String, String)} will be used for matching.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> group names to match</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String, String)</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Group过滤条件。</span></span><br /><span class="line"><span class="comment">     * &lt;br /&gt;</span></span><br /><span class="line"><span class="comment">     * 包含{<span class="doctag">@link</span> ExtensionLoader#getActivateExtension}的group参数给的值，则返回扩展。</span></span><br /><span class="line"><span class="comment">     * &lt;br /&gt;</span></span><br /><span class="line"><span class="comment">     * 如没有Group设置，则不过滤。</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String[] group() <span class="keyword">default</span> {};</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Activate the current extension when the specified keys appear in the URL's parameters.</span></span><br /><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br /><span class="line"><span class="comment">     * For example, given &lt;code&gt;<span class="doctag">@Activate</span>("cache, validation")&lt;/code&gt;, the current extension will be return only when</span></span><br /><span class="line"><span class="comment">     * there's either &lt;code&gt;cache&lt;/code&gt; or &lt;code&gt;validation&lt;/code&gt; key appeared in the URL's parameters.</span></span><br /><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> URL parameter keys</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String)</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String, String)</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Key过滤条件。包含{<span class="doctag">@link</span> ExtensionLoader#getActivateExtension}的URL的参数Key中有，则返回扩展。</span></span><br /><span class="line"><span class="comment">     * &lt;p/&gt;</span></span><br /><span class="line"><span class="comment">     * 示例：&lt;br/&gt;</span></span><br /><span class="line"><span class="comment">     * 注解的值 &lt;code&gt;<span class="doctag">@Activate</span>("cache,validatioin")&lt;/code&gt;，</span></span><br /><span class="line"><span class="comment">     * 则{<span class="doctag">@link</span> ExtensionLoader#getActivateExtension}的URL的参数有&lt;code&gt;cache&lt;/code&gt;Key，或是&lt;code&gt;validatioin&lt;/code&gt;则返回扩展。</span></span><br /><span class="line"><span class="comment">     * &lt;br/&gt;</span></span><br /><span class="line"><span class="comment">     * 如没有设置，则不过滤。</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String[] value() <span class="keyword">default</span> {};</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Relative ordering info, optional</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put before the current one</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 排序信息，可以不提供。</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String[] before() <span class="keyword">default</span> {};</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Relative ordering info, optional</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put after the current one</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 排序信息，可以不提供。</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    String[] after() <span class="keyword">default</span> {};</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Absolute ordering info, optional</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> absolute ordering info</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 排序信息，可以不提供。</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>对于可以被框架中自动激活加载扩展，<code>@Activate</code>&nbsp;用于配置扩展被自动激活加载条件。比如，Filter 扩展，有多个实现，使用&nbsp;<code>@Activate</code>&nbsp;的扩展可以根据<strong>条件</strong>被自动加载。
<ul>
<li>这块的例子，可以看下&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">《Dubbo 开发指南 &mdash;&mdash; 扩展点加载》「扩展点自动激活」</a>&nbsp;文档提供的。</li>
</ul>
</li>
<li>🙂 分成过滤条件和排序信息<strong>两类属性</strong>，胖友看下代码里的注释。</li>
<li>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「4.6 获得激活的拓展对象数组」</a>&nbsp;详细解析。</li>
</ul>
<h1 id="8-ExtensionFactory">8. ExtensionFactory</h1>
<p><a href="http://svip.iocoder.cn/Dubbo/spi/"><code>com.alibaba.dubbo.common.extension.ExtensionFactory</code></a>&nbsp;，拓展工厂接口。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * ExtensionFactory</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 拓展工厂接口</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@SPI</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExtensionFactory</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Get extension.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 获得拓展对象</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> type object type. 拓展接口</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> name object name. 拓展名</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> object instance. 拓展对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span></span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>ExtensionFactory 自身也是拓展接口，基于 Dubbo SPI 加载具体拓展实现类。</li>
<li><code>#getExtension(type, name)</code>&nbsp;方法，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「4.4.3 injectExtension」</a>&nbsp;中，获得拓展对象，向创建的拓展对象<strong>注入依赖属性</strong>。在实际代码中，我们可以看到不仅仅获得的是拓展对象，也可以是 Spring 中的 Bean 对象。</li>
<li>ExtensionFactory 子类类图如下：<img src="http://static2.iocoder.cn/images/Dubbo/2018_03_04/06.png" alt="ExtensionFactory 类图" /></li>
</ul>
<h2 id="8-1-AdaptiveExtensionFactory">8.1 AdaptiveExtensionFactory</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/factory/AdaptiveExtensionFactory.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.common.extension.factory.AdaptiveExtensionFactory</code></a>&nbsp;，自适应 ExtensionFactory 拓展实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Adaptive</span></span><br /><span class="line"> <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>{</span><br /><span class="line"> <span class="number">3</span>: </span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 5:      * ExtensionFactory 拓展对象集合</span></span><br /><span class="line"><span class="comment"> 6:      */</span></span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br /><span class="line"> <span class="number">8</span>: </span><br /><span class="line"> <span class="number">9</span>:     <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveExtensionFactory</span><span class="params">()</span> </span>{</span><br /><span class="line"><span class="number">10</span>:         <span class="comment">// 使用 ExtensionLoader 加载拓展对象实现类。</span></span><br /><span class="line"><span class="number">11</span>:         ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br /><span class="line"><span class="number">12</span>:         List&lt;ExtensionFactory&gt; list = <span class="keyword">new</span> ArrayList&lt;ExtensionFactory&gt;();</span><br /><span class="line"><span class="number">13</span>:         <span class="keyword">for</span> (String name : loader.getSupportedExtensions()) {</span><br /><span class="line"><span class="number">14</span>:             list.add(loader.getExtension(name));</span><br /><span class="line"><span class="number">15</span>:         }</span><br /><span class="line"><span class="number">16</span>:         factories = Collections.unmodifiableList(list);</span><br /><span class="line"><span class="number">17</span>:     }</span><br /><span class="line"><span class="number">18</span>: </span><br /><span class="line"><span class="number">19</span>:     <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>{</span><br /><span class="line"><span class="number">20</span>:         <span class="comment">// 遍历工厂数组，直到获得到属性</span></span><br /><span class="line"><span class="number">21</span>:         <span class="keyword">for</span> (ExtensionFactory factory : factories) {</span><br /><span class="line"><span class="number">22</span>:             T extension = factory.getExtension(type, name);</span><br /><span class="line"><span class="number">23</span>:             <span class="keyword">if</span> (extension != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">24</span>:                 <span class="keyword">return</span> extension;</span><br /><span class="line"><span class="number">25</span>:             }</span><br /><span class="line"><span class="number">26</span>:         }</span><br /><span class="line"><span class="number">27</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line"><span class="number">28</span>:     }</span><br /><span class="line"><span class="number">29</span>: </span><br /><span class="line"><span class="number">30</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>@Adaptive</code>&nbsp;注解，为 ExtensionFactory 的<strong>自适应</strong>拓展实现类。</li>
<li><strong>构造</strong>方法，使用 ExtensionLoader 加载 ExtensionFactory 拓展对象的实现类。若胖友没自己实现 ExtensionFactory 的情况下，<code>factories</code>&nbsp;为 SpiExtensionFactory 和 SpringExtensionFactory 。</li>
<li><code>#getExtension(type, name)</code>&nbsp;方法，遍历&nbsp;<code>factories</code>&nbsp;，调用其&nbsp;<code>#getExtension(type, name)</code>&nbsp;方法，直到获得到属性值。</li>
</ul>
<h2 id="8-2-SpiExtensionFactory">8.2 SpiExtensionFactory</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/factory/SpiExtensionFactory.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.common.extension.factory.SpiExtensionFactory</code></a>&nbsp;，SPI ExtensionFactory 拓展实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 获得拓展对象</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> type object type. 拓展接口</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> name object name. 拓展名</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> 拓展对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>{</span><br /><span class="line">        <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) { <span class="comment">// 校验是 @SPI</span></span><br /><span class="line">            <span class="comment">// 加载拓展接口对应的 ExtensionLoader 对象</span></span><br /><span class="line">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br /><span class="line">            <span class="comment">// 加载拓展对象</span></span><br /><span class="line">            <span class="keyword">if</span> (!loader.getSupportedExtensions().isEmpty()) {</span><br /><span class="line">                <span class="keyword">return</span> loader.getAdaptiveExtension();</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="8-3-SpringExtensionFactory">8.3 SpringExtensionFactory</h2>
<p><a href="http://svip.iocoder.cn/Dubbo/spi/SpringExtensionFactory"><code>com.alibaba.dubbo.config.spring.extension.SpringExtensionFactory</code></a>&nbsp;，Spring ExtensionFactory 拓展实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Spring Context 集合</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>{</span><br /><span class="line">        contexts.add(context);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>{</span><br /><span class="line">        contexts.remove(context);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br /><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>{</span><br /><span class="line">        <span class="keyword">for</span> (ApplicationContext context : contexts) {</span><br /><span class="line">            <span class="keyword">if</span> (context.containsBean(name)) {</span><br /><span class="line">                <span class="comment">// 获得属性</span></span><br /><span class="line">                Object bean = context.getBean(name);</span><br /><span class="line">                <span class="comment">// 判断类型</span></span><br /><span class="line">                <span class="keyword">if</span> (type.isInstance(bean)) {</span><br /><span class="line">                    <span class="keyword">return</span> (T) bean;</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>#getExtension(type, name)</code>&nbsp;方法，遍历&nbsp;<code>contexts</code>&nbsp;，调用其&nbsp;<code>ApplicationContext#getBean(name)</code>方法，获得 Bean 对象，直到成功并且值类型正确。</li>
</ul>
<h3 id="8-3-1-例子">8.3.1 例子</h3>
<p>DemoFilter 是笔者实现的 Filter 拓展实现类，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">private</span> DemoDAO demoDAO;</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> DemoFilter <span class="title">setDemoDAO</span><span class="params">(DemoDAO demoDAO)</span> </span>{</span><br /><span class="line">        <span class="keyword">this</span>.demoDAO = demoDAO;</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>DemoDAO ，笔者在 Spring 中声明对应的 Bean 对象。</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoDAO"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoDAO"</span> /&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/spi/">「4.4.3 injectExtension」</a>&nbsp;中，会调用&nbsp;<code>#setDemoDAO(demo)</code>&nbsp;方法，将 DemoFilter 依赖的属性&nbsp;<code>demoDAO</code>&nbsp;注入。</p>
</li>
</ul>
</div>