<header class="article-header">
<h1 class="article-title">优雅停机</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>本文分享 Dubbo 的<strong>优雅停机</strong>&nbsp;Graceful Shutdown ，对应&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/graceful-shutdown.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 优雅停机》</a>&nbsp;。</p>
<p>定义如下：</p>
<blockquote>
<p>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果用户使用&nbsp;<code>kill -9 PID</code>&nbsp;等强制关闭指令，是不会执行优雅停机的，只有通过&nbsp;<code>kill PID</code>&nbsp;时，才会执行。</p>
</blockquote>
<ul>
<li>这块，我们在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2. ShutdownHook」</a>&nbsp;中，详细解析。</li>
</ul>
<p>原理如下：</p>
<blockquote>
<p><strong>服务提供方</strong></p>
<ul>
<li>停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。 //&lt;1&gt;</li>
<li>然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。 // &lt;2&gt;</li>
</ul>
<p><strong>服务消费方</strong></p>
<ul>
<li>停止时，不再发起新的调用请求，所有新的调用在客户端即报错。 // &lt;3&gt;</li>
<li>然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。 // &lt;4&gt;</li>
</ul>
</blockquote>
<ul>
<li><code>&lt;1&gt;</code>&nbsp;<code>&lt;2&gt;</code>：基于&nbsp;<strong>READONLYEVENT</strong>&nbsp;事件，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-api-exchange/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（四）之 Exchange 层》</a>中，见 HeaderExchangeServer 的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「4.1.4 优雅关闭」</a>&nbsp;。</li>
<li><code>&lt;3&gt;</code>&nbsp;<code>&lt;4&gt;</code>&nbsp;：在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-api-exchange/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（四）之 Exchange 层》</a>&nbsp;中，见 HeaderExchangeChannel 的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2.1.2 发送请求」</a>&nbsp;和&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2.1.3 优雅关闭」</a>。</li>
<li>😈 因为之前文章是<strong>拆开</strong>的，所以下文会提供下<strong>整体</strong>的顺序图。</li>
</ul>
<h1 id="2-ShutdownHook">2. ShutdownHook</h1>
<p>Dubbo 的优雅停机&nbsp;<strong>ShutdownHook</strong>&nbsp;在 AbstractConfig 的<strong>静态代码块</strong>初始化，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">static</span> {</span><br /><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br /><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br /><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line">                logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br /><span class="line">            }</span><br /><span class="line">            ProtocolConfig.destroyAll();</span><br /><span class="line">        }</span><br /><span class="line">    }, <span class="string">"DubboShutdownHook"</span>));</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>从代码的位置上来说，这不是一个<strong>好</strong>的位置。但是考虑到保证<strong>能够</strong>被初始化到 ShutdownHook ，这又是一个<strong>合适</strong>的位置。当然，从官方的 TODO 来说，未来可能会换地方。</li>
<li>
<p><code>ProtocolConfig#destroyAll()</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="comment">// 忽略，若已经销毁</span></span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br /><span class="line"> <span class="number">4</span>:         <span class="keyword">return</span>;</span><br /><span class="line"> <span class="number">5</span>:     }</span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// 销毁 Registry 相关</span></span><br /><span class="line"> <span class="number">7</span>:     AbstractRegistryFactory.destroyAll();</span><br /><span class="line"> <span class="number">8</span>: </span><br /><span class="line"> <span class="number">9</span>:     <span class="comment">// 等到服务消费，接收到注册中心通知到该服务提供者已经下线，加大了在不重试情况下优雅停机的成功率。</span></span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// Wait for registry notification</span></span><br /><span class="line"><span class="number">11</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">12</span>:         Thread.sleep(ConfigUtils.getServerShutdownTimeout());</span><br /><span class="line"><span class="number">13</span>:     } <span class="keyword">catch</span> (InterruptedException e) {</span><br /><span class="line"><span class="number">14</span>:         logger.warn(<span class="string">"Interrupted unexpectedly when waiting for registry notification during shutdown process!"</span>);</span><br /><span class="line"><span class="number">15</span>:     }</span><br /><span class="line"><span class="number">16</span>: </span><br /><span class="line"><span class="number">17</span>:     <span class="comment">// 销毁 Protocol 相关</span></span><br /><span class="line"><span class="number">18</span>:     ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class);</span><br /><span class="line"><span class="number">19</span>:     <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) {</span><br /><span class="line"><span class="number">20</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">21</span>:             Protocol protocol = loader.getLoadedExtension(protocolName);</span><br /><span class="line"><span class="number">22</span>:             <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">23</span>:                 protocol.destroy();</span><br /><span class="line"><span class="number">24</span>:             }</span><br /><span class="line"><span class="number">25</span>:         } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">26</span>:             logger.warn(t.getMessage(), t);</span><br /><span class="line"><span class="number">27</span>:         }</span><br /><span class="line"><span class="number">28</span>:     }</span><br /><span class="line"><span class="number">29</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 2 至 5 行：<strong>忽略</strong>，若已经销毁。</li>
<li>第 7 行：调用&nbsp;<code>AbstractRegistryFactory#destroyAll()</code>&nbsp;方法，销毁<strong>所有</strong>&nbsp;Registry ，取消<strong>应用程序</strong>中的服务提供者和消费者的<strong>订阅</strong>与<strong>注册</strong>。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2.1 AbstractRegistryFactory」</a>&nbsp;中。</li>
<li>
<p>第 9 至 15 行：sleep&nbsp;<strong>等待</strong>一段时间，用于<strong>其他应用程序</strong>的服务消费者，接收到注册中心通知，该<strong>应用程序</strong>的服务提供者已经下线，加大了在不重试情况下优雅停机的成功率。</p>
<ul>
<li>
<p>😈 当然，这不是<strong>绝对</strong>能等待到，而是开发者自己配置&nbsp;<code>"dubbo.service.shutdown.wait"</code>&nbsp;参数，设置等待的时长（单位：毫秒）。<code>ConfigUtils#getServerShutdownTimeout()</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getServerShutdownTimeout</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 默认，10 * 1000 毫秒</span></span><br /><span class="line">    <span class="keyword">int</span> timeout = Constants.DEFAULT_SERVER_SHUTDOWN_TIMEOUT;</span><br /><span class="line">    <span class="comment">// 获得 "dubbo.service.shutdown.wait" 配置项，单位：毫秒</span></span><br /><span class="line">    String value = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_KEY);</span><br /><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) {</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            timeout = Integer.parseInt(value);</span><br /><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">        }</span><br /><span class="line">    <span class="comment">// 若为空，获得 "dubbo.service.shutdown.wait.seconds" 配置项，单位：秒。</span></span><br /><span class="line">    <span class="comment">// ps：目前已经废弃该参数，推荐使用 "dubbo.service.shutdown.wait"</span></span><br /><span class="line">    } <span class="keyword">else</span> {</span><br /><span class="line">        value = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY);</span><br /><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) {</span><br /><span class="line">            <span class="keyword">try</span> {</span><br /><span class="line">                timeout = Integer.parseInt(value) * <span class="number">1000</span>;</span><br /><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 返回</span></span><br /><span class="line">    <span class="keyword">return</span> timeout;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><strong>默认</strong>&nbsp;10 * 1000 毫秒。</li>
</ul>
</li>
<li>
<p>在&nbsp;<a href="https://github.com/apache/incubator-dubbo/pull/1021" target="_blank" rel="external nofollow noopener noreferrer">ISSUE#1021：Enhancement for graceful shutdown</a>&nbsp;，是针对这块的讨论，非常有趣，胖友一定要看看。</p>
<blockquote>
<p>目前不管是用的最多的2.5.3版本还是最新的2.5.7版本，亲自测试在不设置重试机制下是无法做到优雅停机的，这次改动主要是修改一点点代码，加上可配置的等待时间，就能简单的做到&ldquo;不开启重试也能优雅停机&rdquo;。</p>
<p>其主要实现机制就是在【provider断连注册中心之后，关闭应答之前】和【consumer移除掉invoker后，关闭client之前】这两个阶段加入可配置的等待时间，目前亲测可以做到不配置重试也能优雅停机。</p>
<p>因为现在大多数用dubbo的公司，为了避免极端情况下的雪崩和流量风暴，大部分接口都会关闭重试机制，这样，对于当前dubbo优雅停机的设定，就无法做到优雅停机了，所以这里通过比较简单的方式，加大了在不重试情况下优雅停机的成功率。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第 17 至 28 行：销毁<strong>所有</strong>&nbsp;Protocol 。目前分层两类 Protocol ：</p>
<ul>
<li>和 Registry 集成的 Protocol 实现类&nbsp;<strong>RegistryProtocol</strong>&nbsp;，关注服务的<strong>注册</strong>。具体的销毁逻辑，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2.3 RegistryProtocol」</a>&nbsp;中。</li>
<li><strong>具体协议</strong>对应的 Protocol 实现类，例如&nbsp;<code>dubbo://</code>&nbsp;对应的 DubboProtocol 、<code>hessian://</code>&nbsp;对应的 HessianProtocol ，关注服务的<strong>暴露</strong>和<strong>引用</strong>。因为 DubboProtocol 是最<strong>常用</strong>的，所以我们以它为例子，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2.2 DubboProtocol」</a>&nbsp;中分享。</li>
</ul>
</li>
</ul>
<h2 id="2-1-AbstractRegistryFactory">2.1 AbstractRegistryFactory</h2>
<p><code>#destroyAll()</code>&nbsp;方法，销毁所有 Registry 。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Registry&gt; REGISTRIES = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Registry&gt;();</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (LOGGER.isInfoEnabled()) {</span><br /><span class="line">        LOGGER.info(<span class="string">"Close all registries "</span> + getRegistries());</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 获得锁</span></span><br /><span class="line">    LOCK.lock();</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        <span class="comment">// 销毁</span></span><br /><span class="line">        <span class="keyword">for</span> (Registry registry : getRegistries()) {</span><br /><span class="line">            <span class="keyword">try</span> {</span><br /><span class="line">                registry.destroy();</span><br /><span class="line">            } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">                LOGGER.error(e.getMessage(), e);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 清空缓存</span></span><br /><span class="line">        REGISTRIES.clear();</span><br /><span class="line">    } <span class="keyword">finally</span> {</span><br /><span class="line">        <span class="comment">// 释放锁</span></span><br /><span class="line">        LOCK.unlock();</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>调用&nbsp;<code>Registry#destroy()</code>&nbsp;方法，销毁每个 Registry 。</li>
<li>
<p>AbstractRegistry 实现了<strong>公用</strong>的销毁逻辑：取消<strong>注册</strong>和<strong>订阅</strong>。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 已销毁，跳过</span></span><br /><span class="line">    <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line">        logger.info(<span class="string">"Destroy registry:"</span> + getUrl());</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 取消注册</span></span><br /><span class="line">    Set&lt;URL&gt; destroyRegistered = <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered());</span><br /><span class="line">    <span class="keyword">if</span> (!destroyRegistered.isEmpty()) {</span><br /><span class="line">        <span class="keyword">for</span> (URL url : <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered())) {</span><br /><span class="line">            <span class="keyword">if</span> (url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>)) {</span><br /><span class="line">                <span class="keyword">try</span> {</span><br /><span class="line">                    unregister(url); <span class="comment">// 取消注册</span></span><br /><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line">                        logger.info(<span class="string">"Destroy unregister url "</span> + url);</span><br /><span class="line">                    }</span><br /><span class="line">                } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">                    logger.warn(<span class="string">"Failed to unregister url "</span> + url + <span class="string">" to registry "</span> + getUrl() + <span class="string">" on destroy, cause: "</span> + t.getMessage(), t);</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 取消订阅</span></span><br /><span class="line">    Map&lt;URL, Set&lt;NotifyListener&gt;&gt; destroySubscribed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed());</span><br /><span class="line">    <span class="keyword">if</span> (!destroySubscribed.isEmpty()) {</span><br /><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : destroySubscribed.entrySet()) {</span><br /><span class="line">            URL url = entry.getKey();</span><br /><span class="line">            <span class="keyword">for</span> (NotifyListener listener : entry.getValue()) {</span><br /><span class="line">                <span class="keyword">try</span> {</span><br /><span class="line">                    unsubscribe(url, listener); <span class="comment">// 取消订阅</span></span><br /><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line">                        logger.info(<span class="string">"Destroy unsubscribe url "</span> + url);</span><br /><span class="line">                    }</span><br /><span class="line">                } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">                    logger.warn(<span class="string">"Failed to unsubscribe url "</span> + url + <span class="string">" to registry "</span> + getUrl() + <span class="string">" on destroy, cause: "</span> + t.getMessage(), t);</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>无论是服务<strong>提供者</strong>还是<strong>消费者</strong>，都会向 Registry 发起<strong>注册</strong>和<strong>订阅</strong>，所以<strong>都</strong>需要进行取消。</li>
</ul>
</li>
<li>
<p>AbstractRegistry 的<strong>子类</strong>&nbsp;FailbackRegistry ，实现销毁<strong>公用</strong>的<strong>重试任务</strong>。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 忽略，若已经销毁</span></span><br /><span class="line">    <span class="keyword">if</span> (!canDestroy()) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 调用父方法，取消注册和订阅</span></span><br /><span class="line">    <span class="keyword">super</span>.destroy();</span><br /><span class="line">    <span class="comment">// 销毁重试任务</span></span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        retryFuture.cancel(<span class="keyword">true</span>);</span><br /><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">        logger.warn(t.getMessage(), t);</span><br /><span class="line">    }</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canDestroy</span><span class="params">()</span></span>{</span><br /><span class="line">    <span class="keyword">return</span> destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>FailbackRegistry 有<strong>多种</strong>实现类，会有销毁其对应的<strong>客户端连接</strong>的逻辑。以&nbsp;<strong>Zookeeper</strong>Registry 举例子。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 调用父方法，取消注册和订阅</span></span><br /><span class="line">    <span class="keyword">super</span>.destroy();</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        <span class="comment">// 关闭 Zookeeper 客户端连接</span></span><br /><span class="line">        zkClient.close();</span><br /><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">        logger.warn(<span class="string">"Failed to close zookeeper client "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<h2 id="2-2-DubboProtocol">2.2 DubboProtocol</h2>
<p><code>#destroy()</code>&nbsp;方法，销毁<strong>所有</strong>通信 ExchangeClient 和 ExchangeServer 。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"> <span class="number">2</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">// 销毁所有 ExchangeServer</span></span><br /><span class="line"> <span class="number">5</span>:     <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(serverMap.keySet())) {</span><br /><span class="line"> <span class="number">6</span>:         ExchangeServer server = serverMap.remove(key);</span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">if</span> (server != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">8</span>:             <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">9</span>:                 <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line"><span class="number">10</span>:                     logger.info(<span class="string">"Close dubbo server: "</span> + server.getLocalAddress());</span><br /><span class="line"><span class="number">11</span>:                 }</span><br /><span class="line"><span class="number">12</span>:                 server.close(ConfigUtils.getServerShutdownTimeout());</span><br /><span class="line"><span class="number">13</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">14</span>:                 logger.warn(t.getMessage(), t);</span><br /><span class="line"><span class="number">15</span>:             }</span><br /><span class="line"><span class="number">16</span>:         }</span><br /><span class="line"><span class="number">17</span>:     }</span><br /><span class="line"><span class="number">18</span>: </span><br /><span class="line"><span class="number">19</span>:     <span class="comment">// 销毁所有 ExchangeClient</span></span><br /><span class="line"><span class="number">20</span>:     <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(referenceClientMap.keySet())) {</span><br /><span class="line"><span class="number">21</span>:         ExchangeClient client = referenceClientMap.remove(key);</span><br /><span class="line"><span class="number">22</span>:         <span class="keyword">if</span> (client != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">23</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">24</span>:                 <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line"><span class="number">25</span>:                     logger.info(<span class="string">"Close dubbo connect: "</span> + client.getLocalAddress() + <span class="string">"--&gt;"</span> + client.getRemoteAddress());</span><br /><span class="line"><span class="number">26</span>:                 }</span><br /><span class="line"><span class="number">27</span>:                 client.close(ConfigUtils.getServerShutdownTimeout()); <span class="comment">// 销毁</span></span><br /><span class="line"><span class="number">28</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">29</span>:                 logger.warn(t.getMessage(), t);</span><br /><span class="line"><span class="number">30</span>:             }</span><br /><span class="line"><span class="number">31</span>:         }</span><br /><span class="line"><span class="number">32</span>:     }</span><br /><span class="line"><span class="number">33</span>:     <span class="comment">// 销毁所有幽灵 ExchangeClient</span></span><br /><span class="line"><span class="number">34</span>:     <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(ghostClientMap.keySet())) {</span><br /><span class="line"><span class="number">35</span>:         ExchangeClient client = ghostClientMap.remove(key);</span><br /><span class="line"><span class="number">36</span>:         <span class="keyword">if</span> (client != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">37</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">38</span>:                 <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line"><span class="number">39</span>:                     logger.info(<span class="string">"Close dubbo connect: "</span> + client.getLocalAddress() + <span class="string">"--&gt;"</span> + client.getRemoteAddress());</span><br /><span class="line"><span class="number">40</span>:                 }</span><br /><span class="line"><span class="number">41</span>:                 client.close(ConfigUtils.getServerShutdownTimeout()); <span class="comment">// 销毁</span></span><br /><span class="line"><span class="number">42</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">43</span>:                 logger.warn(t.getMessage(), t);</span><br /><span class="line"><span class="number">44</span>:             }</span><br /><span class="line"><span class="number">45</span>:         }</span><br /><span class="line"><span class="number">46</span>:     }</span><br /><span class="line"><span class="number">47</span>:     <span class="comment">// 【TODO 8033】 参数回调</span></span><br /><span class="line"><span class="number">48</span>:     stubServiceMethodsMap.clear();</span><br /><span class="line"><span class="number">49</span>:     <span class="keyword">super</span>.destroy();</span><br /><span class="line"><span class="number">50</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>实际情况下，一个应用程序即可以是服务<strong>提供者</strong>，又是服务<strong>消费者</strong>。因此，需要关闭 ExchangeClient 和 ExchangeServer 。</li>
<li>第 4 至 17 行：<strong>循环</strong>调用&nbsp;<code>HeaderExchangeServer#close(timeout)</code>&nbsp;方法，销毁所有 ExchangeServer 。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2.2.1 HeaderExchangeServer」</a>&nbsp;。</li>
<li>第 19 至 32 行：<strong>循环</strong>调用&nbsp;<code>ReferenceCountExchangeClient#close(timeout)</code>&nbsp;方法，销毁所有 ReferenceCountExchangeClient 。<strong>在该方法内部</strong>，会调用&nbsp;<code>HeaderExchangeClient#close(timeout)</code>&nbsp;方法，关闭 HeaderExchangeClient 对象。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2.2.2 HeaderExchangeClient」</a>&nbsp;。</li>
<li>第 33 至 46 行：<strong>循环</strong>调用&nbsp;<code>LazyConnectExchangeClient#close(timeout)</code>&nbsp;方法，进行关闭。关于 LazyConnectExchangeClient ，详细见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/?self">精尽 Dubbo 源码分析 &mdash;&mdash; 服务引用（二）之远程引用（Dubbo）</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「5.2 LazyConnectExchangeClient」</a>&nbsp;。</li>
<li>第 48 行：【TODO 8033】 参数回调</li>
<li>
<p>第 49 行：调用<strong>父</strong>&nbsp;<code>AbstractExporter#unexport()</code>&nbsp;方法，取消服务的暴露( Exporter )。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">//  销毁协议对应的服务消费者的所有 Invoker</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">for</span> (Invoker&lt;?&gt; invoker : invokers) {</span><br /><span class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">6</span>:             invokers.remove(invoker);</span><br /><span class="line"> <span class="number">7</span>:             <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">8</span>:                 <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line"> <span class="number">9</span>:                     logger.info(<span class="string">"Destroy reference: "</span> + invoker.getUrl());</span><br /><span class="line"><span class="number">10</span>:                 }</span><br /><span class="line"><span class="number">11</span>:                 invoker.destroy();</span><br /><span class="line"><span class="number">12</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">13</span>:                 logger.warn(t.getMessage(), t);</span><br /><span class="line"><span class="number">14</span>:             }</span><br /><span class="line"><span class="number">15</span>:         }</span><br /><span class="line"><span class="number">16</span>:     }</span><br /><span class="line"><span class="number">17</span>:     <span class="comment">// 销毁协议对应的服务提供者的所有 Exporter</span></span><br /><span class="line"><span class="number">18</span>:     <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(exporterMap.keySet())) {</span><br /><span class="line"><span class="number">19</span>:         Exporter&lt;?&gt; exporter = exporterMap.remove(key);</span><br /><span class="line"><span class="number">20</span>:         <span class="keyword">if</span> (exporter != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">21</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">22</span>:                 <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line"><span class="number">23</span>:                     logger.info(<span class="string">"Unexport service: "</span> + exporter.getInvoker().getUrl());</span><br /><span class="line"><span class="number">24</span>:                 }</span><br /><span class="line"><span class="number">25</span>:                 exporter.unexport();</span><br /><span class="line"><span class="number">26</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">27</span>:                 logger.warn(t.getMessage(), t);</span><br /><span class="line"><span class="number">28</span>:             }</span><br /><span class="line"><span class="number">29</span>:         }</span><br /><span class="line"><span class="number">30</span>:     }</span><br /><span class="line"><span class="number">31</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 至 16 行：<strong>循环</strong>，销毁<strong>协议( 此处为 DubboProtocol )对应</strong>的服务<em>消费者</em>的所有 Invoker<strong>( 此处为 DubboInvoker )</strong>&nbsp;。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2.2.3 DubboInvoker」</a>&nbsp;。</li>
<li>第 17 至 30 行：<strong>循环</strong>，销毁<strong>协议( 此处为 DubboProtocol )对应</strong>的服务<em>提供者</em>的所有 Exporter<strong>( 此处为 DubboExporter )</strong>&nbsp;。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2.2.4 DubboExporter」</a>&nbsp;。</li>
</ul>
</li>
</ul>
<h3 id="2-2-1-HeaderExchangeServer">2.2.1 HeaderExchangeServer</h3>
<p><code>#close(timeout)</code>&nbsp;方法，整体流程如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_06_01/01.png" alt="close" /></p>
<ul>
<li>
<p><strong>红</strong>框部分：因为 ProtocolListenerWrapper 和 ProtocolFilterWrapper 和&nbsp;<strong>Protocol 的 Dubbo SPI Wrapper 实现类</strong>，所以调用&nbsp;<code>DubboProtocol#destroy()</code>&nbsp;方法时，会先调用它们。目前仅仅是一层包装，没有逻辑 😈 ，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="comment">// ProtocolListenerWrapper.java</span></span><br /><span class="line"> <span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">    protocol.destroy();</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// ProtocolFilterWrapper.java</span></span><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">    protocol.destroy();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<ul>
<li><strong>绿</strong>框部分：HeaderExchangeServer 的<strong>优雅</strong>关闭流程，详细解析见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-api-exchange/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（四）之 Exchange 层》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「4.1.4 优雅关闭」</a>&nbsp;。</li>
<li><strong>黄</strong>框部分：NettyServer 关闭<strong>真正</strong>&nbsp;Netty 相关<strong>服务器</strong>组件，详细解析见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-impl-netty4//?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（六）之 Netty4 实现》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「关闭服务器」</a>&nbsp;。</li>
<li>ExecutorUtil 提供了两种<strong>关闭</strong>方法，在本文的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「3. ExecutorUtil」</a>&nbsp;详细解析 。</li>
</ul>
<h3 id="2-2-2-HeaderExchangeClient">2.2.2 HeaderExchangeClient</h3>
<p><code>#close(timeout)</code>&nbsp;方法，整体流程如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_06_01/02.png" alt="close" /></p>
<ul>
<li><strong>红</strong>框部分：HeaderExchangeClient 的<strong>优雅</strong>关闭流程，详细解析见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-api-exchange/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（四）之 Exchange 层》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「2.1.3 优雅关闭」</a>。</li>
<li><strong>绿</strong>框部分：NettyClient 关闭<strong>真正</strong>&nbsp;Netty 相关<strong>客户端</strong>组件，详细解析见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-impl-netty4//?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（六）之 Netty4 实现》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/graceful-shutdown/">「关闭通道」</a>&nbsp;。</li>
</ul>
<h3 id="2-2-3-DubboInvoker">2.2.3 DubboInvoker</h3>
<p><code>#destroy()</code>&nbsp;方法，销毁 ExchangeClient 。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 忽略，若已经销毁</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (<span class="keyword">super</span>.isDestroyed()) {</span><br /><span class="line"> <span class="number">5</span>:         <span class="keyword">return</span>;</span><br /><span class="line"> <span class="number">6</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">7</span>:         <span class="comment">// double check to avoid dup close</span></span><br /><span class="line"> <span class="number">8</span>:         <span class="comment">// 双重锁校验，避免已经关闭</span></span><br /><span class="line"> <span class="number">9</span>:         destroyLock.lock();</span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">11</span>:             <span class="keyword">if</span> (<span class="keyword">super</span>.isDestroyed()) {</span><br /><span class="line"><span class="number">12</span>:                 <span class="keyword">return</span>;</span><br /><span class="line"><span class="number">13</span>:             }</span><br /><span class="line"><span class="number">14</span>:             <span class="comment">// 标记关闭</span></span><br /><span class="line"><span class="number">15</span>:             <span class="keyword">super</span>.destroy();</span><br /><span class="line"><span class="number">16</span>:             <span class="comment">// 移除出 `invokers`</span></span><br /><span class="line"><span class="number">17</span>:             <span class="keyword">if</span> (invokers != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">18</span>:                 invokers.remove(<span class="keyword">this</span>);</span><br /><span class="line"><span class="number">19</span>:             }</span><br /><span class="line"><span class="number">20</span>:             <span class="comment">// 关闭 ExchangeClient 们</span></span><br /><span class="line"><span class="number">21</span>:             <span class="keyword">for</span> (ExchangeClient client : clients) {</span><br /><span class="line"><span class="number">22</span>:                 <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">23</span>:                     client.close(ConfigUtils.getServerShutdownTimeout());</span><br /><span class="line"><span class="number">24</span>:                 } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">25</span>:                     logger.warn(t.getMessage(), t);</span><br /><span class="line"><span class="number">26</span>:                 }</span><br /><span class="line"><span class="number">27</span>:             }</span><br /><span class="line"><span class="number">28</span>:         } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">29</span>:             <span class="comment">// 释放锁</span></span><br /><span class="line"><span class="number">30</span>:             destroyLock.unlock();</span><br /><span class="line"><span class="number">31</span>:         }</span><br /><span class="line"><span class="number">32</span>:     }</span><br /><span class="line"><span class="number">33</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>代码比较易懂，胖友看代码注释。下面只挑选几个方法分享。</li>
<li>
<p><strong>父</strong>&nbsp;<code>AbstractInvoker#isDestroyed()</code>&nbsp;方法，判断是否已经销毁。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否销毁</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDestroyed</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> destroyed.get();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><strong>父</strong>&nbsp;<code>AbstractInvoker#destroy()</code>&nbsp;方法，标记已经销毁。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否可用</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> available = <span class="keyword">true</span>;</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    setAvailable(<span class="keyword">false</span>);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setAvailable</span><span class="params">(<span class="keyword">boolean</span> available)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>.available = available;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>并且，会标记 DubboInvoker 已经<strong>不可用</strong>。</li>
<li>
<p>标记已经销毁后，再调用&nbsp;<code>#invoke(Invocation)</code>&nbsp;方法，会抛出 RpcException 异常。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">    <span class="keyword">if</span> (destroyed.get()) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Rpc invoker for service "</span> + <span class="keyword">this</span> + <span class="string">" on consumer "</span> + NetUtils.getLocalHost()</span><br /><span class="line">                + <span class="string">" use dubbo version "</span> + Version.getVersion()</span><br /><span class="line">                + <span class="string">" is DESTROYED, can not be invoked any more!"</span>);</span><br /><span class="line">    }</span><br />    <br /><span class="line">    <span class="comment">// ... 省略其他代码</span></span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>x</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第 20 至 27 行：<strong>循环</strong>，调用&nbsp;<code>ReferenceCountExchangeClient#close(timeout)</code>&nbsp;方法，关闭客户端。😈 实际上，在&nbsp;<code>DubboProtocol#destroy()</code>&nbsp;方法中，已经关闭客户端。虽然看起来重复，实际不然。因为远程服务提供者关闭时， DubboInvoker 需要进行销毁，此时必须关闭客户端的链接。所以，DubboInvoker 必须有这块逻辑。</p>
</li>
</ul>
<h3 id="2-2-4-DubboExporter">2.2.4 DubboExporter</h3>
<p><code>#unexport()</code>&nbsp;方法，取消暴露。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 服务键</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Exporter 集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key: 服务键</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 该值实际就是 {<span class="doctag">@link</span> com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap}</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 取消暴露</span></span><br /><span class="line">    <span class="keyword">super</span>.unexport();</span><br /><span class="line">    <span class="comment">// 移除自己</span></span><br /><span class="line">    exporterMap.remove(key);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>调用<strong>父</strong>&nbsp;<code>AbstractExporter#unexport()</code>&nbsp;方法，取消暴露。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Invoker 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;T&gt; invoker;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否取消暴露服务</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unexported = <span class="keyword">false</span>;</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 标记已经取消暴露</span></span><br /><span class="line">    <span class="keyword">if</span> (unexported) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    unexported = <span class="keyword">true</span>;</span><br /><span class="line">    <span class="comment">// 销毁</span></span><br /><span class="line">    getInvoker().destroy();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>其中，<code>invoker</code>&nbsp;如下图所示：<img src="http://static2.iocoder.cn/images/Dubbo/2019_06_01/03.png" alt="invoker" /></p>
<ul>
<li>
<p>这个 Invoker 通过 JavassistProxyFactory 创建，实际实现了 AbstractProxyInvoker 抽象类。所以&nbsp;<code>#destroy()</code>&nbsp;方法如下，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>😈 空的，嘿嘿嘿。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-RegistryProtocol">2.3 RegistryProtocol</h2>
<p><code>#destroy()</code>&nbsp;方法，取消所有 Exporter 的暴露。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 绑定关系集合。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key：服务 Dubbo URL</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ExporterChangeableWrapper&lt;?&gt;&gt; bounds = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ExporterChangeableWrapper&lt;?&gt;&gt;();</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 获得 Exporter 数组</span></span><br /><span class="line">    List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;(bounds.values());</span><br /><span class="line">    <span class="comment">// 取消所有 Exporter 的暴露</span></span><br /><span class="line">    <span class="keyword">for</span> (Exporter&lt;?&gt; exporter : exporters) {</span><br /><span class="line">        exporter.unexport();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 清空</span></span><br /><span class="line">    bounds.clear();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><strong>循环</strong>，调用&nbsp;<code>ExporterChangeableWrapper#unexport()</code>&nbsp;方法，取消服务<strong>暴露</strong>。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 暴露的 Exporter 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Exporter&lt;T&gt; exporter;</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>{</span><br /><span class="line">    String key = getCacheKey(<span class="keyword">this</span>.originInvoker);</span><br /><span class="line">    <span class="comment">// 移除出 `bounds`</span></span><br /><span class="line">    bounds.remove(key);</span><br /><span class="line">    <span class="comment">// 取消暴露</span></span><br /><span class="line">    exporter.unexport();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>因为服务提供者<strong>集成</strong>了配置规则 Configurator ，所以需要使用到 ExporterChangeableWrapper ，保存原有 Invoker 对象。
<ul>
<li>也因此，上述所有取消暴露逻辑，是无法销毁 ExporterChangeableWrapper 在&nbsp;<code>bounds</code>&nbsp;的映射，需要通过 RegistryProtocol 的&nbsp;<code>#destroy()</code>&nbsp;方法实现。</li>
<li>也因此，此处调用<strong>暴露的 Exporter 对象</strong>&nbsp;<code>exporter</code>&nbsp;，已经被&nbsp;<code>AbstractExporter#unexport()</code>&nbsp;方法，取消暴露。但是呢，这里又不能去掉这块逻辑，因为没准有地方，需要调用&nbsp;<code>ExporterChangeableWrapper#unexport()</code>&nbsp;方法呢。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-ExecutorUtil">3. ExecutorUtil</h1>
<h2 id="3-1-gracefulShutdown">3.1 gracefulShutdown</h2>
<p><code>#gracefulShutdown(executor, timeout)</code>&nbsp;方法，<strong>优雅</strong>关闭，禁止新的任务提交，将原有任务执行完。</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gracefulShutdown</span><span class="params">(Executor executor, <span class="keyword">int</span> timeout)</span> </span>{</span><br /><span class="line">    <span class="comment">// 忽略，若不是 ExecutorService ，或者已经关闭</span></span><br /><span class="line">    <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isShutdown(executor)) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 关闭，禁止新的任务提交，将原有任务执行完</span></span><br /><span class="line">    <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        es.shutdown(); <span class="comment">// Disable new tasks from being submitted &lt;1&gt;</span></span><br /><span class="line">    } <span class="keyword">catch</span> (SecurityException ex2) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    } <span class="keyword">catch</span> (NullPointerException ex2) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 等待原有任务执行完。若等待超时，强制结束所有任务</span></span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        <span class="keyword">if</span> (!es.awaitTermination(timeout, TimeUnit.MILLISECONDS)) {</span><br /><span class="line">            es.shutdownNow();</span><br /><span class="line">        }</span><br /><span class="line">    } <span class="keyword">catch</span> (InterruptedException ex) {</span><br /><span class="line">        <span class="comment">// 发生 InterruptedException 异常，也强制结束所有任务</span></span><br /><span class="line">        es.shutdownNow();</span><br /><span class="line">        Thread.currentThread().interrupt();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 若未关闭成功，新开线程去关闭</span></span><br /><span class="line">    <span class="keyword">if</span> (!isShutdown(es)) {</span><br /><span class="line">        newThreadToCloseExecutor(es);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="3-2-shutdownNow">3.2 shutdownNow</h2>
<p><code>#shutdownNow(executor, timeout)</code>&nbsp;方法，<strong>强制</strong>关闭，包括<strong>打断</strong>原有执行中的任务。</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdownNow</span><span class="params">(Executor executor, <span class="keyword">final</span> <span class="keyword">int</span> timeout)</span> </span>{</span><br /><span class="line">    <span class="comment">// 忽略，若不是 ExecutorService ，或者已经关闭</span></span><br /><span class="line">    <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isShutdown(executor)) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 立即关闭，包括原有任务也打断</span></span><br /><span class="line">    <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        es.shutdownNow(); <span class="comment">// &lt;1&gt;</span></span><br /><span class="line">    } <span class="keyword">catch</span> (SecurityException ex2) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    } <span class="keyword">catch</span> (NullPointerException ex2) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 等待原有任务被打断完成</span></span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        es.awaitTermination(timeout, TimeUnit.MILLISECONDS);</span><br /><span class="line">    } <span class="keyword">catch</span> (InterruptedException ex) {</span><br /><span class="line">        Thread.currentThread().interrupt();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 若未关闭成功，新开线程去关闭</span></span><br /><span class="line">    <span class="keyword">if</span> (!isShutdown(es)) {</span><br /><span class="line">        newThreadToCloseExecutor(es);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>和&nbsp;<code>#gracefulShutdown(executor, timeout)</code>&nbsp;方法不同的是，<code>&lt;1&gt;</code>&nbsp;处调用的是&nbsp;<code>#shutdownNow()</code>&nbsp;方法，而<strong>不是</strong>&nbsp;<code>#shutdown()</code>&nbsp;方法。</li>
</ul>
<h2 id="3-3-newThreadToCloseExecutor">3.3 newThreadToCloseExecutor</h2>
<p><code>#newThreadToCloseExecutor(ExecutorService)</code>&nbsp;方法，<strong>新开</strong>线程，不断强制关闭。</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newThreadToCloseExecutor</span><span class="params">(<span class="keyword">final</span> ExecutorService es)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (!isShutdown(es)) {</span><br /><span class="line">        shutdownExecutor.execute(<span class="keyword">new</span> Runnable() {</span><br /><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br /><span class="line">                <span class="keyword">try</span> {</span><br /><span class="line">                    <span class="comment">// 循环 1000 次，不断强制结束线程池</span></span><br /><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br /><span class="line">                        <span class="comment">// 立即关闭，包括原有任务也打断</span></span><br /><span class="line">                        es.shutdownNow();</span><br /><span class="line">                        <span class="comment">// 等待原有任务被打断完成</span></span><br /><span class="line">                        <span class="keyword">if</span> (es.awaitTermination(<span class="number">10</span>, TimeUnit.MILLISECONDS)) {</span><br /><span class="line">                            <span class="keyword">break</span>;</span><br /><span class="line">                        }</span><br /><span class="line">                    }</span><br /><span class="line">                } <span class="keyword">catch</span> (InterruptedException ex) {</span><br /><span class="line">                    Thread.currentThread().interrupt();</span><br /><span class="line">                } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">                    logger.warn(e.getMessage(), e);</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        });</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="666-彩蛋">666. 彩蛋</h1>
<p><img src="http://static2.iocoder.cn/images/Architecture/2017_12_29/01.png" alt="知识星球" /></p>
<p>理论来说，服务提供者如果要关闭，大体流程如下：</p>
<blockquote>
<p>provider =&gt; registry ：移除自己<br />provider =&gt; consumer ：我准备关闭了，不要调用我<br /><strong>所有</strong>&nbsp;consumer =&gt; provider ：好的，我知道了<br />provider =&gt; consumer ：处理完所有原有请求<br />provider 关闭</p>
</blockquote>
<p>但是实际情况非常复杂，如果依赖 consumer 去应答和确认。所以 Dubbo 的选择是：</p>
<ul>
<li>provider 从 registry ，移除自己。并且 sleep 等待一定时间（开发者可配），等待 consumer 获得到通知。当然，这个过程<strong>不是绝对能够成功</strong>的。例如，consumer 连接不上 registry ，但是连的上 provider 。</li>
<li>provider 通知 consumer ，自己准备关闭，不要请求自己。全部通知完成后，等处理完原有请求。完成后，关闭本地服务器及线程池。</li>
</ul>
<p>当然，consumer 也有优雅关闭，等待所有发起的请求结束。相对简单的多。</p>
<p>推荐阅读文章：</p>
<ul>
<li><a href="https://blog.csdn.net/manzhizhen/article/details/78756370" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo源代码分析九：优雅停机》</a></li>
<li><a href="https://www.jianshu.com/p/aa22eac09d8c" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 优雅停机》</a></li>
<li><a href="https://my.oschina.net/u/1398931/blog/790709" target="_blank" rel="external nofollow noopener noreferrer">《解决dubbo优雅停机》</a></li>
</ul>
</div>
<div class="article-info article-info-index">
<div class="article-category tagcloud">
<ul class="article-tag-list">
<li class="article-tag-list-item"><a class="article-tag-list-link color1" href="http://svip.iocoder.cn/categories/Dubbo//">Dubbo</a></li>
</ul>
</div>
</div>