<h1 class="postTitle"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/lizo/p/7683300.html">springboot自定义配置源</a></h1>
<div class="clear">&nbsp;</div>
<div class="postBody">
<div id="cnblogs_post_body" class="blogpost-body">
<h1 id="概述" data-source-line="1">概述</h1>
<p data-source-line="2">我们知道，在Spring boot中可以通过xml或者@ImportResource 来引入自己的配置文件，但是这里有个限制，必须是本地，而且格式只能是 properties(或者 yaml)。那么，如果我们有远程配置，如何把他引入进来来呢。</p>
<h1 id="第一种方式" data-source-line="3">第一种方式</h1>
<p data-source-line="4">这外一种方法，相对更简单些，但是相对没那么&ldquo;优雅&rdquo;。就是通过EnvironmentPostProcessor接口把我们自定义的propertySource加入environment中，</p>
<div class="cnblogs_code">
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></span></div>
<pre>public class MyEnvironmentPostProcessor implements EnvironmentPostProcessor {
    @Override
    public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
        MyPropertySource propertySource = new MyPropertySource("myPropertySource");

        Map&lt;String, String&gt; propertyMap = new HashMap&lt;&gt;();
        propertyMap.put("myName", "lizo");
        propertySource.setProperty(propertyMap);
        environment.getPropertySources().addLast(propertySource);
    }
}</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></span></div>
</div>
<p data-source-line="5"><code class="hljs"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-title"><span class="hljs-type"><span class="hljs-string"><span class="zh-hans">同时需要在META-INFO/spring.factories中加入</span></span></span></span></span></span></code></p>
<div class="cnblogs_code">
<pre>org.springframework.boot.env.EnvironmentPostProcessor=com.lizo.MyEnvironmentPostProcessor</pre>
</div>
<h1 id="第二种方式" data-source-line="20">第二种方式</h1>
<p data-source-line="21">第二种方式可能相对比较复杂一点，其实是参考Sprng cloud中的做法，其实也只需要3步</p>
<p>&nbsp;</p>
<h2 id="第一步编写propertysource" data-source-line="6">第一步，编写PropertySource</h2>
<p data-source-line="7">编写一个类继承EnumerablePropertySource，然后实现它的抽象方法即可，抽象方法看名字就知道作用，简单起见，这里使用一个map来保存配置，例如：</p>
<div class="cnblogs_code">
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></span></div>
<pre>public class MyPropertySource extends EnumerablePropertySource&lt;Map&lt;String,String&gt;&gt; {

    public MyPropertySource(String name, Map source) {
        super(name, source);
    }

    //获取所有的配置名字
    @Override
    public String[] getPropertyNames() {
        return source.keySet().toArray(new String[source.size()]);
    }

    //根据配置返回对应的属性
    @Override
    public Object getProperty(String name) {
        return source.get(name);
    }
}</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></span></div>
</div>
<h2 id="第二步编写propertysourcelocator" data-source-line="28">第二步，编写PropertySourceLocator</h2>
<p data-source-line="29">PropertySourceLocator 其实就是用来定位我们前面的PropertySource，需要重写的方法只有一个，就是返回一个PropertySource对象，例如，</p>
<div class="cnblogs_code">
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></span></div>
<pre>public class MyPropertySourceLocator implements PropertySourceLocator {
    @Override
    public PropertySource&lt;?&gt; locate(Environment environment) {
        //简单起见，这里直接创建一个map,你可以在这里写从哪里获取配置信息。
        Map&lt;String,String&gt; properties = new HashMap&lt;&gt;();
        properties.put("myName","lizo");

        MyPropertySource myPropertySource = new MyPropertySource("myPropertySource",properties);
        return myPropertySource;
    }
}</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></span></div>
</div>
<h2 id="第三步让propertysourcelocator生效" data-source-line="43">第三步，让PropertySourceLocator生效</h2>
<p data-source-line="44">新建一个配置类，例如</p>
<div class="cnblogs_code">
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></span></div>
<pre>@Configuration
public class MyConfigBootstrapConfiguration {

    @Bean
    public MyPropertySourceLocator myPropertySourceLocator(){
        return new MyPropertySourceLocator();
    }
}</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></span></div>
</div>
<p data-source-line="55">最后再创建/更新 META-INFO/spring.factories(如果做过自定义Spring boot开发的都知道这个文件)</p>
<div class="cnblogs_code">
<pre>org.springframework.cloud.bootstrap.BootstrapConfiguration=\
com.lizo.MyConfigBootstrapConfiguration</pre>
</div>
<p data-source-line="60">简单来说就是给Spring Boot说，这个是一个启动配置类（一种优先级很高的配置类）。</p>
<h1 id="编写测试" data-source-line="61">编写测试</h1>
<h2 id="测试一" data-source-line="62">测试一</h2>
<div class="cnblogs_code">
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></span></div>
<pre>@SpringBootApplication
public class Test2 {

    public static void main(String[] args) throws SQLException {
        ConfigurableApplicationContext run = SpringApplication.run(Test2.class, args);
        Ser bean = run.getBean(Ser.class);
        System.out.println(bean.getMyName());
    }

    @Component
    public static class Ser{
        @Value("${myName}")
        private String myName;

        public String getMyName() {
            return myName;
        }

        public void setMyName(String myName) {
            this.myName = myName;
        }
    }
}</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></span></div>
</div>
<p>正确输出</p>
<h2 id="测试二" data-source-line="88">测试二</h2>
<p data-source-line="89">我们在application配置文件中，引入这个变量呢，例如在application.properties中</p>
<div class="cnblogs_code">
<pre>my.name=${myName}</pre>
</div>
<p data-source-line="93">同样，结果也是能够生效的</p>
<p data-source-line="95">myName就是上面在PropertySourceLocator中写进去的配置属性。运行程序，可以看见确实是可以正确输出。</p>
<h1 id="小结" data-source-line="96">小结</h1>
<p data-source-line="97">上面只是抛砖引玉，这样无论是哪里的数据源，都可以通过这种方式编写，把配置交给Spring 管理。这样再也不怕在本地配置文件中出现敏感信息啦，再也不怕修改配置文件需要登录每一个机器修改啦。</p>
</div>
</div>