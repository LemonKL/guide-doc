<header class="article-header">
<h1 class="article-title">注册中心（二）之 Zookeeper</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>前置阅读文章：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Dubbo/remoting-zookeeper/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; Zookeeper 客户端》</a></li>
<li><a href="http://svip.iocoder.cn/Dubbo/registry-api/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 注册中心（一）之抽象 API》</a></li>
</ul>
<p>😈 在《注册中心（一）之抽象 API》 中，我们分享的那是<strong>相当抽象</strong>。因此，在本文中，我们会分享 Dubbo 使用 Zookeeper 作为注册中心的代码，同时也会分享服务暴露和引用时，对注册中心的使用。</p>
<p>下面，我们先来看下&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/references/registry/zookeeper.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; zookeeper 注册中心》</a>&nbsp;文档，内容如下：</p>
<blockquote>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_08_04/01.png" alt="流程" /></p>
<p>流程说明：</p>
<ul>
<li>
<p><strong>服务提供者</strong>启动时: 向&nbsp;<code>/dubbo/com.foo.BarService/providers</code>&nbsp;目录下写入自己的 URL 地址</p>
</li>
<li>
<p><strong>服务消费者</strong>启动时: 订阅&nbsp;<code>/dubbo/com.foo.BarService/providers</code>&nbsp;目录下的提供者 URL 地址。并向&nbsp;<code>/dubbo/com.foo.BarService/consumers</code>&nbsp;目录下写入自己的 URL 地址</p>
</li>
<li>
<p><strong>监控中心</strong>启动时: 订阅&nbsp;<code>/dubbo/com.foo.BarService</code>&nbsp;目录下的所有提供者和消费者 URL 地址。</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>在图中，我们可以看到 Zookeeper 的节点层级，自上而下是：</p>
<ul>
<li><strong>Root</strong>&nbsp;层：根目录，可通过&nbsp;<code>&lt;dubbo:registry group="dubbo" /&gt;</code>&nbsp;的&nbsp;<code>"group"</code>&nbsp;设置 Zookeeper 的根节点，缺省使用&nbsp;<code>"dubbo"</code>&nbsp;。</li>
<li><strong>Service</strong>&nbsp;层：服务接口全名。</li>
<li><strong>Type</strong>&nbsp;层：分类。目前除了我们在图中看到的&nbsp;<code>"providers"</code>( 服务提供者列表 )&nbsp;<code>"consumers"</code>( 服务消费者列表 ) 外，还有&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html" target="_blank" rel="external nofollow noopener noreferrer"><code>"routes"</code></a>( 路由规则列表 ) 和&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/config-rule.html" target="_blank" rel="external nofollow noopener noreferrer"><code>"configurations"</code></a>( 配置规则列表 )。</li>
<li><strong>URL</strong>&nbsp;层：URL ，根据不同 Type 目录，下面可以是服务提供者 URL 、服务消费者 URL 、路由规则 URL 、配置规则 URL 。</li>
<li>实际上 URL 上带有&nbsp;<code>"category"</code>&nbsp;参数，已经能判断每个 URL 的分类，但是 Zookeeper 是基于节点目录订阅的，所以增加了&nbsp;<strong>Type</strong>&nbsp;层。</li>
</ul>
</li>
<li>
<p>实际上，<strong>服务消费者</strong>启动后，不仅仅订阅了&nbsp;<code>"providers"</code>&nbsp;分类，也订阅了&nbsp;<code>"routes"</code>&nbsp;<code>"configurations"</code>&nbsp;分类。</p>
</li>
</ul>
<h1 id="2-ZookeeperRegistryFactory">2. ZookeeperRegistryFactory</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/66a1e1b0ef4b01175be148d27fdcf519f4f01b15/dubbo-registry/dubbo-registry-zookeeper/src/main/java/com/alibaba/dubbo/registry/zookeeper/ZookeeperRegistryFactory.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistryFactory</code></a>&nbsp;，实现 AbstractRegistryFactory 抽象类，Zookeeper Registry 工厂。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistryFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRegistryFactory</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Zookeeper 工厂</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> ZookeeperTransporter zookeeperTransporter;</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 设置 Zookeeper 工厂</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 该方法，通过 Dubbo SPI 注入</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> zookeeperTransporter Zookeeper 工厂对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZookeeperTransporter</span><span class="params">(ZookeeperTransporter zookeeperTransporter)</span> </span>{</span><br /><span class="line">        <span class="keyword">this</span>.zookeeperTransporter = zookeeperTransporter;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="3-ZookeeperRegistry">3. ZookeeperRegistry</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/66a1e1b0ef4b01175be148d27fdcf519f4f01b15/dubbo-registry/dubbo-registry-zookeeper/src/main/java/com/alibaba/dubbo/registry/zookeeper/ZookeeperRegistry.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry</code></a>&nbsp;，实现 FailbackRegistry 抽象类，Zookeeper Registry 。</p>
<h2 id="3-1-属性-构造方法">3.1 属性 + 构造方法</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 2:  * 默认端口</span></span><br /><span class="line"><span class="comment"> 3:  */</span></span><br /><span class="line"> <span class="number">4</span>: <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_ZOOKEEPER_PORT = <span class="number">2181</span>;</span><br /><span class="line"> <span class="number">5</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment"> 6:  * 默认 Zookeeper 根节点</span></span><br /><span class="line"><span class="comment"> 7:  */</span></span><br /><span class="line"> <span class="number">8</span>: <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_ROOT = <span class="string">"dubbo"</span>;</span><br /><span class="line"> <span class="number">9</span>: </span><br /><span class="line"><span class="number">10</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">11:  * Zookeeper 根节点</span></span><br /><span class="line"><span class="comment">12:  */</span></span><br /><span class="line"><span class="number">13</span>: <span class="keyword">private</span> <span class="keyword">final</span> String root;</span><br /><span class="line"><span class="number">14</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">15:  * Service 接口全名集合</span></span><br /><span class="line"><span class="comment">16:  */</span></span><br /><span class="line"><span class="number">17</span>: <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; anyServices = <span class="keyword">new</span> ConcurrentHashSet&lt;String&gt;();</span><br /><span class="line"><span class="number">18</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">19:  * 监听器集合</span></span><br /><span class="line"><span class="comment">20:  */</span></span><br /><span class="line"><span class="number">21</span>: <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt;();</span><br /><span class="line"><span class="number">22</span>: <span class="comment">/**</span></span><br /><span class="line"><span class="comment">23:  * Zookeeper 客户端</span></span><br /><span class="line"><span class="comment">24:  */</span></span><br /><span class="line"><span class="number">25</span>: <span class="keyword">private</span> <span class="keyword">final</span> ZookeeperClient zkClient;</span><br /><span class="line"><span class="number">26</span>: </span><br /><span class="line"><span class="number">27</span>: <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>{</span><br /><span class="line"><span class="number">28</span>:     <span class="keyword">super</span>(url);</span><br /><span class="line"><span class="number">29</span>:     <span class="keyword">if</span> (url.isAnyHost()) {</span><br /><span class="line"><span class="number">30</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br /><span class="line"><span class="number">31</span>:     }</span><br /><span class="line"><span class="number">32</span>:     <span class="comment">// 获得 Zookeeper 根节点</span></span><br /><span class="line"><span class="number">33</span>:     String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT); <span class="comment">// `url.parameters.group` 参数值</span></span><br /><span class="line"><span class="number">34</span>:     <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) {</span><br /><span class="line"><span class="number">35</span>:         group = Constants.PATH_SEPARATOR + group;</span><br /><span class="line"><span class="number">36</span>:     }</span><br /><span class="line"><span class="number">37</span>:     <span class="keyword">this</span>.root = group;</span><br /><span class="line"><span class="number">38</span>:     <span class="comment">// 创建 Zookeeper Client</span></span><br /><span class="line"><span class="number">39</span>:     zkClient = zookeeperTransporter.connect(url);</span><br /><span class="line"><span class="number">40</span>:     <span class="comment">// 添加 StateListener 对象。该监听器，在重连时，调用恢复方法。</span></span><br /><span class="line"><span class="number">41</span>:     zkClient.addStateListener(<span class="keyword">new</span> StateListener() {</span><br /><span class="line"><span class="number">42</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>{</span><br /><span class="line"><span class="number">43</span>:             <span class="keyword">if</span> (state == RECONNECTED) {</span><br /><span class="line"><span class="number">44</span>:                 <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">45</span>:                     recover();</span><br /><span class="line"><span class="number">46</span>:                 } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line"><span class="number">47</span>:                     logger.error(e.getMessage(), e);</span><br /><span class="line"><span class="number">48</span>:                 }</span><br /><span class="line"><span class="number">49</span>:             }</span><br /><span class="line"><span class="number">50</span>:         }</span><br /><span class="line"><span class="number">51</span>:     });</span><br /><span class="line"><span class="number">52</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>root</code>&nbsp;属性，Zookeeper 根节点，即首图的&nbsp;<strong>Root</strong>&nbsp;层。</li>
<li><code>anyServices</code>&nbsp;属性，Service 接口接口全名<strong>集合</strong>。该属性适可用于监控中心，订阅<strong>整个</strong>&nbsp;<strong>Service</strong>&nbsp;层。因为，Service 层是<strong>动态</strong>的，可以有不断有新的 Service 服务发布（注意，不是服务实例）。在&nbsp;<code>#doSubscribe(url, notifyListener)</code>&nbsp;方法中，会更容易理解。</li>
<li><code>zkListeners</code>&nbsp;属性，监听器集合，建立 NotifyListener 和 ChildListener 的映射关系。</li>
<li><code>zkClient</code>&nbsp;属性，Zookeeper 客户端。</li>
<li><strong>构造方法</strong>
<ul>
<li>第 28 至 31 行：设置注册中心的 URL 。</li>
<li>第 32 至 37 行：设置在 Zookeeper 的根节点，缺省使用&nbsp;<code>DEFAULT_ROOT</code>&nbsp;。</li>
<li>第 39 行：调用&nbsp;<code>ZookeeperTransporter#connect(url)</code>&nbsp;方法，基于 Dubbo SPI Adaptive 机制，根据&nbsp;<code>url</code>&nbsp;参数，加载对应的 ZookeeperTransporter 实现类，创建对应的 ZookeeperClient 实现类的对应。</li>
<li>第 41 至 51 行：添加 StateListener 对象到 ZookeeperClient 对象中。该监听器，在重连时，在第 45 行的代码，调用&nbsp;<code>#recover()</code>&nbsp;方法，进行恢复逻辑，重新发起注册和订阅。</li>
</ul>
</li>
</ul>
<h2 id="3-2-doRegister">3.2 doRegister</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"><span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line"><span class="number">3</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">4</span>:         zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br /><span class="line"><span class="number">5</span>:     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">6</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br /><span class="line"><span class="number">7</span>:     }</span><br /><span class="line"><span class="number">8</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 4 行：调用&nbsp;<code>#toUrlPath(url)</code>&nbsp;方法，获得 URL 的路径。</li>
<li>第 4 行：<code>url.parameters.dynamic</code>&nbsp;，是否动态数据。若为 false ，该数据为<strong>持久数据</strong>，当注册方退出时，数据依然保存在注册中心。</li>
<li>第 4 行：调用&nbsp;<code>ZookeeperClient#create(url, ephemeral)</code>&nbsp;方法，创建 URL 节点，即我们在首图看到的&nbsp;<strong>URL 层</strong>。</li>
</ul>
<h3 id="3-2-1-toUrlPath">3.2.1 toUrlPath</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 获得 URL 的路径</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * Root + Service + Type + URL</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 被 {<span class="doctag">@link</span> #doRegister(URL)} 和 {<span class="doctag">@link</span> #doUnregister(URL)} 调用</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> url URL</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 路径</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">toUrlPath</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> toCategoryPath(url) + Constants.PATH_SEPARATOR + URL.encode(url.toFullString());</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="3-2-2-toCategoryPath">3.2.2 toCategoryPath</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 获得分类路径</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * Root + Service + Type</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> url URL</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分类路径</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">toCategoryPath</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> toServicePath(url) + Constants.PATH_SEPARATOR + url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="3-2-3-toServicePath">3.2.3 toServicePath</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 获得服务路径</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * Root + Type</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> url URL</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 服务路径</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">toServicePath</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">    String name = url.getServiceInterface();</span><br /><span class="line">    <span class="keyword">if</span> (Constants.ANY_VALUE.equals(name)) {</span><br /><span class="line">        <span class="keyword">return</span> toRootPath();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> toRootDir() + URL.encode(name);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="3-2-4-toRootDir">3.2.4 toRootDir</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 获得根目录</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * Root</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 路径</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">toRootDir</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (root.equals(Constants.PATH_SEPARATOR)) {</span><br /><span class="line">        <span class="keyword">return</span> root;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> root + Constants.PATH_SEPARATOR;</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Root</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根路径</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">toRootPath</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> root;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="3-3-doUnregister">3.3 doUnregister</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        zkClient.delete(toUrlPath(url));</span><br /><span class="line">    } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to unregister "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="3-4-doSubscribe">3.4 doSubscribe</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">4</span>:         <span class="comment">// 处理所有 Service 层的发起订阅，例如监控中心的订阅</span></span><br /><span class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getServiceInterface())) {</span><br /><span class="line"> <span class="number">6</span>:             String root = toRootPath();</span><br /><span class="line"> <span class="number">7</span>:             <span class="comment">// 获得 url 对应的监听器集合</span></span><br /><span class="line"> <span class="number">8</span>:             ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br /><span class="line"> <span class="number">9</span>:             <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) { <span class="comment">// 不存在，进行创建</span></span><br /><span class="line"><span class="number">10</span>:                 zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;());</span><br /><span class="line"><span class="number">11</span>:                 listeners = zkListeners.get(url);</span><br /><span class="line"><span class="number">12</span>:             }</span><br /><span class="line"><span class="number">13</span>:             <span class="comment">// 获得 ChildListener 对象</span></span><br /><span class="line"><span class="number">14</span>:             ChildListener zkListener = listeners.get(listener);</span><br /><span class="line"><span class="number">15</span>:             <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) { <span class="comment">// 不存在 ChildListener 对象，进行创建 ChildListener 对象</span></span><br /><span class="line"><span class="number">16</span>:                 listeners.putIfAbsent(listener, <span class="keyword">new</span> ChildListener() {</span><br /><span class="line"><span class="number">17</span>:                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childChanged</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> </span>{</span><br /><span class="line"><span class="number">18</span>:                         <span class="keyword">for</span> (String child : currentChilds) {</span><br /><span class="line"><span class="number">19</span>:                             child = URL.decode(child);</span><br /><span class="line"><span class="number">20</span>:                             <span class="comment">// 新增 Service 接口全名时（即新增服务），发起该 Service 层的订阅</span></span><br /><span class="line"><span class="number">21</span>:                             <span class="keyword">if</span> (!anyServices.contains(child)) {</span><br /><span class="line"><span class="number">22</span>:                                 anyServices.add(child);</span><br /><span class="line"><span class="number">23</span>:                                 subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY, child,</span><br /><span class="line"><span class="number">24</span>:                                         Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br /><span class="line"><span class="number">25</span>:                             }</span><br /><span class="line"><span class="number">26</span>:                         }</span><br /><span class="line"><span class="number">27</span>:                     }</span><br /><span class="line"><span class="number">28</span>:                 });</span><br /><span class="line"><span class="number">29</span>:                 zkListener = listeners.get(listener);</span><br /><span class="line"><span class="number">30</span>:             }</span><br /><span class="line"><span class="number">31</span>:             <span class="comment">// 创建 Service 节点。该节点为持久节点。</span></span><br /><span class="line"><span class="number">32</span>:             zkClient.create(root, <span class="keyword">false</span>);</span><br /><span class="line"><span class="number">33</span>:             <span class="comment">// 向 Zookeeper ，Service 节点，发起订阅</span></span><br /><span class="line"><span class="number">34</span>:             List&lt;String&gt; services = zkClient.addChildListener(root, zkListener);</span><br /><span class="line"><span class="number">35</span>:             <span class="comment">// 首次全量数据获取完成时，循环 Service 接口全名数组，发起该 Service 层的订阅</span></span><br /><span class="line"><span class="number">36</span>:             <span class="keyword">if</span> (services != <span class="keyword">null</span> &amp;&amp; !services.isEmpty()) {</span><br /><span class="line"><span class="number">37</span>:                 <span class="keyword">for</span> (String service : services) {</span><br /><span class="line"><span class="number">38</span>:                     service = URL.decode(service);</span><br /><span class="line"><span class="number">39</span>:                     anyServices.add(service);</span><br /><span class="line"><span class="number">40</span>:                     subscribe(url.setPath(service).addParameters(Constants.INTERFACE_KEY, service,</span><br /><span class="line"><span class="number">41</span>:                             Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br /><span class="line"><span class="number">42</span>:                 }</span><br /><span class="line"><span class="number">43</span>:             }</span><br /><span class="line"><span class="number">44</span>:         <span class="comment">// 处理指定 Service 层的发起订阅，例如服务消费者的订阅</span></span><br /><span class="line"><span class="number">45</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">46</span>:             <span class="comment">// 子节点数据数组</span></span><br /><span class="line"><span class="number">47</span>:             List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br /><span class="line"><span class="number">48</span>:             <span class="comment">// 循环分类数组</span></span><br /><span class="line"><span class="number">49</span>:             <span class="keyword">for</span> (String path : toCategoriesPath(url)) {</span><br /><span class="line"><span class="number">50</span>:                 <span class="comment">// 获得 url 对应的监听器集合</span></span><br /><span class="line"><span class="number">51</span>:                 ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br /><span class="line"><span class="number">52</span>:                 <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) { <span class="comment">// 不存在，进行创建</span></span><br /><span class="line"><span class="number">53</span>:                     zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;());</span><br /><span class="line"><span class="number">54</span>:                     listeners = zkListeners.get(url);</span><br /><span class="line"><span class="number">55</span>:                 }</span><br /><span class="line"><span class="number">56</span>:                 <span class="comment">// 获得 ChildListener 对象</span></span><br /><span class="line"><span class="number">57</span>:                 ChildListener zkListener = listeners.get(listener);</span><br /><span class="line"><span class="number">58</span>:                 <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) { <span class="comment">// 不存在 ChildListener 对象，进行创建 ChildListener 对象</span></span><br /><span class="line"><span class="number">59</span>:                     listeners.putIfAbsent(listener, <span class="keyword">new</span> ChildListener() {</span><br /><span class="line"><span class="number">60</span>:                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childChanged</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> </span>{</span><br /><span class="line"><span class="number">61</span>:                             <span class="comment">// 变更时，调用 `#notify(...)` 方法，回调 NotifyListener</span></span><br /><span class="line"><span class="number">62</span>:                             ZookeeperRegistry.<span class="keyword">this</span>.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));</span><br /><span class="line"><span class="number">63</span>:                         }</span><br /><span class="line"><span class="number">64</span>:                     });</span><br /><span class="line"><span class="number">65</span>:                     zkListener = listeners.get(listener);</span><br /><span class="line"><span class="number">66</span>:                 }</span><br /><span class="line"><span class="number">67</span>:                 <span class="comment">// 创建 Type 节点。该节点为持久节点。</span></span><br /><span class="line"><span class="number">68</span>:                 zkClient.create(path, <span class="keyword">false</span>);</span><br /><span class="line"><span class="number">69</span>:                 <span class="comment">// 向 Zookeeper ，PATH 节点，发起订阅</span></span><br /><span class="line"><span class="number">70</span>:                 List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);</span><br /><span class="line"><span class="number">71</span>:                 <span class="comment">// 添加到 `urls` 中</span></span><br /><span class="line"><span class="number">72</span>:                 <span class="keyword">if</span> (children != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">73</span>:                     urls.addAll(toUrlsWithEmpty(url, path, children));</span><br /><span class="line"><span class="number">74</span>:                 }</span><br /><span class="line"><span class="number">75</span>:             }</span><br /><span class="line"><span class="number">76</span>:             <span class="comment">// 首次全量数据获取完成时，调用 `#notify(...)` 方法，回调 NotifyListener</span></span><br /><span class="line"><span class="number">77</span>:             notify(url, listener, urls);</span><br /><span class="line"><span class="number">78</span>:         }</span><br /><span class="line"><span class="number">79</span>:     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">80</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to subscribe "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br /><span class="line"><span class="number">81</span>:     }</span><br /><span class="line"><span class="number">82</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>整个方法分成两部分，分别：</li>
<li>============ 第二部分【第 44 至 78 行】 ============</li>
<li>处理<strong>指定</strong>&nbsp;Service 层的发起订阅，例如<strong>服务消费者</strong>的订阅。</li>
<li>第 47 行：子节点数据数组，即&nbsp;<strong>Service 层</strong>下的<strong>所有 URL</strong>&nbsp;。</li>
<li>第 49 行：循环分类数组。其中，调用&nbsp;<code>#toCategoriesPath(url)</code>&nbsp;方法，获得 分类数组。</li>
<li>第 51 至 55 行：获得订阅的&nbsp;<code>url</code>&nbsp;对应的监听器集合。</li>
<li>第 56 至 66 行：获得&nbsp;<code>listener</code>( NotifyListener ) 对应的 ChildListener 对象。<strong>在 URL 层发生变更时</strong>，会调用&nbsp;<code>NotifyListener#notify(url, listener, currentChilds)</code>&nbsp;方法，回调 NotifyListener 的逻辑。酱紫，如果 Service 下增加<strong>新的服务提供者实例</strong>( 新的 URL )，服务消费者可创建新的 Invoker 对象，用于调用该服务提供者。</li>
<li>第 68 行：创建&nbsp;<strong>Type</strong>&nbsp;节点。该节点为<strong>持久</strong>节点。</li>
<li>第 70 行：向 Zookeeper 的&nbsp;<strong>Path</strong>&nbsp;节点，发起订阅。</li>
<li>第 72 至 74 行：添加到&nbsp;<code>urls</code>&nbsp;中。</li>
<li>第 77 行：<strong>首次全量数据获取完成时</strong>，调用&nbsp;<code>NotifyListener#notify(url, listener, currentChilds)</code>&nbsp;方法，回调 NotifyListener 的逻辑。酱紫，服务消费者可创建所有的 Invoker 对象，用于调用服务提供者们。</li>
<li>🙂 回看【第 77 行】和【第 62 行】，全量 + 增量，仔细理解下。</li>
<li>============ 第一部分【第 5 至 43 行】 ============</li>
<li>处理<strong>所有</strong>&nbsp;Service 层的发起订阅，例如<strong>监控中心</strong>的订阅</li>
<li>第 8 至 12 行：获得订阅的&nbsp;<code>url</code>&nbsp;对应的监听器集合。</li>
<li>第 13 至 30 行：获得&nbsp;<code>listener</code>( NotifyListener ) 对应的 ChildListener 对象。<strong>在 Service 层发生变更时</strong>，若是新增 Service 接口全名时（即新增服务），调用&nbsp;<code>#subscribe(url, listener)</code>&nbsp;方法，发起该 Service 层的订阅（【第 45 至 78 行】的逻辑）。是否是新增的服务，通过&nbsp;<code>anyServices</code>&nbsp;属性来判断。</li>
<li>第 32 行：创建&nbsp;<strong>Service</strong>&nbsp;节点。该节点为<strong>持久</strong>节点。</li>
<li>第 34 行：向 Zookeeper 的&nbsp;<strong>Service</strong>&nbsp;节点，发起订阅。</li>
<li>第 36 至 43 行：<strong>首次全量数据获取完成时</strong>，循环 Service 接口全名数组，调用&nbsp;<code>#subscribe(url, listener)</code>&nbsp;方法，发起该 Service 层的订阅（【第 45 至 78 行】的逻辑）。</li>
</ul>
<blockquote>
<p>友情提示：如果觉得比较绕，或者笔者讲的不清晰，胖友可以进行调试理解。</p>
</blockquote>
<h3 id="3-4-1-toCategoriesPath">3.4.1 toCategoriesPath</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 获得分类路径数组</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * Root + Service + Type</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> url URL</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分类路径数组</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> String[] toCategoriesPath(URL url) {</span><br /><span class="line">    <span class="comment">// 获得分类数组</span></span><br /><span class="line">    String[] categories;</span><br /><span class="line">    <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getParameter(Constants.CATEGORY_KEY))) { <span class="comment">// * 时，</span></span><br /><span class="line">        categories = <span class="keyword">new</span> String[]{Constants.PROVIDERS_CATEGORY, Constants.CONSUMERS_CATEGORY,</span><br /><span class="line">                Constants.ROUTERS_CATEGORY, Constants.CONFIGURATORS_CATEGORY};</span><br /><span class="line">    } <span class="keyword">else</span> {</span><br /><span class="line">        categories = url.getParameter(Constants.CATEGORY_KEY, <span class="keyword">new</span> String[]{Constants.DEFAULT_CATEGORY});</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 获得分类路径数组</span></span><br /><span class="line">    String[] paths = <span class="keyword">new</span> String[categories.length];</span><br /><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; categories.length; i++) {</span><br /><span class="line">        paths[i] = toServicePath(url) + Constants.PATH_SEPARATOR + categories[i];</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> paths;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="3-4-2-toUrlsWithEmpty">3.4.2 toUrlsWithEmpty</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 获得 providers 中，和 consumer 匹配的 URL 数组</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 若不存在匹配，则创建 `empty://` 的 URL返回。通过这样的方式，可以处理类似服务提供者为空的情况。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumer 用于匹配 URL</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 被匹配的 URL 的字符串</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> providers 匹配的 URL 数组</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 匹配的 URL 数组</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> List&lt;URL&gt; <span class="title">toUrlsWithEmpty</span><span class="params">(URL consumer, String path, List&lt;String&gt; providers)</span> </span>{</span><br /><span class="line">    <span class="comment">// 获得 providers 中，和 consumer 匹配的 URL 数组</span></span><br /><span class="line">    List&lt;URL&gt; urls = toUrlsWithoutEmpty(consumer, providers);</span><br /><span class="line">    <span class="comment">// 若不存在匹配，则创建 `empty://` 的 URL返回</span></span><br /><span class="line">    <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) {</span><br /><span class="line">        <span class="keyword">int</span> i = path.lastIndexOf(<span class="string">'/'</span>);</span><br /><span class="line">        String category = i &lt; <span class="number">0</span> ? path : path.substring(i + <span class="number">1</span>);</span><br /><span class="line">        URL empty = consumer.setProtocol(Constants.EMPTY_PROTOCOL).addParameter(Constants.CATEGORY_KEY, category);</span><br /><span class="line">        urls.add(empty);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> urls;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>#toUrlsWithoutEmpty()</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 获得 providers 中，和 consumer 匹配的 URL 数组</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumer 用于匹配 URL</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> providers 被匹配的 URL 的字符串</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 匹配的 URL 数组</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> List&lt;URL&gt; <span class="title">toUrlsWithoutEmpty</span><span class="params">(URL consumer, List&lt;String&gt; providers)</span> </span>{</span><br /><span class="line">    List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br /><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span> &amp;&amp; !providers.isEmpty()) {</span><br /><span class="line">        <span class="keyword">for</span> (String provider : providers) {</span><br /><span class="line">            provider = URL.decode(provider);</span><br /><span class="line">            <span class="keyword">if</span> (provider.contains(<span class="string">"://"</span>)) { <span class="comment">// 是 url</span></span><br /><span class="line">                URL url = URL.valueOf(provider); <span class="comment">// 将字符串转化成 URL</span></span><br /><span class="line">                <span class="keyword">if</span> (UrlUtils.isMatch(consumer, url)) { <span class="comment">// 匹配</span></span><br /><span class="line">                    urls.add(url);</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> urls;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<h2 id="3-5-doUnsubscribe">3.5 doUnsubscribe</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUnsubscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>{</span><br /><span class="line">    ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br /><span class="line">    <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) {</span><br /><span class="line">        ChildListener zkListener = listeners.get(listener);</span><br /><span class="line">        <span class="keyword">if</span> (zkListener != <span class="keyword">null</span>) {</span><br /><span class="line">            <span class="comment">// 向 Zookeeper ，移除订阅</span></span><br /><span class="line">            zkClient.removeChildListener(toUrlPath(url), zkListener);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="3-6-lookup">3.6 lookup</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 查询符合条件的已注册数据，与订阅的推模式相对应，这里为拉模式，只返回一次结果。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> url 查询条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 已注册信息列表，可能为空，含义同{<span class="doctag">@link</span> com.alibaba.dubbo.registry.NotifyListener#notify(List&lt;URL&gt;)}的参数。</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.NotifyListener#notify(List)</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> List&lt;URL&gt; <span class="title">lookup</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"lookup url == null"</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        <span class="comment">// 循环分类数组，获得所有的 URL 数组</span></span><br /><span class="line">        List&lt;String&gt; providers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br /><span class="line">        <span class="keyword">for</span> (String path : toCategoriesPath(url)) {</span><br /><span class="line">            List&lt;String&gt; children = zkClient.getChildren(path);</span><br /><span class="line">            <span class="keyword">if</span> (children != <span class="keyword">null</span>) {</span><br /><span class="line">                providers.addAll(children);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 匹配</span></span><br /><span class="line">        <span class="keyword">return</span> toUrlsWithoutEmpty(url, providers);</span><br /><span class="line">    } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to lookup "</span> + url + <span class="string">" from zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="3-7-isAvailable">3.7 isAvailable</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> zkClient.isConnected();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="3-8-destroy">3.8 destroy</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">super</span>.destroy();</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        zkClient.close();</span><br /><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">        logger.warn(<span class="string">"Failed to close zookeeper client "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="4-调用">4. 调用</h1>
<h2 id="4-1-服务提供者">4.1 服务提供者</h2>
<p>回头看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/service-export-remote-dubbo/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 服务暴露（二）之远程暴露（Dubbo）》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/registry-zookeeper/">「3.2.2 export」</a>&nbsp;小节，我们可以看到：</p>
<ul>
<li>
<p>第 14 行：调用&nbsp;<code>#register(registryUrl, registedProviderUrl)</code>&nbsp;方法，向注册中心注册服务提供者（自己）。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registedProviderUrl)</span> </span>{</span><br /><span class="line">    Registry registry = registryFactory.getRegistry(registryUrl);</span><br /><span class="line">    registry.register(registedProviderUrl);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<h2 id="4-2-服务消费者">4.2 服务消费者</h2>
<p>回头看&nbsp;<a href="http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 服务引用（二）之远程引用（Dubbo）》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/registry-zookeeper/">「3.2.2 doRefer</a>&nbsp;小节，我们可以看到：</p>
<ul>
<li>第 20 至 25 行：调用&nbsp;<code>RegistryService#register(url)</code>&nbsp;方法，向注册中心注册<strong>自己</strong>（服务消费者）。</li>
<li>第 35 行：调用&nbsp;<code>Directory#subscribe(url)</code>&nbsp;方法，向注册中心订阅服务提供者 + 路由规则 + 配置规则。
<ul>
<li>在该方法中，会循环获得到的服务体用这列表，调用&nbsp;<code>Protocol#refer(type, url)</code>&nbsp;方法，创建每个调用服务的 Invoker 对象。</li>
</ul>
</li>
</ul>
</div>