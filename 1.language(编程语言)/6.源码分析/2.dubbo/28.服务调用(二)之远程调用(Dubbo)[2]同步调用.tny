<header class="article-header">
<h1 class="article-title">&nbsp;服务调用（二）之远程调用（Dubbo）【2】同步调用</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>本文分享&nbsp;<code>dubbo://</code>&nbsp;协议的远程调用的<strong>第二部分：同步调用</strong>。</p>
<p>在&nbsp;<code>dubbo://</code>&nbsp;协议的调用，一共分成三种：</p>
<ol>
<li>sync 同步调用</li>
<li>async 异步调用</li>
<li>oneway 单向调用</li>
</ol>
<p>前两种比较好理解，都是基于 Request Response 模型，差异点在异步调用，服务消费者<strong>不阻塞</strong>等待结果，而是通过<strong>回调</strong>的方式，处理服务提供者返回的结果。<br />最后一种，基于 Message 模型，发起调用，而不关注等待和关注执行结果。<br />因此，从性能上：oneway &gt; async &gt; sync 。</p>
<blockquote>
<p>友情提示：本文会分享 sync 和 oneway 两种方式。</p>
</blockquote>
<h1 id="2-顺序图">2. 顺序图</h1>
<ul>
<li>
<p>消费者调用服务的顺序图：<img src="http://static2.iocoder.cn/images/Dubbo/2018_10_04/02_01.jpeg" alt="顺序图" /></p>
<ul>
<li>此图是在&nbsp;<code>injvm://</code>&nbsp;协议的顺序图的基础上修改：
<ul>
<li>将 InjvmInvoker 替换成 DubboInvoker 。</li>
<li>在&nbsp;<code>#doInvoker()</code>&nbsp;方法中，DubboInvoker 会调用 Client ，向服务提供者发起请求。</li>
</ul>
</li>
<li>可能会有胖友问，<strong>集群容错</strong>呢？在 InvokerInvocationHandler 之后，ProtocolFilterWrapper$Invoker 之前。如下图所示：<img src="http://static2.iocoder.cn/images/Dubbo/2018_10_04/02_02.png" alt="集群容错" />
<ul>
<li>🙂 我们后面专门写几篇文章，专门分享集群容错，所以本文略过。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>提供者提供服务的顺序图：<img src="http://static2.iocoder.cn/images/Dubbo/2018_10_04/02_03.jpeg" alt="顺序图" /></p>
<ul>
<li>此图是在&nbsp;<code>injvm://</code>&nbsp;协议的顺序图的基础上修改：
<ul>
<li>InjvmInvoker 替换成 ExchangeServer 。例如在 Netty4 中，IO Worker 解析请求，转发给 ExchangeHandler 处理。</li>
<li>InjvmProtocol 替换成 DubboProtocol 。在该类中，实现了自定义的 ExchangeHandler 处理请求。<strong>注意</strong>，在&nbsp;<strong>Dubbo ThreadPool</strong>&nbsp;中处理请求，参见&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/thread-model.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 线程模型》</a>&nbsp;文档。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-消费者调用服务">3. 消费者调用服务</h1>
<p>调用&nbsp;<code>DubboInvoker#invoke(Invocation)</code>&nbsp;方法，调用服务。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 使用的 {<span class="doctag">@link</span> #clients} 的位置</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicPositiveInteger index = <span class="keyword">new</span> AtomicPositiveInteger();</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> </span>{</span><br /><span class="line">  <span class="number">3</span>:     RpcInvocation inv = (RpcInvocation) invocation;</span><br /><span class="line">  <span class="number">4</span>:     <span class="comment">// 获得方法名</span></span><br /><span class="line">  <span class="number">5</span>:     <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br /><span class="line">  <span class="number">6</span>:     <span class="comment">// 获得 `path`( 服务名 )，`version`</span></span><br /><span class="line">  <span class="number">7</span>:     inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br /><span class="line">  <span class="number">8</span>:     inv.setAttachment(Constants.VERSION_KEY, version);</span><br /><span class="line">  <span class="number">9</span>: </span><br /><span class="line"> <span class="number">10</span>:     <span class="comment">// 获得 ExchangeClient 对象</span></span><br /><span class="line"> <span class="number">11</span>:     ExchangeClient currentClient;</span><br /><span class="line"> <span class="number">12</span>:     <span class="keyword">if</span> (clients.length == <span class="number">1</span>) {</span><br /><span class="line"> <span class="number">13</span>:         currentClient = clients[<span class="number">0</span>];</span><br /><span class="line"> <span class="number">14</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">15</span>:         currentClient = clients[index.getAndIncrement() % clients.length];</span><br /><span class="line"> <span class="number">16</span>:     }</span><br /><span class="line"> <span class="number">17</span>:     <span class="comment">// 远程调用</span></span><br /><span class="line"> <span class="number">18</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">19</span>:         <span class="comment">// 获得是否异步调用</span></span><br /><span class="line"> <span class="number">20</span>:         <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br /><span class="line"> <span class="number">21</span>:         <span class="comment">// 获得是否单向调用</span></span><br /><span class="line"> <span class="number">22</span>:         <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br /><span class="line"> <span class="number">23</span>:         <span class="comment">// 获得超时时间</span></span><br /><span class="line"> <span class="number">24</span>:         <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br /><span class="line"> <span class="number">25</span>:         <span class="comment">// 单向调用</span></span><br /><span class="line"> <span class="number">26</span>:         <span class="keyword">if</span> (isOneway) {</span><br /><span class="line"> <span class="number">27</span>:             <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br /><span class="line"> <span class="number">28</span>:             currentClient.send(inv, isSent);</span><br /><span class="line"> <span class="number">29</span>:             RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br /><span class="line"> <span class="number">30</span>:             <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br /><span class="line"> <span class="number">31</span>:         <span class="comment">// 异步调用</span></span><br /><span class="line"> <span class="number">32</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) {</span><br /><span class="line"> <span class="number">33</span>:             ResponseFuture future = currentClient.request(inv, timeout);</span><br /><span class="line"> <span class="number">34</span>:             RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br /><span class="line"> <span class="number">35</span>:             <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br /><span class="line"> <span class="number">36</span>:         <span class="comment">// 同步调用</span></span><br /><span class="line"> <span class="number">37</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">38</span>:             RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br /><span class="line"> <span class="number">39</span>:             <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br /><span class="line"> <span class="number">40</span>:         }</span><br /><span class="line"> <span class="number">41</span>:     } <span class="keyword">catch</span> (TimeoutException e) {</span><br /><span class="line"> <span class="number">42</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br /><span class="line"> <span class="number">43</span>:     } <span class="keyword">catch</span> (RemotingException e) {</span><br /><span class="line"> <span class="number">44</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br /><span class="line"> <span class="number">45</span>:     }</span><br /><span class="line"> <span class="number">46</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>第 5 行：调用&nbsp;<code>RpcUtils#getMethodName()</code>&nbsp;方法，获得方法名。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMethodName</span><span class="params">(Invocation invocation)</span> </span>{</span><br /><span class="line">    <span class="comment">// 泛化调用，第一个参数为方法名</span></span><br /><span class="line">    <span class="keyword">if</span> (Constants.$INVOKE.equals(invocation.getMethodName())</span><br /><span class="line">            &amp;&amp; invocation.getArguments() != <span class="keyword">null</span></span><br /><span class="line">            &amp;&amp; invocation.getArguments().length &gt; <span class="number">0</span></span><br /><span class="line">            &amp;&amp; invocation.getArguments()[<span class="number">0</span>] <span class="keyword">instanceof</span> String) {</span><br /><span class="line">        <span class="keyword">return</span> (String) invocation.getArguments()[<span class="number">0</span>];</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 普通调用，直接获得</span></span><br /><span class="line">    <span class="keyword">return</span> invocation.getMethodName();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>第 6 至 8 行：获得&nbsp;<code>path</code>( 服务名 )、<code>version</code>&nbsp;。</p>
</li>
<li>第 10 至 16 行：<strong>顺序</strong>，获得 ExchangeClient 对象。</li>
<li>
<p>第 20 行：调用&nbsp;<code>RpcUtils#isAsync(url, invocation)</code>&nbsp;方法，判断是否异步调用。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAsync</span><span class="params">(URL url, Invocation inv)</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> Boolean.TRUE.toString().equals(inv.getAttachment(Constants.ASYNC_KEY)) <span class="comment">// RpcContext#asyncCall(Callable) 方法，可以设置</span></span><br /><span class="line">            || url.getMethodParameter(getMethodName(inv), Constants.ASYNC_KEY, <span class="keyword">false</span>);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>获得是否异步。服务引用或方法，任一配置&nbsp;<code>async = true</code>&nbsp;，即为异步。</li>
</ul>
</li>
<li>
<p>第 22 行：调用&nbsp;<code>RpcUtils#isOneway(url, invocation)</code>&nbsp;方法，判断是否异步调用。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOneway</span><span class="params">(URL url, Invocation inv)</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> Boolean.FALSE.toString().equals(inv.getAttachment(Constants.RETURN_KEY)) <span class="comment">// RpcContext#asyncCall(Runnable) 方法，可以设置</span></span><br /><span class="line">            || !url.getMethodParameter(getMethodName(inv), Constants.RETURN_KEY, <span class="keyword">true</span>);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>获得是否单向。方法配置&nbsp;<code>return = true</code>&nbsp;，即为单向。</li>
</ul>
</li>
<li>
<p>第 24 行：调用&nbsp;<code>URL#getMethodParameter(method, key, defaultValue)</code>&nbsp;方法，获得远程调用超时时间，单位：毫秒。</p>
</li>
<li>第 25 至 30 行：oneway 单向调用。
<ul>
<li>第 28 行：<strong>注意</strong>，调用的是&nbsp;<code>ExchangeClient#send(invocation, sent)</code>&nbsp;方法，发送<strong>消息</strong>，而不是<strong>请求</strong>。</li>
<li>第 29 行：设置&nbsp;<code>RpcContext.future = null</code>&nbsp;，无需 FutureFilter ，异步回调。</li>
<li>第 30 行：创建 RpcResult 对象，<strong>空返回</strong>。</li>
</ul>
</li>
<li>第 31 至 35 行：async 异步调用。
<ul>
<li>第 33 行：调用&nbsp;<code>ExchangeClient#request(invocation, timeout)</code>&nbsp;方法，发送<strong>请求</strong>。</li>
<li>第 34 行：调用&nbsp;<code>RpcContext#setFuture(future)</code>&nbsp;方法，在 FutureFitler 中，异步回调。</li>
<li>第 35 行：创建 RpcResult 对象，<strong>空返回</strong>。</li>
</ul>
</li>
<li>第 36 至 40 行：sync 同步调用。
<ul>
<li>第 38 行：设置&nbsp;<code>RpcContext.future = null</code>&nbsp;，无需 FutureFilter ，异步回调。</li>
<li>第 39 行：调用&nbsp;<code>ExchangeClient#request(invocation, timeout)</code>&nbsp;方法，发送<strong>请求</strong>。</li>
<li>第 39 行：调用&nbsp;<code>ResponseFuture#get()</code>&nbsp;方法，<strong>阻塞</strong>等待，返回结果。</li>
</ul>
</li>
</ul>
<h1 id="4-提供者提供服务">4. 提供者提供服务</h1>
<p>在 DubboProtocol 类中，实现了自己的 ExchangeHandler 对象，处理请求、消息、连接、断开连接等事件。对于服务消费者的远程调用，通过&nbsp;<code>#reply(ExchangeChannel channel, Object message)</code>&nbsp;和&nbsp;<code>#reply(Channel channel, Object message)</code>&nbsp;方法来处理。如下图所示：<img src="http://static2.iocoder.cn/images/Dubbo/2018_10_04/02_04.png" alt="ExchangeHandler" /></p>
<p>下面，我们来看看每个方法的实现代码。</p>
<h2 id="4-1-reply">4.1 reply</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) {</span><br /><span class="line"> <span class="number">4</span>:         Invocation inv = (Invocation) message;</span><br /><span class="line"> <span class="number">5</span>:         <span class="comment">// 获得请求对应的 Invoker 对象</span></span><br /><span class="line"> <span class="number">6</span>:         Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br /><span class="line"> <span class="number">7</span>:         <span class="comment">// 如果是callback 需要处理高版本调用低版本的问题</span></span><br /><span class="line"> <span class="number">8</span>:         <span class="comment">// need to consider backward-compatibility if it's a callback</span></span><br /><span class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {</span><br /><span class="line"><span class="number">10</span>:             String methodsStr = invoker.getUrl().getParameters().get(<span class="string">"methods"</span>);</span><br /><span class="line"><span class="number">11</span>:             <span class="keyword">boolean</span> hasMethod = <span class="keyword">false</span>;</span><br /><span class="line"><span class="number">12</span>:             <span class="keyword">if</span> (methodsStr == <span class="keyword">null</span> || !methodsStr.contains(<span class="string">","</span>)) {</span><br /><span class="line"><span class="number">13</span>:                 hasMethod = inv.getMethodName().equals(methodsStr);</span><br /><span class="line"><span class="number">14</span>:             } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">15</span>:                 String[] methods = methodsStr.split(<span class="string">","</span>);</span><br /><span class="line"><span class="number">16</span>:                 <span class="keyword">for</span> (String method : methods) {</span><br /><span class="line"><span class="number">17</span>:                     <span class="keyword">if</span> (inv.getMethodName().equals(method)) {</span><br /><span class="line"><span class="number">18</span>:                         hasMethod = <span class="keyword">true</span>;</span><br /><span class="line"><span class="number">19</span>:                         <span class="keyword">break</span>;</span><br /><span class="line"><span class="number">20</span>:                     }</span><br /><span class="line"><span class="number">21</span>:                 }</span><br /><span class="line"><span class="number">22</span>:             }</span><br /><span class="line"><span class="number">23</span>:             <span class="keyword">if</span> (!hasMethod) {</span><br /><span class="line"><span class="number">24</span>:                 logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"The methodName "</span> + inv.getMethodName() + <span class="string">" not found in callback service interface ,invoke will be ignored. please update the api interface. url is:"</span> + invoker.getUrl()) + <span class="string">" ,invocation is :"</span> + inv);</span><br /><span class="line"><span class="number">25</span>:                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line"><span class="number">26</span>:             }</span><br /><span class="line"><span class="number">27</span>:         }</span><br /><span class="line"><span class="number">28</span>:         <span class="comment">// 设置调用方的地址</span></span><br /><span class="line"><span class="number">29</span>:         RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br /><span class="line"><span class="number">30</span>:         <span class="comment">// 执行调用</span></span><br /><span class="line"><span class="number">31</span>:         <span class="keyword">return</span> invoker.invoke(inv);</span><br /><span class="line"><span class="number">32</span>:     }</span><br /><span class="line"><span class="number">33</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, message.getClass().getName() + <span class="string">": "</span> + message</span><br /><span class="line"><span class="number">34</span>:             + <span class="string">", channel: consumer: "</span> + channel.getRemoteAddress() + <span class="string">" --&gt; provider: "</span> + channel.getLocalAddress());</span><br /><span class="line"><span class="number">35</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>用于处理服务消费者的同步调用和异步调用的请求。</li>
<li>
<p>第 6 行：调用&nbsp;<code>#getInvoker(channel, invocation)</code>&nbsp;方法，获得请求对应的 Invoker 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Exporter 集合</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * key: 服务键 {<span class="doctag">@link</span> #serviceKey(URL)} 或 {<span class="doctag">@link</span> URL#getServiceKey()} 。</span></span><br /><span class="line"><span class="comment"> *      不同协议会不同</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Exporter&lt;?&gt;&gt;(); <span class="comment">// FROM 父类 AbstractProtocol.java</span></span><br /><br /><span class="line">  <span class="number">1</span>: Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="keyword">throws</span> RemotingException {</span><br /><span class="line">  <span class="number">2</span>:     <span class="keyword">boolean</span> isCallBackServiceInvoke;</span><br /><span class="line">  <span class="number">3</span>:     <span class="keyword">boolean</span> isStubServiceInvoke;</span><br /><span class="line">  <span class="number">4</span>:     <span class="keyword">int</span> port = channel.getLocalAddress().getPort();</span><br /><span class="line">  <span class="number">5</span>:     String path = inv.getAttachments().get(Constants.PATH_KEY);</span><br /><span class="line">  <span class="number">6</span>:     <span class="comment">// TODO 【8033 参数回调】</span></span><br /><span class="line">  <span class="number">7</span>:     <span class="comment">// if it's callback service on client side</span></span><br /><span class="line">  <span class="number">8</span>:     isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getAttachments().get(Constants.STUB_EVENT_KEY));</span><br /><span class="line">  <span class="number">9</span>:     <span class="keyword">if</span> (isStubServiceInvoke) {</span><br /><span class="line"> <span class="number">10</span>:         port = channel.getRemoteAddress().getPort();</span><br /><span class="line"> <span class="number">11</span>:     }</span><br /><span class="line"> <span class="number">12</span>:     <span class="comment">// 如果是参数回调，获得真正的服务名 `path` 。</span></span><br /><span class="line"> <span class="number">13</span>:     <span class="comment">// callback</span></span><br /><span class="line"> <span class="number">14</span>:     isCallBackServiceInvoke = isClientSide(channel) &amp;&amp; !isStubServiceInvoke;</span><br /><span class="line"> <span class="number">15</span>:     <span class="keyword">if</span> (isCallBackServiceInvoke) {</span><br /><span class="line"> <span class="number">16</span>:         path = inv.getAttachments().get(Constants.PATH_KEY) + <span class="string">"."</span> + inv.getAttachments().get(Constants.CALLBACK_SERVICE_KEY);</span><br /><span class="line"> <span class="number">17</span>:         inv.getAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString());</span><br /><span class="line"> <span class="number">18</span>:     }</span><br /><span class="line"> <span class="number">19</span>:     <span class="comment">// 获得服务建</span></span><br /><span class="line"> <span class="number">20</span>:     String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));</span><br /><span class="line"> <span class="number">21</span>:     <span class="comment">// 获得 Exporter 对象</span></span><br /><span class="line"> <span class="number">22</span>:     DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</span><br /><span class="line"> <span class="number">23</span>:     <span class="comment">// 获得 Invoker 对象</span></span><br /><span class="line"> <span class="number">24</span>:     <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">25</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Not found exported service: "</span> + serviceKey + <span class="string">" in "</span> + exporterMap.keySet() + <span class="string">", may be version or group mismatch "</span> + <span class="string">", channel: consumer: "</span> + channel.getRemoteAddress() + <span class="string">" --&gt; provider: "</span> + channel.getLocalAddress() + <span class="string">", message:"</span> + inv);</span><br /><span class="line"> <span class="number">26</span>:     }</span><br /><span class="line"> <span class="number">27</span>:     <span class="keyword">return</span> exporter.getInvoker();</span><br /><span class="line"> <span class="number">28</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 6 至 11 行：TODO 【8033 参数回调】</li>
<li>第 12 至 18 行：如果是参数回调，获得真正的服务名&nbsp;<code>path</code>&nbsp;。在<strong>参数回调</strong>一文中，我们详细解析。</li>
<li>
<p>第 20 行：调用&nbsp;<code>#serviceKey(port, path, version)</code>&nbsp;方法，获得服务键。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> String <span class="title">serviceKey</span><span class="params">(<span class="keyword">int</span> port, String serviceName, String serviceVersion, String serviceGroup)</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>第 22 行：从&nbsp;<code>exporterMap</code>&nbsp;集合中，获得 Exporter 对象。</p>
</li>
<li>第 23 至 27 行：获得 Invoker 对象。</li>
</ul>
</li>
<li>
<p>第 8 至 27 行：如果是<strong>参数回调</strong>，校验服务消费者实际存在对应的回调方法，通过方法名判断。</p>
</li>
<li>第 29 行：设置调用方的地址。</li>
<li>第 31 行：调用&nbsp;<code>Invoker#invoke(invocation)</code>&nbsp;方法，执行调用，并返回结果。后续的逻辑，和&nbsp;<code>injvm://</code>&nbsp;协议是一致的。</li>
</ul>
<h2 id="4-2-received">4.2 received</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) {</span><br /><span class="line">        <span class="keyword">this</span>.reply((ExchangeChannel) channel, message);</span><br /><span class="line">    } <span class="keyword">else</span> {</span><br /><span class="line">        <span class="keyword">super</span>.received(channel, message);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>用于处理服务消费者的<strong>单次调用</strong>的消息，通过判断消息类型是不是 Invocation 。</li>
</ul>
<h2 id="4-3-connected-amp-amp-disconnected">4.3 connected &amp;&amp; disconnected</h2>
<blockquote>
<p>本小节和 Dubbo RPC 无关系，只是为了完整分享 DubboProtocol ExchangeHandler 的完整代码实现。</p>
</blockquote>
<p>在服务提供者上，有&nbsp;<code>"onconnect"</code>&nbsp;和&nbsp;<code>"ondisconnect"</code>&nbsp;配置项，在服务提供者连接或断开连接时，调用 Service 对应的方法。目前这个配置项，在 Dubbo 文档里，暂未提及。当然，这个在实际场景下，基本没用过。</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>.invoke(channel, Constants.ON_CONNECT_KEY);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line">        logger.info(<span class="string">"disconected from "</span> + channel.getRemoteAddress() + <span class="string">",url:"</span> + channel.getUrl());</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">this</span>.invoke(channel, Constants.ON_DISCONNECT_KEY);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>调用&nbsp;<code>#invoke(channel, methodKey)</code>&nbsp;方法，执行对应的方法。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 调用方法</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel 通道</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodKey 方法名</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Channel channel, String methodKey)</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 Invocation 对象</span></span><br /><span class="line">    Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);</span><br /><span class="line">    <span class="comment">// 调用 received 方法，执行对应的方法</span></span><br /><span class="line">    <span class="keyword">if</span> (invocation != <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="keyword">this</span>.received(channel, invocation);</span><br /><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">            logger.warn(<span class="string">"Failed to invoke event method "</span> + invocation.getMethodName() + <span class="string">"(), cause: "</span> + t.getMessage(), t);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> Invocation <span class="title">createInvocation</span><span class="params">(Channel channel, URL url, String methodKey)</span> </span>{</span><br /><span class="line">    String method = url.getParameter(methodKey);</span><br /><span class="line">    <span class="keyword">if</span> (method == <span class="keyword">null</span> || method.length() == <span class="number">0</span>) {</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">    }</span><br /><span class="line">    RpcInvocation invocation = <span class="keyword">new</span> RpcInvocation(method, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br /><span class="line">    invocation.setAttachment(Constants.PATH_KEY, url.getPath());</span><br /><span class="line">    invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));</span><br /><span class="line">    invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));</span><br /><span class="line">    invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));</span><br /><span class="line">    <span class="keyword">if</span> (url.getParameter(Constants.STUB_EVENT_KEY, <span class="keyword">false</span>)) {</span><br /><span class="line">        invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> invocation;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
</div>