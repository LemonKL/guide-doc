<header class="article-header">
<h1 class="article-title">调用特性（三）之泛化实现</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>本文分享<strong>泛化实现</strong>。我们来看下&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/generic-service.html" target="_blank" rel="external nofollow noopener noreferrer">《用户指南 &mdash;&mdash; 泛化实现》</a>&nbsp;的定义：</p>
<blockquote>
<p>泛接口实现方式主要用于服务器端没有API接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求。</p>
</blockquote>
<p>请注意，消费<strong>提供者</strong>没有&nbsp;<strong>API 接口</strong>&nbsp;及&nbsp;<strong>模型类元</strong>。那就是说，Dubbo 在泛化实现中，需要做两件事情：</p>
<blockquote>
<p><strong>泛化实现</strong>适用于服务提供者，和<strong>泛化引用</strong>适用于服务消费者，恰恰&ldquo;相反&rdquo;。</p>
</blockquote>
<ul>
<li>没有&nbsp;<strong>API 接口</strong>，所以提供一个泛化服务接口，目前是&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/f83e70b53389a064e49babe32e61a5648002a44a/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/service/GenericService.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.service.GenericService</code></a>&nbsp;。
<ul>
<li><strong>一个</strong>泛化实现，只实现<strong>一个</strong>服务。</li>
<li>通过实现&nbsp;<code>$invoke(method, parameterTypes, args)</code>&nbsp;方法，<strong>处理所有该服务的请求</strong>。</li>
<li>具体的使用方式，我们在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/rpc-feature-generic-service/">「2. 示例」</a>&nbsp;中看。</li>
</ul>
</li>
<li>没有&nbsp;<strong>模型类元</strong>，所以方法参数和方法返回若是 POJO ( 例如 User 和 Order 等 ) ，需要<strong>转换处理</strong>：
<ul>
<li>服务消费者，将 POJO 转成 Map ，然后再调用服务提供者。（<strong>透明</strong>）</li>
<li>服务提供者，返回 Map 。</li>
<li>服务消费者，若<strong>收到</strong>返回值是 Map ，则转换成 POJO 再返回。</li>
<li>🙂 此处的 Map 只是举例子，实际在下文中，我们会看到还有<strong>一种</strong>转换方式。 （<strong>透明</strong>）</li>
</ul>
</li>
</ul>
<p>整体流程如下：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_11_07/01.png" alt="流程" /></p>
<h1 id="2-示例">2. 示例</h1>
<p><strong>服务提供者</strong></p>
<p>在&nbsp;<a href="https://github.com/YunaiV/dubbo/tree/3766a47c5e97ee86c29d765dc88ee11ab5225604/dubbo-demo/dubbo-generic-reference-demo-provider" target="_blank" rel="external nofollow noopener noreferrer"><code>dubbo-generic-service-demo-provider</code></a>&nbsp;，我们提供了例子。我们挑<strong>重点</strong>的地方说。</p>
<p>① 在 Java 代码中实现 GenericService 接口：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">GenericService</span> </span>{</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> Object $invoke(String method, String[] parameterTypes, Object[] args) <span class="keyword">throws</span> GenericException {</span><br /><span class="line">        <span class="keyword">if</span> (<span class="string">"sayHello"</span>.equals(method)) {</span><br /><span class="line">            <span class="keyword">return</span> <span class="string">"Welcome "</span> + args[<span class="number">0</span>];</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">return</span> <span class="string">"unknown method"</span>;</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p>② 在 Spring 配置申明服务的实现：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">&lt;bean id=<span class="string">"demoService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoServiceImpl"</span> /&gt;</span><br /><br /><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> ref=<span class="string">"demoService"</span> generic=<span class="string">"true"</span> /&gt;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>interface</code>&nbsp;配置项，泛化实现的服务接口。通过该配置，服务消费者，可以从注册中心，获取到所有<strong>该服务</strong>的提供方的地址，包括泛化实现的该服务的地址。</li>
<li><code>generic</code>&nbsp;配置项，默认为&nbsp;<code>false</code>&nbsp;，不使用配置项。目前有<strong>两种配置项的值</strong>，开启泛化实现的功能：
<ul>
<li><code>generic=true</code>&nbsp;，使用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/f83e70b53389a064e49babe32e61a5648002a44a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/PojoUtils.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.common.utils.PojoUtils</code></a>&nbsp;，实现&nbsp;<code>POJO &lt;=&gt; Map</code>&nbsp;的互转。</li>
<li><code>generic=bean</code>&nbsp;，使用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-common/src/main/java/com/alibaba/dubbo/common/beanutil/JavaBeanSerializeUtil.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.common.beanutil.JavaBeanSerializeUtil</code></a>&nbsp;，实现&nbsp;<code>POJO &lt;=&gt; JavaBeanDescriptor</code>&nbsp;的互转。</li>
<li>不存在&nbsp;<code>generic=nativejava</code>&nbsp;配置项。</li>
</ul>
</li>
</ul>
<p><strong>服务消费者</strong></p>
<p>在&nbsp;<a href="https://github.com/YunaiV/dubbo/tree/3766a47c5e97ee86c29d765dc88ee11ab5225604/dubbo-demo/dubbo-generic-service-demo-consumer" target="_blank" rel="external nofollow noopener noreferrer"><code>dubbo-generic-service-demo-consumer</code></a>&nbsp;，我们提供了例子。我们挑<strong>重点</strong>的地方说。</p>
<p>调用代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>); <span class="comment">// get remote service proxy</span></span><br /><span class="line">Object result = demoService.say01(<span class="string">"NIHAO"</span>);</span><br /><span class="line">System.out.println(<span class="string">"result: "</span> + result);</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>和我们普通的服务消费者，调用服务提供者，<strong>一模一样</strong>，注意，是<strong>一模一样</strong>。</li>
</ul>
<h1 id="3-服务消费者-GenericImplFilter">3. 服务消费者 GenericImplFilter</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/3766a47c5e97ee86c29d765dc88ee11ab5225604/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/GenericImplFilter.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.rpc.filter.GenericImplFilter</code></a>&nbsp;，实现 Filter 接口，服务消费者的泛化调用过滤器。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">  <span class="number">1</span>: <span class="meta">@Activate</span>(group = Constants.CONSUMER, value = Constants.GENERIC_KEY, order = <span class="number">20000</span>)</span><br /><span class="line">  <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericImplFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>{</span><br /><span class="line">  <span class="number">3</span>: </span><br /><span class="line">  <span class="number">4</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GenericImplFilter.class);</span><br /><span class="line">  <span class="number">5</span>: </span><br /><span class="line">  <span class="number">6</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] GENERIC_PARAMETER_TYPES = <span class="keyword">new</span> Class&lt;?&gt;[]{String.class, String[].class, Object[].class};</span><br /><span class="line">  <span class="number">7</span>: </span><br /><span class="line">  <span class="number">8</span>:     <span class="meta">@Override</span></span><br /><span class="line">  <span class="number">9</span>:     <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">10</span>:         <span class="comment">// 获得 `generic` 配置项</span></span><br /><span class="line"> <span class="number">11</span>:         String generic = invoker.getUrl().getParameter(Constants.GENERIC_KEY);</span><br /><span class="line"> <span class="number">12</span>: </span><br /><span class="line"> <span class="number">13</span>:         <span class="comment">// 泛化实现的调用</span></span><br /><span class="line"> <span class="number">14</span>:         <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)</span><br /><span class="line"> <span class="number">15</span>:                 &amp;&amp; !Constants.$INVOKE.equals(invocation.getMethodName())</span><br /><span class="line"> <span class="number">16</span>:                 &amp;&amp; invocation <span class="keyword">instanceof</span> RpcInvocation) {</span><br /><span class="line"> <span class="number">17</span>:             RpcInvocation invocation2 = (RpcInvocation) invocation;</span><br /><span class="line"> <span class="number">18</span>:             String methodName = invocation2.getMethodName();</span><br /><span class="line"> <span class="number">19</span>:             Class&lt;?&gt;[] parameterTypes = invocation2.getParameterTypes();</span><br /><span class="line"> <span class="number">20</span>:             Object[] arguments = invocation2.getArguments();</span><br /><span class="line"> <span class="number">21</span>: </span><br /><span class="line"> <span class="number">22</span>:             <span class="comment">// 获得参数类型数组</span></span><br /><span class="line"> <span class="number">23</span>:             String[] types = <span class="keyword">new</span> String[parameterTypes.length];</span><br /><span class="line"> <span class="number">24</span>:             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) {</span><br /><span class="line"> <span class="number">25</span>:                 types[i] = ReflectUtils.getName(parameterTypes[i]);</span><br /><span class="line"> <span class="number">26</span>:             }</span><br /><span class="line"> <span class="number">27</span>: </span><br /><span class="line"> <span class="number">28</span>:             Object[] args;</span><br /><span class="line"> <span class="number">29</span>:             <span class="comment">// 【第一步】`bean` ，序列化参数，方法参数 =&gt; JavaBeanDescriptor</span></span><br /><span class="line"> <span class="number">30</span>:             <span class="keyword">if</span> (ProtocolUtils.isBeanGenericSerialization(generic)) {</span><br /><span class="line"> <span class="number">31</span>:                 args = <span class="keyword">new</span> Object[arguments.length];</span><br /><span class="line"> <span class="number">32</span>:                 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) {</span><br /><span class="line"> <span class="number">33</span>:                     args[i] = JavaBeanSerializeUtil.serialize(arguments[i], JavaBeanAccessor.METHOD);</span><br /><span class="line"> <span class="number">34</span>:                 }</span><br /><span class="line"> <span class="number">35</span>:             <span class="comment">// 【第一步】`true` ，序列化参数，仅有 Map =&gt; POJO</span></span><br /><span class="line"> <span class="number">36</span>:             } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">37</span>:                 args = PojoUtils.generalize(arguments);</span><br /><span class="line"> <span class="number">38</span>:             }</span><br /><span class="line"> <span class="number">39</span>: </span><br /><span class="line"> <span class="number">40</span>:             <span class="comment">// 修改调用方法的名字为 `$invoke`</span></span><br /><span class="line"> <span class="number">41</span>:             invocation2.setMethodName(Constants.$INVOKE);</span><br /><span class="line"> <span class="number">42</span>:             <span class="comment">// 设置调用方法的参数类型为 `GENERIC_PARAMETER_TYPES`</span></span><br /><span class="line"> <span class="number">43</span>:             invocation2.setParameterTypes(GENERIC_PARAMETER_TYPES);</span><br /><span class="line"> <span class="number">44</span>:             <span class="comment">// 设置调用方法的参数数组，分别为方法名、参数类型数组、参数数组</span></span><br /><span class="line"> <span class="number">45</span>:             invocation2.setArguments(<span class="keyword">new</span> Object[]{methodName, types, args});</span><br /><span class="line"> <span class="number">46</span>: </span><br /><span class="line"> <span class="number">47</span>:             <span class="comment">// 【第二步】RPC 调用</span></span><br /><span class="line"> <span class="number">48</span>:             Result result = invoker.invoke(invocation2);</span><br /><span class="line"> <span class="number">49</span>: </span><br /><span class="line"> <span class="number">50</span>:             <span class="comment">// 【第三步】反序列化正常结果</span></span><br /><span class="line"> <span class="number">51</span>:             <span class="keyword">if</span> (!result.hasException()) {</span><br /><span class="line"> <span class="number">52</span>:                 Object value = result.getValue();</span><br /><span class="line"> <span class="number">53</span>:                 <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">54</span>:                     <span class="comment">// 【第三步】`bean` ，反序列化结果，JavaBeanDescriptor =&gt; 结果</span></span><br /><span class="line"> <span class="number">55</span>:                     <span class="keyword">if</span> (ProtocolUtils.isBeanGenericSerialization(generic)) {</span><br /><span class="line"> <span class="number">56</span>:                         <span class="keyword">if</span> (value == <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">57</span>:                             <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(<span class="keyword">null</span>);</span><br /><span class="line"> <span class="number">58</span>:                         } <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> JavaBeanDescriptor) {</span><br /><span class="line"> <span class="number">59</span>:                             <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) value));</span><br /><span class="line"> <span class="number">60</span>:                         } <span class="keyword">else</span> { <span class="comment">// 必须是 JavaBeanDescriptor 返回</span></span><br /><span class="line"> <span class="number">61</span>:                             <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(</span><br /><span class="line"> <span class="number">62</span>:                                     <span class="keyword">new</span> StringBuilder(<span class="number">64</span>)</span><br /><span class="line"> <span class="number">63</span>:                                             .append(<span class="string">"The type of result value is "</span>)</span><br /><span class="line"> <span class="number">64</span>:                                             .append(value.getClass().getName())</span><br /><span class="line"> <span class="number">65</span>:                                             .append(<span class="string">" other than "</span>)</span><br /><span class="line"> <span class="number">66</span>:                                             .append(JavaBeanDescriptor.class.getName())</span><br /><span class="line"> <span class="number">67</span>:                                             .append(<span class="string">", and the result is "</span>)</span><br /><span class="line"> <span class="number">68</span>:                                             .append(value).toString());</span><br /><span class="line"> <span class="number">69</span>:                         }</span><br /><span class="line"> <span class="number">70</span>:                     } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">71</span>:                         <span class="comment">// 获得对应的方法 Method 对象</span></span><br /><span class="line"> <span class="number">72</span>:                         Method method = invoker.getInterface().getMethod(methodName, parameterTypes);</span><br /><span class="line"> <span class="number">73</span>:                         <span class="comment">//【第三步】`true` ，反序列化结果，仅有 Map =&gt; POJO</span></span><br /><span class="line"> <span class="number">74</span>:                         <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(PojoUtils.realize(value, method.getReturnType(), method.getGenericReturnType()));</span><br /><span class="line"> <span class="number">75</span>:                     }</span><br /><span class="line"> <span class="number">76</span>:                 } <span class="keyword">catch</span> (NoSuchMethodException e) {</span><br /><span class="line"> <span class="number">77</span>:                     <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br /><span class="line"> <span class="number">78</span>:                 }</span><br /><span class="line"> <span class="number">79</span>:             <span class="comment">// 【第三步】反序列化异常结果</span></span><br /><span class="line"> <span class="number">80</span>:             } <span class="keyword">else</span> <span class="keyword">if</span> (result.getException() <span class="keyword">instanceof</span> GenericException) {</span><br /><span class="line"> <span class="number">81</span>:                 GenericException exception = (GenericException) result.getException();</span><br /><span class="line"> <span class="number">82</span>:                 <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">83</span>:                     String className = exception.getExceptionClass();</span><br /><span class="line"> <span class="number">84</span>:                     Class&lt;?&gt; clazz = ReflectUtils.forName(className);</span><br /><span class="line"> <span class="number">85</span>:                     Throwable targetException = <span class="keyword">null</span>;</span><br /><span class="line"> <span class="number">86</span>:                     Throwable lastException = <span class="keyword">null</span>;</span><br /><span class="line"> <span class="number">87</span>:                     <span class="comment">// 创建原始异常</span></span><br /><span class="line"> <span class="number">88</span>:                     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">89</span>:                         targetException = (Throwable) clazz.newInstance();</span><br /><span class="line"> <span class="number">90</span>:                     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"> <span class="number">91</span>:                         lastException = e;</span><br /><span class="line"> <span class="number">92</span>:                         <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : clazz.getConstructors()) {</span><br /><span class="line"> <span class="number">93</span>:                             <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">94</span>:                                 targetException = (Throwable) constructor.newInstance(<span class="keyword">new</span> Object[constructor.getParameterTypes().length]);</span><br /><span class="line"> <span class="number">95</span>:                                 <span class="keyword">break</span>;</span><br /><span class="line"> <span class="number">96</span>:                             } <span class="keyword">catch</span> (Throwable e1) {</span><br /><span class="line"> <span class="number">97</span>:                                 lastException = e1;</span><br /><span class="line"> <span class="number">98</span>:                             }</span><br /><span class="line"> <span class="number">99</span>:                         }</span><br /><span class="line"><span class="number">100</span>:                     }</span><br /><span class="line"><span class="number">101</span>:                     <span class="comment">// 设置异常的明细</span></span><br /><span class="line"><span class="number">102</span>:                     <span class="keyword">if</span> (targetException != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">103</span>:                         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">104</span>:                             Field field = Throwable.class.getDeclaredField(<span class="string">"detailMessage"</span>);</span><br /><span class="line"><span class="number">105</span>:                             <span class="keyword">if</span> (!field.isAccessible()) {</span><br /><span class="line"><span class="number">106</span>:                                 field.setAccessible(<span class="keyword">true</span>);</span><br /><span class="line"><span class="number">107</span>:                             }</span><br /><span class="line"><span class="number">108</span>:                             field.set(targetException, exception.getExceptionMessage());</span><br /><span class="line"><span class="number">109</span>:                         } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">110</span>:                             logger.warn(e.getMessage(), e);</span><br /><span class="line"><span class="number">111</span>:                         }</span><br /><span class="line"><span class="number">112</span>:                         <span class="comment">// 创建新的异常 RpcResult 对象</span></span><br /><span class="line"><span class="number">113</span>:                         result = <span class="keyword">new</span> RpcResult(targetException);</span><br /><span class="line"><span class="number">114</span>:                     <span class="comment">// 创建原始异常失败，抛出异常</span></span><br /><span class="line"><span class="number">115</span>:                     } <span class="keyword">else</span> <span class="keyword">if</span> (lastException != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">116</span>:                         <span class="keyword">throw</span> lastException;</span><br /><span class="line"><span class="number">117</span>:                     }</span><br /><span class="line"><span class="number">118</span>:                 } <span class="keyword">catch</span> (Throwable e) { <span class="comment">// 若发生异常，包装成 RpcException 异常，抛出。</span></span><br /><span class="line"><span class="number">119</span>:                     <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Can not deserialize exception "</span> + exception.getExceptionClass() + <span class="string">", message: "</span> + exception.getExceptionMessage(), e);</span><br /><span class="line"><span class="number">120</span>:                 }</span><br /><span class="line"><span class="number">121</span>:             }</span><br /><span class="line"><span class="number">122</span>:             <span class="comment">// 返回 RpcResult 结果</span></span><br /><span class="line"><span class="number">123</span>:             <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">124</span>:         }</span><br /><span class="line"><span class="number">125</span>: </span><br /><span class="line"><span class="number">126</span>:         <span class="comment">// 省略代码....泛化引用的调用</span></span><br /><span class="line"><span class="number">127</span>: </span><br /><span class="line"><span class="number">128</span>:          <span class="comment">// 普通调用</span></span><br /><span class="line"><span class="number">129</span>:         <span class="keyword">return</span> invoker.invoke(invocation);</span><br /><span class="line"><span class="number">130</span>:     }</span><br /><span class="line"><span class="number">131</span>: </span><br /><span class="line"><span class="number">132</span>:     <span class="comment">// ... 省略 getting/setting 的方法</span></span><br /><span class="line"><span class="number">133</span>: </span><br /><span class="line"><span class="number">134</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>整体，和<strong>服务提供者</strong>的 GenericFilter 有一些<strong>类似</strong>。</li>
<li>使用 Dubbo SPI Adaptive 机制，<strong>自动加载</strong>，仅限<strong>服务消费者</strong>，并且有&nbsp;<code>generic</code>&nbsp;配置项。</li>
<li>第 126 行：省略<strong>泛化引用</strong>的调用，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/rpc-feature-generic-reference">《精尽 Dubbo 源码分析 &mdash;&mdash; 调用特性（二）之泛化引用》</a>&nbsp;中，详细解析。</li>
<li>第 129 行：若是普通调用(&nbsp;<strong>非泛化引用的调用</strong>&nbsp;)，调用&nbsp;<code>Invoker#invoke(invocation)</code>&nbsp;方法，继续过滤链的调用，最终调用 Service 服务。</li>
<li>👇👇👇 正戏 👇👇👇</li>
<li>第 14 至 16 行：判断是<strong>泛化实现</strong>的调用</li>
<li>第 22 至 26 行：获得<strong>参数类型</strong>数组。</li>
<li>========== 【第一步：序列化参数】 ==========</li>
<li>第 29 至 34 行：<code>generic = bean</code>&nbsp;，调用&nbsp;<code>JavaBeanSerializeUtil#serialize(JavaBeanDescriptor)</code>方法，序列化参数，即&nbsp;<code>方法参数 =&gt; JavaBeanDescriptor</code>&nbsp;。</li>
<li>第 35 至 38 行：<code>generic = true</code>&nbsp;，调用&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/f83e70b53389a064e49babe32e61a5648002a44a/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/PojoUtils.java#L63-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>PojoUtils#generalize(Object[] objs</code></a>&nbsp;方法，序列化参数，仅有&nbsp;<code>POJO =&gt; Map</code>&nbsp;。</li>
<li>========== 【第二步：RPC 调用】 ==========</li>
<li>第 41 行：设置 RpcInvocation 的方法名为&nbsp;<code>$invoke</code>&nbsp;。</li>
<li>第 42 行：设置 RpcInvocation 的方法参数类型为&nbsp;<code>GENERIC_PARAMETER_TYPES</code>&nbsp;。</li>
<li>第 43 行：设置 RpcInvocation 的参数数组为&nbsp;<code>methodName</code>&nbsp;<code>types</code>&nbsp;<code>types</code>&nbsp;。</li>
<li>第 48 行：通过如上的&nbsp;<strong>RpcInvocation</strong>&nbsp;的设置，我们调用&nbsp;<code>Invoker#invoke(invocation)</code>&nbsp;方法，就能 RPC 调用到<strong>泛化实现</strong>的服务。</li>
<li>========== 【第三步：反序列化<strong>正常</strong>结果】 ==========</li>
<li>第 55 至 69 行：<code>generic = bean</code>&nbsp;，调用&nbsp;<code>JavaBeanSerializeUtil#serialize(JavaBeanDescriptor)</code>方法，反序列化结果，即&nbsp;<code>JavaBeanDescriptor =&gt; POJO</code>&nbsp;。</li>
<li>第 71 至 74 行：<code>generic = true</code>&nbsp;，调用&nbsp;<code>PojoUtils#realize(pojo, type, genericType)</code>&nbsp;方法，反序列化结果，仅有&nbsp;<code>Map =&gt; POJO</code>&nbsp;。</li>
<li><strong>注意</strong>，反序列完，是会创建<strong>新的</strong>&nbsp;RpcResult 。</li>
<li>========== 【第三步：反序列化<strong>异常</strong>结果】 ==========</li>
<li>第 87 至 100 行：根据 GenericException 异常，创建<strong>原始</strong>异常&nbsp;<code>targetException</code>&nbsp;。</li>
<li>第 101 至 111 行：设置异常明细到&nbsp;<code>targetException</code>&nbsp;。</li>
<li>第 113 行：创建<strong>新的</strong>异常 RpcResult 对象。</li>
<li>第 114 至 117 行：创建原始异常失败，抛出异常&nbsp;<code>lastException</code>&nbsp;。</li>
</ul>
</div>