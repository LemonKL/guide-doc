<header class="article-header">
<h1 class="article-title">NIO 服务器（六）之 Netty4 实现</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>在前面的文章，我们已经了解了&nbsp;<code>dubbo-remoting-api</code>&nbsp;如何实现 NIO 服务器的抽象 API 层。那么本文来看看，<code>dubbo-remoting-netty4</code>&nbsp;，如何将 Netty4 接入实现。</p>
<p>涉及如下类：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_12_16/01.png" alt="类图" /></p>
<blockquote>
<p>友情提示：在当前版本，默认情况下，使用 Netty3 ，如果想配置成 Netty4 ，请参考文档：<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/netty4.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; Netty4》</a></p>
</blockquote>
<h1 id="2-NettyTransporter">2. NettyTransporter</h1>
<p><code>com.alibaba.dubbo.remoting.transport.netty4.NettyTransporter</code>&nbsp;，实现 Transporter 接口，基于&nbsp;<strong>Netty4</strong>&nbsp;的网络传输实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTransporter</span> <span class="keyword">implements</span> <span class="title">Transporter</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 拓展名</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"netty4"</span>;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, listener);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyClient(url, listener);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>NAME</code>&nbsp;<strong>静态</strong>属性，拓展名。</li>
<li>NettyTransporter 基于 Dubbo SPI 机制加载。</li>
<li>创建 NettyServer 和 NettyClient 对象。</li>
</ul>
<h1 id="3-NettyChannel">3. NettyChannel</h1>
<p><code>io.netty.channel.ChannelFuture.NettyChannel</code>&nbsp;，实现 AbstractChannel 抽象类，<strong>封装 Netty Channel</strong>&nbsp;的通道实现类。</p>
<blockquote>
<p>NettyChannel 和 HeaderExchangeChannel 很类似。</p>
</blockquote>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 通道集合</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;io.netty.channel.Channel, NettyChannel&gt; channelMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Channel, NettyChannel&gt;();</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 通道</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> io.netty.channel.Channel channel;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 属性集合</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attributes = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br /><br /><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">NettyChannel</span><span class="params">(io.netty.channel.Channel channel, URL url, ChannelHandler handler)</span> </span>{</span><br /><span class="line">    <span class="keyword">super</span>(url, handler);</span><br /><span class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"netty channel == null;"</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>channel</code>&nbsp;属性，通道。NettyChannel 是传入&nbsp;<code>channel</code>&nbsp;属性的<strong>装饰器</strong>，每个实现的方法，都会调用&nbsp;<code>channel</code>&nbsp;。</li>
<li><code>attributes</code>&nbsp;属性，属性集合。<strong>注意</strong>，<code>setAttribute(...)</code>&nbsp;等方法，使用的是该属性，而不是&nbsp;<code>io.netty.channel.Channel</code>&nbsp;的。</li>
<li>
<p><code>channelMap</code>&nbsp;<strong>静态</strong>属性，通道集合。在实际 Netty Handler 里（例如下面我们会看到的 NettyServerHandler 和 NettyClientHandler），每个方法参数里，传递的是&nbsp;<code>io.netty.channel.Channel</code>&nbsp;对象。通过&nbsp;<code>NettyChannel.channelMap</code>&nbsp;中，获得对应的 NettyChannel 对象。</p>
<ul>
<li>
<p><code>#getOrAddChannel(ch, url, handler)</code>&nbsp;<strong>静态</strong>方法，创建 NettyChannel 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">static</span> NettyChannel <span class="title">getOrAddChannel</span><span class="params">(io.netty.channel.Channel ch, URL url, ChannelHandler handler)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (ch == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">    }</span><br /><span class="line">    NettyChannel ret = channelMap.get(ch);</span><br /><span class="line">    <span class="keyword">if</span> (ret == <span class="keyword">null</span>) {</span><br /><span class="line">        NettyChannel nettyChannel = <span class="keyword">new</span> NettyChannel(ch, url, handler);</span><br /><span class="line">        <span class="keyword">if</span> (ch.isActive()) { <span class="comment">// 连接中</span></span><br /><span class="line">            ret = channelMap.putIfAbsent(ch, nettyChannel); <span class="comment">// 添加到 channelMap</span></span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) {</span><br /><span class="line">            ret = nettyChannel;</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> ret;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>x</li>
</ul>
</li>
<li>
<p><code>#removeChannelIfDisconnected(ch)</code>&nbsp;<strong>静态</strong>方法，移除 NettyChannel 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeChannelIfDisconnected</span><span class="params">(io.netty.channel.Channel ch)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (ch != <span class="keyword">null</span> &amp;&amp; !ch.isActive()) { <span class="comment">// 未连接</span></span><br /><span class="line">        channelMap.remove(ch); <span class="comment">// 移除出channelMap</span></span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>x</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>发送消息</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 检查连接状态</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">super</span>.send(message, sent);</span><br /><span class="line"> <span class="number">5</span>: </span><br /><span class="line"> <span class="number">6</span>:     <span class="keyword">boolean</span> success = <span class="keyword">true</span>; <span class="comment">// 如果没有等待发送成功，默认成功。</span></span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br /><span class="line"> <span class="number">8</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">9</span>:         <span class="comment">// 发送消息</span></span><br /><span class="line"><span class="number">10</span>:         ChannelFuture future = channel.writeAndFlush(message);</span><br /><span class="line"><span class="number">11</span>:         <span class="comment">// 等待发送成功</span></span><br /><span class="line"><span class="number">12</span>:         <span class="keyword">if</span> (sent) {</span><br /><span class="line"><span class="number">13</span>:             timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br /><span class="line"><span class="number">14</span>:             success = future.await(timeout);</span><br /><span class="line"><span class="number">15</span>:         }</span><br /><span class="line"><span class="number">16</span>:         <span class="comment">// 若发生异常，抛出</span></span><br /><span class="line"><span class="number">17</span>:         Throwable cause = future.cause();</span><br /><span class="line"><span class="number">18</span>:         <span class="keyword">if</span> (cause != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">19</span>:             <span class="keyword">throw</span> cause;</span><br /><span class="line"><span class="number">20</span>:         }</span><br /><span class="line"><span class="number">21</span>:     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">22</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message "</span> + message + <span class="string">" to "</span> + getRemoteAddress() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br /><span class="line"><span class="number">23</span>:     }</span><br /><span class="line"><span class="number">24</span>: </span><br /><span class="line"><span class="number">25</span>:     <span class="comment">// 发送失败，抛出异常</span></span><br /><span class="line"><span class="number">26</span>:     <span class="keyword">if</span> (!success) {</span><br /><span class="line"><span class="number">27</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message "</span> + message + <span class="string">" to "</span> + getRemoteAddress()</span><br /><span class="line"><span class="number">28</span>:                 + <span class="string">"in timeout("</span> + timeout + <span class="string">"ms) limit"</span>);</span><br /><span class="line"><span class="number">29</span>:     }</span><br /><span class="line"><span class="number">30</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 4 行：调用&nbsp;<code>#send(message, sent)</code>&nbsp;方法，检查连接状态。</li>
<li>第 6 行：<code>success</code>&nbsp;，是否执行成功。若不需要等待发送成功(&nbsp;<code>sent = false</code>&nbsp;) ，默认成功。</li>
<li>第 10 行：调用<strong>真正的</strong>&nbsp;<code>io.netty.channel.Channel#writeAndFlush(message)</code>&nbsp;方法，发送消息。</li>
<li>第 11 至 15 行：若需要等待发送成功(&nbsp;<code>sent = true</code>&nbsp;)，等待直到成功或超时。</li>
<li>第 16 至 20 行：若发生异常，抛出异常。</li>
<li>第 26 至 29 行：若发送失败，抛出异常。</li>
</ul>
<p><strong>关闭通道</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 标记关闭</span></span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        <span class="keyword">super</span>.close();</span><br /><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">        logger.warn(e.getMessage(), e);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 移除连接</span></span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        removeChannelIfDisconnected(channel);</span><br /><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">        logger.warn(e.getMessage(), e);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 清空属性 attributes</span></span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        attributes.clear();</span><br /><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">        logger.warn(e.getMessage(), e);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 关闭真正的通道 channel</span></span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line">            logger.info(<span class="string">"Close netty channel "</span> + channel);</span><br /><span class="line">        }</span><br /><span class="line">        channel.close();</span><br /><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">        logger.warn(e.getMessage(), e);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><strong>注意</strong>，最后一步才关闭真正的通道，避免中间状态。</li>
</ul>
<p><strong>其它方法</strong></p>
<p>其它实现方法，比较简单，胖友自己瞅瞅。例如：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> !isClosed() &amp;&amp; channel.isActive();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="4-Server">4. Server</h1>
<h2 id="4-1-NettyServer">4.1 NettyServer</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/com/alibaba/dubbo/remoting/transport/netty4/NettyServer.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.transport.netty4.NettyServer</code></a>&nbsp;，实现 Server 接口，继承 AbstractServer 抽象类，Netty 服务器实现类。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 通道集合</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Map&lt;String, Channel&gt; channels; <span class="comment">// &lt;ip:port, channel&gt;</span></span><br /><br /><span class="line"><span class="keyword">private</span> ServerBootstrap bootstrap;</span><br /><br /><span class="line"><span class="keyword">private</span> io.netty.channel.Channel channel;</span><br /><br /><span class="line"><span class="keyword">private</span> EventLoopGroup bossGroup;</span><br /><span class="line"><span class="keyword">private</span> EventLoopGroup workerGroup;</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">    <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME) <span class="comment">/* 设置线程名到 URL 上 */</span>));</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><code>channels</code>&nbsp;属性，连接到服务器的客户端通道集合。笔者在看 NettyChannel 时，在有&nbsp;<code>NettyChannel.channels</code>，那么此处的&nbsp;<code>channels</code>&nbsp;不是重复了么？答案在&nbsp;<code>#getChannel(remoteAddress)</code>&nbsp;方法，获得<strong>指定地址</strong>的 Channel 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">getChannel</span><span class="params">(InetSocketAddress remoteAddress)</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> channels.get(NetUtils.toAddressString(remoteAddress));</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p><code>bootstrap</code>&nbsp;<code>channel</code>&nbsp;<code>bossGroup</code>&nbsp;<code>workerGroup</code>&nbsp;属性，😈 不熟悉这几个的胖友，请 Google 一下 Netty 入门噶。</p>
</li>
<li><code>ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)</code>代码段，包装 ChannelHandler ，实现 Dubbo 线程模型的功能。
<ul>
<li><a href="http://svip.iocoder.cn/Dubbo/remoting-api-transport/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（二）之 Transport 层》「8. Dispacher」</a>&nbsp;有详细解析。</li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/thread-model.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 线程模型》</a></li>
</ul>
</li>
</ul>
<p><strong>启动服务器</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 设置日志工厂</span></span><br /><span class="line"> <span class="number">4</span>:     NettyHelper.setNettyLoggerFactory();</span><br /><span class="line"> <span class="number">5</span>: </span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// 实例化 ServerBootstrap</span></span><br /><span class="line"> <span class="number">7</span>:     bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br /><span class="line"> <span class="number">8</span>: </span><br /><span class="line"> <span class="number">9</span>:     <span class="comment">// 创建线程组</span></span><br /><span class="line"><span class="number">10</span>:     bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>, <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br /><span class="line"><span class="number">11</span>:     workerGroup = <span class="keyword">new</span> NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</span><br /><span class="line"><span class="number">12</span>:             <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br /><span class="line"><span class="number">13</span>: </span><br /><span class="line"><span class="number">14</span>:     <span class="comment">// 创建 NettyServerHandler 对象</span></span><br /><span class="line"><span class="number">15</span>:     <span class="keyword">final</span> NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</span><br /><span class="line"><span class="number">16</span>:     <span class="comment">// 设置 `channels` 属性</span></span><br /><span class="line"><span class="number">17</span>:     channels = nettyServerHandler.getChannels();</span><br /><span class="line"><span class="number">18</span>: </span><br /><span class="line"><span class="number">19</span>:     bootstrap</span><br /><span class="line"><span class="number">20</span>:             <span class="comment">// 设置它的线程组</span></span><br /><span class="line"><span class="number">21</span>:             .group(bossGroup, workerGroup)</span><br /><span class="line"><span class="number">22</span>:             <span class="comment">// 设置 Channel类型</span></span><br /><span class="line"><span class="number">23</span>:             .channel(NioServerSocketChannel.class) <span class="comment">// Server</span></span><br /><span class="line"><span class="number">24</span>:             <span class="comment">// 设置可选项</span></span><br /><span class="line"><span class="number">25</span>:             .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span><br /><span class="line"><span class="number">26</span>:             .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span><br /><span class="line"><span class="number">27</span>:             .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br /><span class="line"><span class="number">28</span>:             <span class="comment">// 设置责任链路</span></span><br /><span class="line"><span class="number">29</span>:             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() {</span><br /><span class="line"><span class="number">30</span>:                 <span class="meta">@Override</span></span><br /><span class="line"><span class="number">31</span>:                 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>{</span><br /><span class="line"><span class="number">32</span>:                     <span class="comment">// 创建 NettyCodecAdapter 对象</span></span><br /><span class="line"><span class="number">33</span>:                     NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br /><span class="line"><span class="number">34</span>:                     ch.pipeline()<span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug</span></span><br /><span class="line"><span class="number">35</span>:                             .addLast(<span class="string">"decoder"</span>, adapter.getDecoder()) <span class="comment">// 解码</span></span><br /><span class="line"><span class="number">36</span>:                             .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())  <span class="comment">// 解码</span></span><br /><span class="line"><span class="number">37</span>:                             .addLast(<span class="string">"handler"</span>, nettyServerHandler); <span class="comment">// 处理器</span></span><br /><span class="line"><span class="number">38</span>:                 }</span><br /><span class="line"><span class="number">39</span>:             });</span><br /><span class="line"><span class="number">40</span>: </span><br /><span class="line"><span class="number">41</span>:     <span class="comment">// 服务器绑定端口监听</span></span><br /><span class="line"><span class="number">42</span>:     <span class="comment">// bind</span></span><br /><span class="line"><span class="number">43</span>:     ChannelFuture channelFuture = bootstrap.bind(getBindAddress());</span><br /><span class="line"><span class="number">44</span>:     channelFuture.syncUninterruptibly();</span><br /><span class="line"><span class="number">45</span>:     channel = channelFuture.channel();</span><br /><span class="line"><span class="number">46</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>参考：<a href="https://tinyzzh.github.io/netty/2014/08/12/Netty4.x_6.html" target="_blank" rel="external nofollow noopener noreferrer">《Netty4.x中文教程系列(六) 从头开始Bootstrap》</a></li>
<li>第 4 行：设置 Netty 的日志工厂，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-impl-netty4/">「7. 日志处理」</a>&nbsp;详细解析。</li>
<li>第 7 行：实例化 ServerBootstrap 对象。</li>
<li>第 9 至 12 行：创建&nbsp;<code>bossGroup</code>&nbsp;<code>workerGroup</code>&nbsp;线程组。</li>
<li>第 15 行：创建 NettyServerHandler 对象。</li>
<li>第 17 行：设置&nbsp;<code>channels</code>&nbsp;属性，指向&nbsp;<code>NettyServerHandler.channels</code>&nbsp;属性。</li>
<li>第 21 行：设置线程组。</li>
<li>第 23 行：设置 Channel 类型为 NioServerSocketChannel 。</li>
<li>第 24 至 27 行：设置可选项。
<ul>
<li><code>PooledByteBufAllocator.DEFAULT</code>&nbsp;，对象池，重用缓冲区。参见&nbsp;<a href="http://huangdongrong.github.io/2016/05/24/netty-jvm/" target="_blank" rel="external nofollow noopener noreferrer">《Netty 调优》</a>&nbsp;。</li>
</ul>
</li>
<li>第 29 至 39 行：设置责任链。
<ul>
<li>第 33 行：创建 NettyCodecAdapter 对象。NettyCodecAdapter 在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/remoting-impl-netty4/">「6. 2 NettyCodecAdapter」</a>&nbsp;详细解析。</li>
<li>第 35 行：调用&nbsp;<code>NettyCodecAdapter#getDecoder()</code>&nbsp;方法，获得解码器，并设置。</li>
<li>第 37 行：调用&nbsp;<code>NettyCodecAdapter#getEncoder()</code>&nbsp;方法，获得编码器，并设置。</li>
<li>第 37 行：设置处理器&nbsp;<code>handler</code>&nbsp;。</li>
</ul>
</li>
<li>第 41 至 45 行：服务器绑定端口监听，<strong>正式启动</strong>啦。</li>
</ul>
<p><strong>获得所有通道</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>{</span><br /><span class="line">    Collection&lt;Channel&gt; chs = <span class="keyword">new</span> HashSet&lt;Channel&gt;();</span><br /><span class="line">    <span class="keyword">for</span> (Channel channel : <span class="keyword">this</span>.channels.values()) {</span><br /><span class="line">        <span class="keyword">if</span> (channel.isConnected()) { <span class="comment">// 已连接，返回</span></span><br /><span class="line">            chs.add(channel);</span><br /><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 未连接，移除</span></span><br /><span class="line">            channels.remove(NetUtils.toAddressString(channel.getRemoteAddress()));</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> chs;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p><strong>关闭服务器</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 关闭服务器通道</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (channel != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">6</span>:             <span class="comment">// unbind.</span></span><br /><span class="line"> <span class="number">7</span>:             channel.close();</span><br /><span class="line"> <span class="number">8</span>:         }</span><br /><span class="line"> <span class="number">9</span>:     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">10</span>:         logger.warn(e.getMessage(), e);</span><br /><span class="line"><span class="number">11</span>:     }</span><br /><span class="line"><span class="number">12</span>:     <span class="comment">// 关闭连接到服务器的客户端通道</span></span><br /><span class="line"><span class="number">13</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">14</span>:         Collection&lt;com.alibaba.dubbo.remoting.Channel&gt; channels = getChannels();</span><br /><span class="line"><span class="number">15</span>:         <span class="keyword">if</span> (channels != <span class="keyword">null</span> &amp;&amp; channels.size() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">16</span>:             <span class="keyword">for</span> (com.alibaba.dubbo.remoting.Channel channel : channels) {</span><br /><span class="line"><span class="number">17</span>:                 <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">18</span>:                     channel.close();</span><br /><span class="line"><span class="number">19</span>:                 } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">20</span>:                     logger.warn(e.getMessage(), e);</span><br /><span class="line"><span class="number">21</span>:                 }</span><br /><span class="line"><span class="number">22</span>:             }</span><br /><span class="line"><span class="number">23</span>:         }</span><br /><span class="line"><span class="number">24</span>:     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">25</span>:         logger.warn(e.getMessage(), e);</span><br /><span class="line"><span class="number">26</span>:     }</span><br /><span class="line"><span class="number">27</span>:     <span class="comment">// 优雅关闭工作组</span></span><br /><span class="line"><span class="number">28</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">29</span>:         <span class="keyword">if</span> (bootstrap != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">30</span>:             bossGroup.shutdownGracefully();</span><br /><span class="line"><span class="number">31</span>:             workerGroup.shutdownGracefully();</span><br /><span class="line"><span class="number">32</span>:         }</span><br /><span class="line"><span class="number">33</span>:     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">34</span>:         logger.warn(e.getMessage(), e);</span><br /><span class="line"><span class="number">35</span>:     }</span><br /><span class="line"><span class="number">36</span>:     <span class="comment">// 清空连接到服务器的客户端通道</span></span><br /><span class="line"><span class="number">37</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">38</span>:         <span class="keyword">if</span> (channels != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">39</span>:             channels.clear();</span><br /><span class="line"><span class="number">40</span>:         }</span><br /><span class="line"><span class="number">41</span>:     } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">42</span>:         logger.warn(e.getMessage(), e);</span><br /><span class="line"><span class="number">43</span>:     }</span><br /><span class="line"><span class="number">44</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 至 11 行：关闭服务器通道(&nbsp;<code>io.netty.channel.Channel</code>&nbsp;)。</li>
<li>第 12 至 26 行：关闭连接到服务器的客户端通道(&nbsp;<code>com.alibaba.dubbo.remoting.Channel</code>&nbsp;) 。</li>
<li>第 27 至 35 行：优雅关闭工作组。</li>
<li>第 36 至 43 行：清空连接到服务器的客户端通道。</li>
</ul>
<h2 id="4-2-NettyServerHandler">4.2 NettyServerHandler</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/com/alibaba/dubbo/remoting/transport/netty4/NettyServerHandler.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.transport.netty4.NettyServerHandler</code></a>&nbsp;，实现&nbsp;<code>io.netty.channel.ChannelDuplexHandler</code>&nbsp;类，NettyServer 的处理器。</p>
<blockquote>
<p>NettyServerHandler 和 HeaderExchangeHandler 类似。</p>
</blockquote>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@io</span>.netty.channel.ChannelHandler.Sharable</span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Dubbo Channel 集合</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Channel&gt;(); <span class="comment">// &lt;ip:port, channel&gt;</span></span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * URL</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Dubbo ChannelHandler</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">(URL url, ChannelHandler handler)</span> </span>{</span><br /><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">this</span>.url = url;</span><br /><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br /><span class="line">    }</span><br />    <br /><span class="line">    <span class="comment">// ... 省略实现方法</span></span><br />    <br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p><a href="mailto:%60@io.netty.channel.ChannelHandler.Sharable" target="_blank" rel="external nofollow noopener noreferrer">`@io.netty.channel.ChannelHandler.Sharable</a>` 注解：</p>
<blockquote>
<p>FROM&nbsp;<a href="https://www.zhihu.com/question/50198921" target="_blank" rel="external nofollow noopener noreferrer">《netty4中注解Sharable的使用场景？》</a></p>
<p>Sharable 注解主要是用来标示一个 ChannelHandler 可以被安全地共享，即可以在多个Channel 的 ChannelPipeline 中使用同一个ChannelHandler ，而不必每一个ChannelPipeline 都重新 new 一个新的 ChannelHandler 。</p>
</blockquote>
</li>
<li>
<p><code>channels</code>&nbsp;属性，连接到服务器的 Dubbo Channel 集合。</p>
</li>
<li><code>handler</code>&nbsp;属性，Dubbo ChannelHandler。NettyServerHandler 对每个事件的处理，会调用&nbsp;<code>handler</code>&nbsp;对应的方法。</li>
</ul>
<p><strong>实现方法</strong></p>
<p>每个实现的方法，处理都比较类似，一般是提交给&nbsp;<code>handler</code>&nbsp;做相应的处理。艿艿已经添加了代码注释，胖友可以自己看看。下面以&nbsp;<code>#channelActive(ChannelHandlerContext)</code>&nbsp;方法举例子，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 交给下一个节点处理</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">// 芋艿：实际此处不要调用也没关系，因为 NettyServerHandler 没下一个节点。</span></span><br /><span class="line"> <span class="number">5</span>:     ctx.fireChannelActive();</span><br /><span class="line"> <span class="number">6</span>: </span><br /><span class="line"> <span class="number">7</span>:     <span class="comment">// 创建 NettyChannel 对象</span></span><br /><span class="line"> <span class="number">8</span>:     NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br /><span class="line"> <span class="number">9</span>:     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">10</span>:         <span class="comment">// 添加到 `channels` 中</span></span><br /><span class="line"><span class="number">11</span>:         <span class="keyword">if</span> (channel != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">12</span>:             channels.put(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()), channel);</span><br /><span class="line"><span class="number">13</span>:         }</span><br /><span class="line"><span class="number">14</span>:         <span class="comment">// 提交给 `handler` 处理器。</span></span><br /><span class="line"><span class="number">15</span>:         handler.connected(channel);</span><br /><span class="line"><span class="number">16</span>:     } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">17</span>:         <span class="comment">// 移除 NettyChannel 对象，若已断开</span></span><br /><span class="line"><span class="number">18</span>:         NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br /><span class="line"><span class="number">19</span>:     }</span><br /><span class="line"><span class="number">20</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><a href="https://www.jianshu.com/p/88ffafa23221" target="_blank" rel="external nofollow noopener noreferrer">《Netty 框架总结「ChannelHandler 及 EventLoop」》</a></li>
<li>第 5 行：调用&nbsp;<code>ChannelHandlerContext#fireChannelActive()</code>&nbsp;方法，交给下一个节点处理。实际上，<strong>此处不要调用也没关系</strong>，因为 NettyServerHandler 没下一个节点。</li>
<li>第 8 行：调用&nbsp;<code>NettyChannel#getOrAddChannel(channel, url, handler)</code>&nbsp;方法，创建 NettyChannel 对象。</li>
<li>第 10 至 13 行：添加到&nbsp;<code>channels</code>&nbsp;中。</li>
<li>第 15 行：调用&nbsp;<code>ChannelHandler#connected(channel)</code>&nbsp;方法，处理连接事件。</li>
<li>第 16 至 19 行：调用&nbsp;<code>NettyChannel#removeChannelIfDisconnected(channel)</code>&nbsp;方法，移除 NettyChannel 对象，若<strong>已断开</strong>。</li>
</ul>
<h1 id="5-Client">5. Client</h1>
<h2 id="5-1-NettyClient">5.1 NettyClient</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/com/alibaba/dubbo/remoting/transport/netty4/NettyClient.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.transport.netty4.NettyClient</code></a>&nbsp;，继承 AbstractNettyClient 抽象类，Netty 客户端实现类。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// 【TODO 8027】为啥公用</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NioEventLoopGroup nioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(Constants.DEFAULT_IO_THREADS, <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyClientWorker"</span>, <span class="keyword">true</span>));</span><br /><br /><span class="line"><span class="keyword">private</span> Bootstrap bootstrap;</span><br /><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> io.netty.channel.Channel channel; <span class="comment">// volatile, please copy reference to use</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>{</span><br /><span class="line">    <span class="keyword">super</span>(url, wrapChannelHandler(url, handler));</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>nioEventLoopGroup</code>&nbsp;属性，【TODO 8027】为啥公用</li>
<li><code>channel</code>&nbsp;属性，通道，有&nbsp;<strong>volatile</strong>&nbsp;修饰符。因为客户端可能会断开重连，需要保证<strong>多线程</strong>的可见性。</li>
<li><code>#wrapChannelHandler(url, handler)</code>&nbsp;代码段，包装 ChannelHandler ，实现 Dubbo 线程模型的功能。
<ul>
<li><a href="http://svip.iocoder.cn/Dubbo/remoting-api-transport/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; NIO 服务器（二）之 Transport 层》「8. Dispacher」</a>&nbsp;有详细解析。</li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/thread-model.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 线程模型》</a></li>
</ul>
</li>
</ul>
<p><strong>启动客户端</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 设置日志工厂</span></span><br /><span class="line"> <span class="number">4</span>:     NettyHelper.setNettyLoggerFactory();</span><br /><span class="line"> <span class="number">5</span>: </span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// 创建 NettyClientHandler 对象</span></span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">final</span> NettyClientHandler nettyClientHandler = <span class="keyword">new</span> NettyClientHandler(getUrl(), <span class="keyword">this</span>);</span><br /><span class="line"> <span class="number">8</span>: </span><br /><span class="line"> <span class="number">9</span>:     <span class="comment">// 实例化 ServerBootstrap</span></span><br /><span class="line"><span class="number">10</span>:     bootstrap = <span class="keyword">new</span> Bootstrap();</span><br /><span class="line"><span class="number">11</span>:     bootstrap</span><br /><span class="line"><span class="number">12</span>:             <span class="comment">// 设置它的线程组</span></span><br /><span class="line"><span class="number">13</span>:             .group(nioEventLoopGroup)</span><br /><span class="line"><span class="number">14</span>:             <span class="comment">// 设置可选项</span></span><br /><span class="line"><span class="number">15</span>:             .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br /><span class="line"><span class="number">16</span>:             .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br /><span class="line"><span class="number">17</span>:             .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br /><span class="line"><span class="number">18</span>:             <span class="comment">//.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())</span></span><br /><span class="line"><span class="number">19</span>:             <span class="comment">// 设置 Channel类型</span></span><br /><span class="line"><span class="number">20</span>:             .channel(NioSocketChannel.class);</span><br /><span class="line"><span class="number">21</span>: </span><br /><span class="line"><span class="number">22</span>:     <span class="comment">// 设置连接超时时间</span></span><br /><span class="line"><span class="number">23</span>:     <span class="keyword">if</span> (getTimeout() &lt; <span class="number">3000</span>) {</span><br /><span class="line"><span class="number">24</span>:         bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">3000</span>);</span><br /><span class="line"><span class="number">25</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">26</span>:         bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout());</span><br /><span class="line"><span class="number">27</span>:     }</span><br /><span class="line"><span class="number">28</span>: </span><br /><span class="line"><span class="number">29</span>:     <span class="comment">// 设置责任链路</span></span><br /><span class="line"><span class="number">30</span>:     bootstrap.handler(<span class="keyword">new</span> ChannelInitializer() {</span><br /><span class="line"><span class="number">31</span>:         <span class="meta">@Override</span></span><br /><span class="line"><span class="number">32</span>:         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>{</span><br /><span class="line"><span class="number">33</span>:             <span class="comment">// 创建 NettyCodecAdapter 对象</span></span><br /><span class="line"><span class="number">34</span>:             NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br /><span class="line"><span class="number">35</span>:             ch.pipeline()<span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug</span></span><br /><span class="line"><span class="number">36</span>:                     .addLast(<span class="string">"decoder"</span>, adapter.getDecoder()) <span class="comment">// 解码</span></span><br /><span class="line"><span class="number">37</span>:                     .addLast(<span class="string">"encoder"</span>, adapter.getEncoder()) <span class="comment">// 解码</span></span><br /><span class="line"><span class="number">38</span>:                     .addLast(<span class="string">"handler"</span>, nettyClientHandler); <span class="comment">// 处理器</span></span><br /><span class="line"><span class="number">39</span>:         }</span><br /><span class="line"><span class="number">40</span>:     });</span><br /><span class="line"><span class="number">41</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>和&nbsp;<code>NettyClient#doOpen()</code>&nbsp;方法类似。我们仅仅说一些差异点。</li>
<li>第 7 行：创建 NettyClientHandler 对象。</li>
<li>第 13 行：设置线程组，没有&nbsp;<code>bossGroup</code>&nbsp;。</li>
<li>第 20 行：设置 Channel 类型为 NioSocketChannel 。</li>
<li>第 22 至 27 行：设置连接超时时间。</li>
</ul>
<p><strong>连接服务器</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"Duplicates"</span>)</span><br /><span class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>{</span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">long</span> start = System.currentTimeMillis();</span><br /><span class="line"> <span class="number">5</span>:     <span class="comment">// 连接服务器</span></span><br /><span class="line"> <span class="number">6</span>:     ChannelFuture future = bootstrap.connect(getConnectAddress());</span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">8</span>:         <span class="comment">// 等待连接成功或者超时</span></span><br /><span class="line"> <span class="number">9</span>:         <span class="keyword">boolean</span> ret = future.awaitUninterruptibly(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br /><span class="line"><span class="number">10</span>:         <span class="comment">// 连接成功</span></span><br /><span class="line"><span class="number">11</span>:         <span class="keyword">if</span> (ret &amp;&amp; future.isSuccess()) {</span><br /><span class="line"><span class="number">12</span>:             Channel newChannel = future.channel();</span><br /><span class="line"><span class="number">13</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">14</span>:                 <span class="comment">// 关闭老的连接</span></span><br /><span class="line"><span class="number">15</span>:                 <span class="comment">// Close old channel</span></span><br /><span class="line"><span class="number">16</span>:                 Channel oldChannel = NettyClient.<span class="keyword">this</span>.channel; <span class="comment">// copy reference</span></span><br /><span class="line"><span class="number">17</span>:                 <span class="keyword">if</span> (oldChannel != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">18</span>:                     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">19</span>:                         <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line"><span class="number">20</span>:                             logger.info(<span class="string">"Close old netty channel "</span> + oldChannel + <span class="string">" on create new netty channel "</span> + newChannel);</span><br /><span class="line"><span class="number">21</span>:                         }</span><br /><span class="line"><span class="number">22</span>:                         oldChannel.close();</span><br /><span class="line"><span class="number">23</span>:                     } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">24</span>:                         NettyChannel.removeChannelIfDisconnected(oldChannel);</span><br /><span class="line"><span class="number">25</span>:                     }</span><br /><span class="line"><span class="number">26</span>:                 }</span><br /><span class="line"><span class="number">27</span>:             } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">28</span>:                 <span class="comment">// 若 NettyClient 被关闭，关闭连接</span></span><br /><span class="line"><span class="number">29</span>:                 <span class="keyword">if</span> (NettyClient.<span class="keyword">this</span>.isClosed()) {</span><br /><span class="line"><span class="number">30</span>:                     <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">31</span>:                         <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br /><span class="line"><span class="number">32</span>:                             logger.info(<span class="string">"Close new netty channel "</span> + newChannel + <span class="string">", because the client closed."</span>);</span><br /><span class="line"><span class="number">33</span>:                         }</span><br /><span class="line"><span class="number">34</span>:                         newChannel.close();</span><br /><span class="line"><span class="number">35</span>:                     } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">36</span>:                         NettyClient.<span class="keyword">this</span>.channel = <span class="keyword">null</span>;</span><br /><span class="line"><span class="number">37</span>:                         NettyChannel.removeChannelIfDisconnected(newChannel);</span><br /><span class="line"><span class="number">38</span>:                     }</span><br /><span class="line"><span class="number">39</span>:                 <span class="comment">// 设置新连接</span></span><br /><span class="line"><span class="number">40</span>:                 } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">41</span>:                     NettyClient.<span class="keyword">this</span>.channel = newChannel;</span><br /><span class="line"><span class="number">42</span>:                 }</span><br /><span class="line"><span class="number">43</span>:             }</span><br /><span class="line"><span class="number">44</span>:         <span class="comment">// 发生异常，抛出 RemotingException 异常</span></span><br /><span class="line"><span class="number">45</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (future.cause() != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">46</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"client(url: "</span> + getUrl() + <span class="string">") failed to connect to server "</span></span><br /><span class="line"><span class="number">47</span>:                     + getRemoteAddress() + <span class="string">", error message is:"</span> + future.cause().getMessage(), future.cause());</span><br /><span class="line"><span class="number">48</span>:         <span class="comment">// 无结果（连接超时），抛出 RemotingException 异常</span></span><br /><span class="line"><span class="number">49</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">50</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"client(url: "</span> + getUrl() + <span class="string">") failed to connect to server "</span></span><br /><span class="line"><span class="number">51</span>:                     + getRemoteAddress() + <span class="string">" client-side timeout "</span></span><br /><span class="line"><span class="number">52</span>:                     + getConnectTimeout() + <span class="string">"ms (elapsed: "</span> + (System.currentTimeMillis() - start) + <span class="string">"ms) from netty client "</span></span><br /><span class="line"><span class="number">53</span>:                     + NetUtils.getLocalHost() + <span class="string">" using dubbo version "</span> + Version.getVersion());</span><br /><span class="line"><span class="number">54</span>:         }</span><br /><span class="line"><span class="number">55</span>:     } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">56</span>:         <span class="keyword">if</span> (!isConnected()) {</span><br /><span class="line"><span class="number">57</span>:             <span class="comment">//future.cancel(true);</span></span><br /><span class="line"><span class="number">58</span>:         }</span><br /><span class="line"><span class="number">59</span>:     }</span><br /><span class="line"><span class="number">60</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 6 行：调用&nbsp;<code>Bootstrap#connect(remoteAddress)</code>&nbsp;方法，连接服务器。</li>
<li>第 9 行：调用&nbsp;<code>ChannelFuture#awaitUninterruptibly(3000, TimeUnit)</code>&nbsp;方法，等待连接成功或超时。这里传入&nbsp;<code>3000</code>&nbsp;貌似不太正确，应该传入&nbsp;<code>ChannelOption.CONNECT_TIMEOUT_MILLIS</code>&nbsp;的实际值。</li>
<li>第 10 至 43 行：连接成功。
<ul>
<li>第 14 至 26 行：若存在<strong>老的</strong>连接，调用&nbsp;<code>Channel#close()</code>&nbsp;方法，进行关闭。</li>
<li>第 29 至 38 行：若 NettyClient 被关闭，调用&nbsp;<code>Channel#close()</code>&nbsp;方法，关闭<strong>新的连接</strong>。</li>
<li>第 39 至 42 行：设置<strong>新的连接</strong>到&nbsp;<code>channel</code>。</li>
</ul>
</li>
<li>第 44 至 47 行：发生异常，抛出&nbsp;<strong>Server</strong>&nbsp;RemotingException 异常。</li>
<li>第 48 至 54 行：无结果（连接超时），抛出&nbsp;<strong>Client</strong>&nbsp;RemotingException 异常。</li>
<li>第 55 至 59 行：// 【TODO 8028】为什么不取消 future TODO 可能，和 3000 有关系。&lt; 3000 强制 3000 。以及等待 3000</li>
</ul>
<p><strong>断开连接</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDisConnect</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        NettyChannel.removeChannelIfDisconnected(channel);</span><br /><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">        logger.warn(t.getMessage());</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p><strong>关闭连接</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>{</span><br /><span class="line">    <span class="comment">//can't shutdown nioEventLoopGroup</span></span><br /><span class="line">    <span class="comment">//nioEventLoopGroup.shutdownGracefully();</span></span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="5-2-NettyClientHandler">5.2 NettyClientHandler</h2>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/com/alibaba/dubbo/remoting/transport/netty4/NettyClientHandler.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.transport.netty4.NettyClientHandler</code></a>&nbsp;，实现&nbsp;<code>io.netty.channel.ChannelDuplexHandler</code>&nbsp;类，NettyClient 的处理器。</p>
<blockquote>
<p>NettyServerHandler 和 HeaderExchangeHandler 类似。</p>
</blockquote>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@io</span>.netty.channel.ChannelHandler.Sharable</span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Dubbo URL</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Dubbo ChannelHandler</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">(URL url, ChannelHandler handler)</span> </span>{</span><br /><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">this</span>.url = url;</span><br /><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br /><span class="line">    }</span><br />    <br /><span class="line">    <span class="comment">// ... 省略实现方法</span></span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<p><strong>实现方法</strong></p>
<p>NettyClientHandler 的<strong>处理方式</strong>，和 NettyServerHandler 大体一致，但是也存在<strong>一定的差异</strong>，以&nbsp;<code>#channelActive(ChannelHandlerContext)</code>&nbsp;方法举例子，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{</span><br /><span class="line">    ctx.fireChannelActive();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>不同于 NettyServerHandler 的该方法，会提交给&nbsp;<code>handler</code>&nbsp;继续处理。因为，客户端不会被连接，无需做连入 Channel 的管理。</li>
</ul>
<p>🙂 其他方法，胖友自己查看。</p>
<h1 id="6-NettyBackedChannelBuffer">6. NettyBackedChannelBuffer</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/com/alibaba/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.transport.netty4.NettyBackedChannelBuffer</code></a>&nbsp;，实现 ChannelBuffer 接口，基于&nbsp;<strong>Netty ByteBuf</strong>&nbsp;的 ChannelBuffer 实现类。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> ByteBuf buffer;</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyBackedChannelBuffer</span><span class="params">(ByteBuf buffer)</span> </span>{</span><br /><span class="line">    Assert.notNull(buffer, <span class="string">"buffer == null"</span>);</span><br /><span class="line">    <span class="keyword">this</span>.buffer = buffer;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><a href="https://waylau.gitbooks.io/essential-netty-in-action/CORE%20FUNCTIONS/ByteBuf%20-%20The%20byte%20data%20container.html" target="_blank" rel="external nofollow noopener noreferrer">《ByteBuf - 字节数据的容器》</a></li>
</ul>
<p><strong>工厂</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="comment">//has nothing use</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> ChannelBufferFactory <span class="title">factory</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>无使用工厂的地方。</li>
<li>另外，ByteBuf 默认情况下，容量为 Integer.MAX_VALUE 。</li>
</ul>
<p><strong>实现方法</strong></p>
<p>每个方法，直接调用 ByteBuf 对应的方法。🙂 ChannelBuffer 是以 ByteBuf 为<strong>原型</strong>，设计的接口 API 。</p>
<h1 id="7-NettyCodecAdapter">7. NettyCodecAdapter</h1>
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/com/alibaba/dubbo/remoting/transport/netty4/NettyCodecAdapter.java" target="_blank" rel="external nofollow noopener noreferrer"><code>com.alibaba.dubbo.remoting.transport.netty4.NettyCodecAdapter</code></a>&nbsp;，Netty 编解码<strong>适配器</strong>，将&nbsp;<strong>Dubbo 编解码器</strong>&nbsp;适配成 Netty4 的编码器和解码器。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Netty 编码器</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler encoder = <span class="keyword">new</span> InternalEncoder();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Netty 解码器</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler decoder = <span class="keyword">new</span> InternalDecoder();</span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Dubbo 编解码器</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Codec2 codec;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Dubbo URL</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Dubbo ChannelHandler</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> com.alibaba.dubbo.remoting.ChannelHandler handler;</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyCodecAdapter</span><span class="params">(Codec2 codec, URL url, com.alibaba.dubbo.remoting.ChannelHandler handler)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>.codec = codec;</span><br /><span class="line">    <span class="keyword">this</span>.url = url;</span><br /><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="7-1-InternalEncoder">7.1 InternalEncoder</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>{</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line">        <span class="comment">// 创建 NettyBackedChannelBuffer 对象</span></span><br /><span class="line">        com.alibaba.dubbo.remoting.buffer.ChannelBuffer buffer = <span class="keyword">new</span> NettyBackedChannelBuffer(out);</span><br /><span class="line">        <span class="comment">// 获得 NettyChannel 对象</span></span><br /><span class="line">        Channel ch = ctx.channel();</span><br /><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ch, url, handler);</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="comment">// 编码</span></span><br /><span class="line">            codec.encode(channel, buffer, msg);</span><br /><span class="line">        } <span class="keyword">finally</span> {</span><br /><span class="line">            <span class="comment">// 移除 NettyChannel 对象，若断开连接</span></span><br /><span class="line">            NettyChannel.removeChannelIfDisconnected(ch);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>io.netty.handler.codec.MessageToByteEncoder</code>&nbsp;，Netty4 编码器<strong>抽象类</strong>。</li>
<li>🙂 代码比较简单，胖友自己看注释。</li>
</ul>
<h2 id="7-2-InternalDecoder">7.2 InternalDecoder</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>{</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf input, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>{</span><br /><span class="line">        <span class="comment">// 创建 NettyBackedChannelBuffer 对象</span></span><br /><span class="line">        ChannelBuffer message = <span class="keyword">new</span> NettyBackedChannelBuffer(input);</span><br /><span class="line">        <span class="comment">// 获得 NettyChannel 对象</span></span><br /><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br /><span class="line">        <span class="comment">// 循环解析，直到结束</span></span><br /><span class="line">        Object msg;</span><br /><span class="line">        <span class="keyword">int</span> saveReaderIndex;</span><br /><span class="line">        <span class="keyword">try</span> {</span><br /><span class="line">            <span class="comment">// decode object.</span></span><br /><span class="line">            <span class="keyword">do</span> {</span><br /><span class="line">                <span class="comment">// 记录当前读进度</span></span><br /><span class="line">                saveReaderIndex = message.readerIndex();</span><br /><span class="line">                <span class="comment">// 解码</span></span><br /><span class="line">                <span class="keyword">try</span> {</span><br /><span class="line">                    msg = codec.decode(channel, message);</span><br /><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br /><span class="line">                    <span class="keyword">throw</span> e;</span><br /><span class="line">                }</span><br /><span class="line">                <span class="comment">// 需要更多输入，即消息不完整，标记回原有读进度，并结束</span></span><br /><span class="line">                <span class="keyword">if</span> (msg == Codec2.DecodeResult.NEED_MORE_INPUT) {</span><br /><span class="line">                    message.readerIndex(saveReaderIndex);</span><br /><span class="line">                    <span class="keyword">break</span>;</span><br /><span class="line">                <span class="comment">// 解码到消息，添加到 `out`</span></span><br /><span class="line">                } <span class="keyword">else</span> {</span><br /><span class="line">                    <span class="comment">//is it possible to go here ? 芋艿：不可能，哈哈哈</span></span><br /><span class="line">                    <span class="keyword">if</span> (saveReaderIndex == message.readerIndex()) {</span><br /><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Decode without read data."</span>);</span><br /><span class="line">                    }</span><br /><span class="line">                    <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {</span><br /><span class="line">                        out.add(msg);</span><br /><span class="line">                    }</span><br /><span class="line">                }</span><br /><span class="line">            } <span class="keyword">while</span> (message.readable());</span><br /><span class="line">        } <span class="keyword">finally</span> {</span><br /><span class="line">            <span class="comment">// 移除 NettyChannel 对象，若断开连接</span></span><br /><span class="line">            NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>io.netty.handler.codec.ByteToMessageDecoder</code>&nbsp;，Netty4 解码器<strong>抽象类</strong>。</li>
<li>🙂 代码比较简单，胖友自己看注释。</li>
</ul>
<h1 id="8-日志工厂">8. 日志工厂</h1>
<p>在&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/logger-strategy.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 日志适配》</a>&nbsp;文档，提到：</p>
<blockquote>
<p>自&nbsp;<code>2.2.1</code>&nbsp;开始，dubbo 开始内置 log4j、slf4j、jcl、jdk 这些日志框架的适配。</p>
</blockquote>
<p>在&nbsp;<a href="https://www.kancloud.cn/ssj234/netty-source/433218" target="_blank" rel="external nofollow noopener noreferrer">《Netty源码笔记 &mdash;&mdash; Netty日志处理》</a>&nbsp;文档，我们可以看到 Netty 支持实现自定义的<strong>日志工厂</strong>。通过这样的方式，我们可以接入 Dubbo 的<strong>日志适配</strong>。</p>
<p>下面，我们来看看具体的代码实现。</p>
<p>调用&nbsp;<code>NettyHelper#setNettyLoggerFactory()</code>&nbsp;方法，设置日志工厂，基于 Dubbo Logger 组件。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setNettyLoggerFactory</span><span class="params">()</span> </span>{</span><br /><span class="line">    InternalLoggerFactory factory = InternalLoggerFactory.getDefaultFactory();</span><br /><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span> || !(factory <span class="keyword">instanceof</span> DubboLoggerFactory)) {</span><br /><span class="line">        InternalLoggerFactory.setDefaultFactory(<span class="keyword">new</span> DubboLoggerFactory());</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>设置 Netty 日志工厂为 DubboLoggerFactory 。</li>
</ul>
<hr />
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/com/alibaba/dubbo/remoting/transport/netty4/logging/NettyHelper.java#L27-L32" target="_blank" rel="external nofollow noopener noreferrer">DubboLoggerFactory</a>&nbsp;，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboLoggerFactory</span> <span class="keyword">extends</span> <span class="title">InternalLoggerFactory</span> </span>{</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> InternalLogger <span class="title">newInstance</span><span class="params">(String name)</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DubboLogger(LoggerFactory.getLogger(name));</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>创建 DubboLogger 对象，并传入&nbsp;<code>name</code>&nbsp;对应的 Dubbo&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-common/src/main/java/com/alibaba/dubbo/common/logger/Logger.java" target="_blank" rel="external nofollow noopener noreferrer">Logger</a>&nbsp;对象，而 Dubbo Logger 的对象，基于 Dubbo SPI 机制加载。</li>
</ul>
<hr />
<p><a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/com/alibaba/dubbo/remoting/transport/netty4/logging/NettyHelper.java#L42-L236" target="_blank" rel="external nofollow noopener noreferrer">DubboLogger</a>&nbsp;，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboLogger</span> <span class="keyword">extends</span> <span class="title">AbstractInternalLogger</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 日志组件</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> com.alibaba.dubbo.common.logger.Logger logger;</span><br /><br /><span class="line">    DubboLogger(Logger logger) {</span><br /><span class="line">        <span class="keyword">super</span>(logger.getClass().getName());</span><br /><span class="line">        <span class="keyword">this</span>.logger = logger;</span><br /><span class="line">    }</span><br />    <br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String msg)</span> </span>{</span><br /><span class="line">        <span class="keyword">if</span> (isInfoEnabled()) {</span><br /><span class="line">            logger.info(msg);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br />    <br /><span class="line">    <span class="comment">// ... 省略类似代码</span></span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>在实现的每个方法中，直接调用&nbsp;<code>logger</code>&nbsp;对应的方法。</li>
<li>
<p>在类似&nbsp;<code>#info(String format, Object... arguments)</code>&nbsp;方法中，需要对日志内容进行格式化，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object... arguments)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (isInfoEnabled()) {</span><br /><span class="line">        FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments);</span><br /><span class="line">        logger.info(ft.getMessage(), ft.getThrowable());</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>我们看到需要&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/com/alibaba/dubbo/remoting/transport/netty4/logging/MessageFormatter.java" target="_blank" rel="external nofollow noopener noreferrer">FormattingTuple</a>&nbsp;和&nbsp;<a href="https://github.com/YunaiV/dubbo/blob/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/com/alibaba/dubbo/remoting/transport/netty4/logging/MessageFormatter.java" target="_blank" rel="external nofollow noopener noreferrer">MessageFormatter</a>&nbsp;这两个类，用于格式化。实际上，这两个类是直接从 Netty4 中拷贝出来的两个类，因为它们是&nbsp;<code>package</code>&nbsp;修饰的类，在 DubboLogger 中，无法访问到它们，所以进行复制解决。</li>
</ul>
</li>
</ul>
</div>