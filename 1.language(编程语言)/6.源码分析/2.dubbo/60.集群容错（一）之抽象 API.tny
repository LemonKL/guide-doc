<header class="article-header">
<h1 class="article-title">集群容错（一）之抽象 API</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>从本文开始，我们来分享 Dubbo 的<strong>集群容错</strong>功能的实现。</p>
<p>在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/intro/?self">《精尽 Dubbo 源码分析 &mdash;&mdash; 项目结构一览》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/">「3.4 dubbo-cluster」</a>&nbsp;中，我们对 Dubbo 的&nbsp;<code>dubbo-cluster</code>&nbsp;项目，做了整体的代码结构做了介绍。如果已经没什么印象的胖友，请先回过头找回失散的记忆。</p>
<p>Dubbo 对集群容错功能，实现了很好的&nbsp;<code>package</code>&nbsp;拆分，因此我们按照如下顺序：</p>
<ol>
<li>抽象 API</li>
</ol>
<ul>
<li>Cluster 实现</li>
<li>Directory 实现</li>
<li>LoadBalance 实现</li>
<li>Merger 实现</li>
<li>Router 实现</li>
<li>Configurator 实现</li>
</ul>
<p><strong>一个主题，对应一篇文章</strong>。那么，本文当然是分享<strong>抽象 API</strong>。考虑到干巴巴的看抽象 API 会很容易一脸懵逼，所以我们会使用&nbsp;<strong>FailoverCluster</strong>&nbsp;贯穿本文。</p>
<h1 id="2-整体流程">2. 整体流程</h1>
<blockquote>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2018_01_04/09.png" alt="集群容错" /></p>
</blockquote>
<ul>
<li>🙂 只看红线。</li>
<li><strong>左边 invoke</strong>&nbsp;：通过 Cluster 暴露&nbsp;<strong>Invoker</strong>&nbsp;对象，从而实现<strong>统一</strong>、<strong>透明</strong>的调用过程。
<ul>
<li>无法理解？详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/">「3. Cluster」</a>&nbsp;。</li>
</ul>
</li>
<li><strong>右边 list</strong>&nbsp;：通过 Directory 中，<strong>获取</strong>可调用的 Invoker 集合。</li>
<li><strong>右边 route</strong>&nbsp;：通过 Router ，<strong>过滤</strong>符合<strong>路由规则</strong>的 Invoker 集合。</li>
<li><strong>右边 select</strong>&nbsp;：通过 LoadBalance ，根据<strong>负载均衡机制</strong>，<strong>选择</strong>一个符合的 Invoker 对象。</li>
<li><strong>右边 invoke</strong>&nbsp;：调用该 Invoker 对象。</li>
</ul>
<h1 id="3-Cluster">3. Cluster</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.Cluster</code>&nbsp;，集群接口。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@SPI</span>(FailoverCluster.NAME)</span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cluster</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Merge the directory invokers to a virtual invoker.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 基于 Directory ，创建 Invoker 对象，实现统一、透明的 Invoker 调用过程</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory Directory 对象</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;  泛型</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> cluster invoker</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="meta">@Adaptive</span></span><br /><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>@SPI(FailoverCluster.NAME)</code>&nbsp;注解，Dubbo SPI&nbsp;<strong>拓展点</strong>，默认为&nbsp;<code>"failover"</code>&nbsp;，即<strong>失败重试</strong>，也就是会贯穿本文的 FailoverCluster 类。</li>
<li><code>@Adaptive</code>&nbsp;注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Cluster 实现，使用&nbsp;<code>URL.cluster</code>&nbsp;属性。</li>
<li><code>#join(Directory&lt;T&gt;)</code>&nbsp;接口方法，基于 Directory ，创建 Invoker 对象，实现统一、透明的 Invoker 调用过程。</li>
</ul>
<h2 id="3-1-join-方法">3.1 join 方法</h2>
<p>在 RegistryProtocol 的&nbsp;<code>#doRefer(Cluster, Registry, type, url)</code>&nbsp;方法中，会调用&nbsp;<code>Cluster#join(directory)</code>&nbsp;方法，创建 Invoker 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> Cluster cluster; <span class="comment">// &lt;1&gt;</span></span><br /><br /><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>{</span><br /><span class="line">    <span class="comment">// 创建 RegistryDirectory 对象，并设置注册中心 &lt;2&gt;</span></span><br /><span class="line">    RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br /><span class="line">    directory.setRegistry(registry);</span><br /><span class="line">    directory.setProtocol(protocol);</span><br />    <br /><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br /><br /><span class="line">    <span class="comment">// 创建 Invoker 对象 &lt;3&gt;</span></span><br /><span class="line">    Invoker invoker = cluster.join(directory);</span><br /><span class="line">    <span class="comment">// 向本地注册表，注册消费者</span></span><br /><span class="line">    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br /><span class="line">    <span class="keyword">return</span> invoker;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>&lt;1&gt;</code>&nbsp;：<code>cluster</code>&nbsp;属性，<code>Cluster$Adaptive</code>&nbsp;对象</li>
<li><code>&lt;2&gt;</code>&nbsp;：创建 RegistryDirectory 对象。通过它，可以注册到<strong>一个</strong>注册中心的所有服务<strong>提供者</strong>，即上文提到的【右边 list】。</li>
<li><code>&lt;3&gt;</code>&nbsp;：调用&nbsp;<code>Cluster#join(directory)</code>&nbsp;方法，创建 Invoker 对象。因为&nbsp;<code>cluster</code>&nbsp;是 Dubbo SPI Adaptive 类，所以可以自动获取到<strong>对应的</strong>&nbsp;Cluster 实现类。</li>
</ul>
<h2 id="3-2-子类">3.2 子类</h2>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_04_01/01.png" alt="Cluster 子类" /></p>
<p>我们可以看到，每个 Cluster 实现类，对应一个<strong>专属</strong>于其的 Invoker 实现类。本文分享的 FailoverCluster 的对应的 Invoker 为 FailoverClusterInvoker 。在看具体的代码之前，先一起来看看<strong>集群容错的调用( invoke )过程</strong>。</p>
<h1 id="4-调用顺序图">4. 调用顺序图</h1>
<p>如下是服务<strong>消费者</strong>的调用顺序图：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_04_01/02.png" alt="顺序图" /></p>
<ul>
<li>在 InvokerInvocationHandler 的 【4】<code>#invoke(invocation)</code>&nbsp;处<strong>插入</strong>：<strong>先</strong>调用<strong>集群容错 Invoker</strong>&nbsp;的&nbsp;<code>#invoke(invocation)</code>&nbsp;，<strong>再</strong>调用&nbsp;<code>ProtocolFilterWrapper$Invoker</code>&nbsp;的&nbsp;<code>#invoke(invocation)</code>&nbsp;。</li>
<li><strong>调用栈</strong>如下图：<img src="http://static2.iocoder.cn/images/Dubbo/2019_04_01/03.png" alt="调用栈" />
<ul>
<li>MockClusterInvoker ，胖友先无视，后续有详细文章，进行分享。</li>
</ul>
</li>
</ul>
<h1 id="5-FailoverCluster">5. FailoverCluster</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.support.FailoverCluster</code>&nbsp;，实现 Cluster 接口，失败自动切换，当出现失败，重试其它服务器。通常用于<strong>读操作</strong>，但重试会带来更长延迟。可通过&nbsp;<code>retries="2"</code>&nbsp;来设置重试次数(不含第一次)。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failover"</span>;</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailoverClusterInvoker&lt;T&gt;(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>对应 Invoker 为 FailoverClusterInvoker 。</li>
</ul>
<h1 id="6-AbstractClusterInvoker">6. AbstractClusterInvoker</h1>
<p>因为，FailoverClusterInvoker 继承 AbstractClusterInvoker ，所以我们来分享它。</p>
<p><code>com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker</code>&nbsp;，实现 Invoker 接口，Cluster Invoker 抽象类：</p>
<ul>
<li><strong>实现</strong>例如选择一个符合 Invoker 对象等等<strong>公用</strong>方法</li>
<li>
<p><strong>定义</strong>&nbsp;<code>#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)</code>&nbsp;<strong>抽象</strong>方法，实现子 Cluster 的 Invoker 实现类的<strong>服务调用</strong>的差异逻辑，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException</span>;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
</ul>
<h2 id="6-1-构造方法">6.1 构造方法</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Directory 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Directory&lt;T&gt; directory;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 集群时是否排除非可用( available )的 Invoker ，默认为 true</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> availablecheck;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否已经销毁</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 粘滞连接 Invoker</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * http://dubbo.apache.org/zh-cn/docs/user/demos/stickiness.html</span></span><br /><span class="line"><span class="comment"> * 粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。</span></span><br /><span class="line"><span class="comment"> * 粘滞连接将自动开启延迟连接，以减少长连接数。</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Invoker&lt;T&gt; stickyInvoker = <span class="keyword">null</span>;</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>(directory, directory.getUrl());</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory, URL url)</span> </span>{</span><br /><span class="line">    <span class="comment">// 初始化 directory</span></span><br /><span class="line">    <span class="keyword">if</span> (directory == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service directory == null"</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">this</span>.directory = directory;</span><br /><span class="line">    <span class="comment">// sticky: invoker.isAvailable() should always be checked before using when availablecheck is true.</span></span><br /><span class="line">    <span class="comment">// 初始化 availablecheck</span></span><br /><span class="line">    <span class="keyword">this</span>.availablecheck = url.getParameter(Constants.CLUSTER_AVAILABLE_CHECK_KEY, Constants.DEFAULT_CLUSTER_AVAILABLE_CHECK);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>directory</code>&nbsp;字段，Directory 对象。通过它，可以获得所有服务提供者的 Invoker 对象。</li>
<li><code>availablecheck</code>&nbsp;字段，集群时是否排除非可用( available )的 Invoker ，默认为&nbsp;<code>"true"</code>&nbsp;，通过&nbsp;<code>"cluster.availablecheck"</code>&nbsp;配置项设置。</li>
<li><code>destroyed</code>&nbsp;字段，是否已经销毁。若已经销毁，则不允许在调用。</li>
<li>
<p><code>stickyInvoker</code>&nbsp;字段，粘滞连接 Invoker ，参见&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/stickiness.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 粘滞连接<br />》</a>&nbsp;文档。</p>
<blockquote>
<p>粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。</p>
</blockquote>
</li>
</ul>
<h2 id="6-2-list">6.2 list</h2>
<p><code>#list(Invocation)</code>&nbsp;方法，获得所有服务提供者 Invoker 集合。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException {</span><br /><span class="line">    <span class="keyword">return</span> directory.list(invocation);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="6-3-select">6.3 select</h2>
<p><code>#select(LoadBalance, Invocation, invokers, selected)</code>&nbsp;方法，从<strong>候选</strong>的 Invoker 集合，选择一个<strong>最终调用</strong>的 Invoker 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 使用 loadbalance 选择 invoker.</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadbalance Loadbalance 对象，提供负责均衡策略</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> invocation Invocation 对象</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> invokers   候选的 Invoker 集合</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@param</span> selected    已选过的 Invoker 集合. 注意：输入保证不重复</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最终的 Invoker 对象</span></span><br /><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RpcException 当发生 RpcException 时</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">  <span class="number">2</span>:     <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty()) {</span><br /><span class="line">  <span class="number">3</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">  <span class="number">4</span>:     }</span><br /><span class="line">  <span class="number">5</span>:     <span class="comment">// 获得 sticky 配置项，方法级</span></span><br /><span class="line">  <span class="number">6</span>:     String methodName = invocation == <span class="keyword">null</span> ? <span class="string">""</span> : invocation.getMethodName();</span><br /><span class="line">  <span class="number">7</span>:     <span class="keyword">boolean</span> sticky = invokers.get(<span class="number">0</span>).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY);</span><br /><span class="line">  <span class="number">8</span>:     {</span><br /><span class="line">  <span class="number">9</span>:         <span class="comment">// ignore overloaded method</span></span><br /><span class="line"> <span class="number">10</span>:         <span class="comment">// 若 stickyInvoker 不存在于 invokers 中，说明不在候选中，需要置空，重新选择</span></span><br /><span class="line"> <span class="number">11</span>:         <span class="keyword">if</span> (stickyInvoker != <span class="keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) {</span><br /><span class="line"> <span class="number">12</span>:             stickyInvoker = <span class="keyword">null</span>;</span><br /><span class="line"> <span class="number">13</span>:         }</span><br /><span class="line"> <span class="number">14</span>:         <span class="comment">// ignore cucurrent problem</span></span><br /><span class="line"> <span class="number">15</span>:         <span class="comment">// 若开启粘滞连接的特性，且 stickyInvoker 不存在于 selected 中，则返回 stickyInvoker 这个 Invoker 对象</span></span><br /><span class="line"> <span class="number">16</span>:         <span class="keyword">if</span> (sticky &amp;&amp; stickyInvoker != <span class="keyword">null</span> &amp;&amp; (selected == <span class="keyword">null</span> || !selected.contains(stickyInvoker))) {</span><br /><span class="line"> <span class="number">17</span>:             <span class="comment">// 若开启排除非可用的 Invoker 的特性，则校验 stickyInvoker 是否可用。若可用，则进行返回</span></span><br /><span class="line"> <span class="number">18</span>:             <span class="keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) {</span><br /><span class="line"> <span class="number">19</span>:                 <span class="keyword">return</span> stickyInvoker;</span><br /><span class="line"> <span class="number">20</span>:             }</span><br /><span class="line"> <span class="number">21</span>:         }</span><br /><span class="line"> <span class="number">22</span>:     }</span><br /><span class="line"> <span class="number">23</span>: </span><br /><span class="line"> <span class="number">24</span>:     <span class="comment">// 执行选择</span></span><br /><span class="line"> <span class="number">25</span>:     Invoker&lt;T&gt; invoker = doselect(loadbalance, invocation, invokers, selected);</span><br /><span class="line"> <span class="number">26</span>: </span><br /><span class="line"> <span class="number">27</span>:     <span class="comment">// 若开启粘滞连接的特性，记录最终选择的 Invoker 到 stickyInvoker</span></span><br /><span class="line"> <span class="number">28</span>:     <span class="keyword">if</span> (sticky) {</span><br /><span class="line"> <span class="number">29</span>:         stickyInvoker = invoker;</span><br /><span class="line"> <span class="number">30</span>:     }</span><br /><span class="line"> <span class="number">31</span>:     <span class="keyword">return</span> invoker;</span><br /><span class="line"> <span class="number">32</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>该方法主要处理<strong>粘滞连接</strong>的特性，具体使用 Loadbalance 选择 Invoker 对象的逻辑，在&nbsp;<code>#doselect(loadbalance, invocation, invokers, selected)</code>&nbsp;方法中。</li>
<li>第 5 至 22 行：获得<strong>粘滞连接</strong>&nbsp;<code>stickyInvoker</code>&nbsp;对象。
<ul>
<li>第 6 至 7 行：获得方法级的&nbsp;<code>sticky</code>&nbsp;配置项。</li>
<li>第 9 至 13 行：若&nbsp;<code>stickyInvoker</code>&nbsp;不存在于&nbsp;<code>invokers</code>&nbsp;中，说明不在候选中，需要置空，重新选择。</li>
<li>第 14 至 21 行：获得<strong>粘滞连接</strong>&nbsp;<code>stickyInvoker</code>&nbsp;对象。如要满足如下<strong>条件</strong>：
<ul>
<li>第 16 行：1）开启粘滞连接的特性；2）<code>stickyInvoker</code>&nbsp;不存在于&nbsp;<code>selected</code>&nbsp;中。</li>
<li>第 18 行：若开启<strong>排除非可用</strong>的 Invoker 的特性，则校验&nbsp;<code>stickyInvoker</code>&nbsp;是否可用。</li>
</ul>
</li>
</ul>
</li>
<li>第 25 行：调用&nbsp;<code>#doselect(loadbalance, invocation, invokers, selected)</code>&nbsp;方法，执行选择一个 Invoker 对象。</li>
<li>第 27 至 30 行：若开启<strong>粘滞连接</strong>的特性，记录最终选择的 Invoker 对象，到&nbsp;<code>stickyInvoker</code>&nbsp;中。</li>
</ul>
<h3 id="6-3-1-doselect">6.3.1 doselect</h3>
<p><code>#doselect(loadbalance, invocation, invokers, selected)</code>&nbsp;方法，从<strong>候选</strong>的 Invoker 集合，选择一个<strong>最终调用</strong>的 Invoker 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">doselect</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty()) {</span><br /><span class="line"> <span class="number">3</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line"> <span class="number">4</span>:     }</span><br /><span class="line"> <span class="number">5</span>:     <span class="comment">// 【第一种】如果只有一个 Invoker ，直接选择</span></span><br /><span class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) {</span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br /><span class="line"> <span class="number">8</span>:     }</span><br /><span class="line"> <span class="number">9</span>:     <span class="comment">// 【第二种】如果只有两个 Invoker ，退化成轮循</span></span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// If we only have two invokers, use round-robin instead.</span></span><br /><span class="line"><span class="number">11</span>:     <span class="keyword">if</span> (invokers.size() == <span class="number">2</span> &amp;&amp; selected != <span class="keyword">null</span> &amp;&amp; !selected.isEmpty()) {</span><br /><span class="line"><span class="number">12</span>:         <span class="keyword">return</span> selected.get(<span class="number">0</span>) == invokers.get(<span class="number">0</span>) ? invokers.get(<span class="number">1</span>) : invokers.get(<span class="number">0</span>);</span><br /><span class="line"><span class="number">13</span>:     }</span><br /><span class="line"><span class="number">14</span>: </span><br /><span class="line"><span class="number">15</span>:     <span class="comment">// 【第三种】使用 Loadbalance ，选择一个 Invoker 对象。</span></span><br /><span class="line"><span class="number">16</span>:     Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation);</span><br /><span class="line"><span class="number">17</span>: </span><br /><span class="line"><span class="number">18</span>:     <span class="comment">// If the `invoker` is in the  `selected` or invoker is unavailable &amp;&amp; availablecheck is true, reselect.</span></span><br /><span class="line"><span class="number">19</span>:     <span class="comment">// 如果 selected中包含（优先判断） 或者 不可用&amp;&amp;availablecheck=true 则重试.</span></span><br /><span class="line"><span class="number">20</span>:     <span class="keyword">if</span> ((selected != <span class="keyword">null</span> &amp;&amp; selected.contains(invoker))</span><br /><span class="line"><span class="number">21</span>:             || (!invoker.isAvailable() &amp;&amp; getUrl() != <span class="keyword">null</span> &amp;&amp; availablecheck)) {</span><br /><span class="line"><span class="number">22</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">23</span>:             <span class="comment">//【第四种】重选一个 Invoker 对象</span></span><br /><span class="line"><span class="number">24</span>:             Invoker&lt;T&gt; rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);</span><br /><span class="line"><span class="number">25</span>:             <span class="keyword">if</span> (rinvoker != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">26</span>:                 invoker = rinvoker;</span><br /><span class="line"><span class="number">27</span>:             } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">28</span>:                 <span class="comment">// Check the index of current selected invoker, if it's not the last one, choose the one at index+1.</span></span><br /><span class="line"><span class="number">29</span>:                 <span class="comment">// 【第五种】看下第一次选的位置，如果不是最后，选+1位置.</span></span><br /><span class="line"><span class="number">30</span>:                 <span class="keyword">int</span> index = invokers.indexOf(invoker);</span><br /><span class="line"><span class="number">31</span>:                 <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">32</span>:                     <span class="comment">// Avoid collision</span></span><br /><span class="line"><span class="number">33</span>:                     <span class="comment">// 最后在避免碰撞</span></span><br /><span class="line"><span class="number">34</span>:                     invoker = index &lt; invokers.size() - <span class="number">1</span> ? invokers.get(index + <span class="number">1</span>) : invoker;</span><br /><span class="line"><span class="number">35</span>:                 } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line"><span class="number">36</span>:                     logger.warn(e.getMessage() + <span class="string">" may because invokers list dynamic change, ignore."</span>, e);</span><br /><span class="line"><span class="number">37</span>:                 }</span><br /><span class="line"><span class="number">38</span>:             }</span><br /><span class="line"><span class="number">39</span>:         } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">40</span>:             logger.error(<span class="string">"clustor relselect fail reason is :"</span> + t.getMessage() + <span class="string">" if can not slove ,you can set cluster.availablecheck=false in url"</span>, t);</span><br /><span class="line"><span class="number">41</span>:         }</span><br /><span class="line"><span class="number">42</span>:     }</span><br /><span class="line"><span class="number">43</span>:     <span class="keyword">return</span> invoker;</span><br /><span class="line"><span class="number">44</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>有<strong>五种</strong>选择最终调用的 Invoker 对象的方式。</li>
<li>【第一种】第 5 至 8 行：如果只有<strong>一个候选</strong>的 Invoker 对象，直接选择返回。😈 因为没的选择了。</li>
<li>
<p>【第二种】第 9 至 13 行：如果只有<strong>两个候选</strong>的 Invoker 集合，退化为轮询。此处存在一个 BUG ：</p>
<blockquote>
<p>转载自我<strong>飞哥</strong>，<a href="https://www.jianshu.com/p/10c30d7b8b6a" target="_blank" rel="external nofollow noopener noreferrer">《dubbo 源码 - 负载均衡》</a></p>
<p>这里退化成轮询的实现有问题，对应源码<code>return selected.get(0) == invokers.get(0) ? invokers.get(1) : invokers.get(0)；</code>如果retries=4，即最多调用5次，且两个可选invoke分别为：</p>
<p>10.0.0.1:20884，10.0.0.1:20886；</p>
<p>那么5次选择的invoke为：</p>
<ul>
<li>10.0.0.1:20884</li>
<li>10.0.0.1:20886</li>
<li>10.0.0.1:20886</li>
<li>10.0.0.1:20886</li>
<li>10.0.0.1:20886，</li>
</ul>
<p>即除了第1次外后面的选择都是选择<strong>第二个</strong>invoker;</p>
<p>因次需要把selected.get(0)修改为：selected.get(selected.size()-1)；</p>
<p>即每次拿前一次选择的invoker与 invokers.get(0)比较，如果相同，则选则另一个invoker；否则就选 invokers.get(0)；</p>
</blockquote>
<ul>
<li>比较有趣的是，<a href="https://github.com/apache/incubator-dubbo/issues/934" target="_blank" rel="external nofollow noopener noreferrer">ISSUE#934：Extension of LoadBalance (a small suggestion for loadbalance policy when there&rsquo;s less than 2 providers)&nbsp;</a>。和上述 BUG 无关，胖友自己理解下。</li>
</ul>
</li>
<li>
<p>【第三种】第 16 至 21 行：调用&nbsp;<code>Loadbalance#select(invokers, url, invocation)</code>&nbsp;方法，使用 Loadbalance ，选择一个 Invoker 对象。具体的代码实现，见 Loadbalance 的文章。</p>
<ul>
<li>这种方式的返回，选择的 Invoker 对象，需要满足<strong>两个</strong>条件：1）不存在于&nbsp;<code>selected</code>&nbsp;中。2）Invoker 是可用的，若开启排除非可用的 Invoker 的特性。</li>
</ul>
</li>
<li>【第四种】调用&nbsp;<code>#reselect(loadbalance, invocation, invokers, selected, availablecheck)</code>&nbsp;方法，重新选择一个 Invoker 对象。😈 因为此时&nbsp;<code>invokers</code>&nbsp;中，无法找到一个满足条件的 Invoker 对象。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/">「6.3.2 reselect」</a>&nbsp;。</li>
<li>【第五种】<strong>顺序</strong>从候选的&nbsp;<code>invokers</code>&nbsp;集合中，选择一个 Invoker 对象，不考虑是否<strong>可用</strong>，又或者<strong>已经选择过</strong>，类似【第一种】【第二种】的方式。😈总之，保证能获取到一个 Invoker 对象。</li>
</ul>
<h3 id="6-3-2-reselect">6.3.2 reselect</h3>
<p><code>#reselect(loadbalance, invocation, invokers, selected, availablecheck)</code>&nbsp;方法，重新选择一个 Invoker 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">reselect</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected, <span class="keyword">boolean</span> availablecheck)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="comment">// Allocating one in advance, this list is certain to be used.</span></span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 预先分配一个，这个列表是一定会用到的.</span></span><br /><span class="line"> <span class="number">4</span>:     List&lt;Invoker&lt;T&gt;&gt; reselectInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(invokers.size() &gt; <span class="number">1</span> ? (invokers.size() - <span class="number">1</span>) : invokers.size());</span><br /><span class="line"> <span class="number">5</span>: </span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// First, try picking a invoker not in `selected`.</span></span><br /><span class="line"> <span class="number">7</span>:     <span class="comment">// 先从非select中选</span></span><br /><span class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (availablecheck) { <span class="comment">// invoker.isAvailable() should be checked</span></span><br /><span class="line"> <span class="number">9</span>:         <span class="comment">// 获得非选择过，并且可用的 Invoker 集合</span></span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) {</span><br /><span class="line"><span class="number">11</span>:             <span class="keyword">if</span> (invoker.isAvailable()) { <span class="comment">// 并且可用</span></span><br /><span class="line"><span class="number">12</span>:                 <span class="keyword">if</span> (selected == <span class="keyword">null</span> || !selected.contains(invoker)) {</span><br /><span class="line"><span class="number">13</span>:                     reselectInvokers.add(invoker);</span><br /><span class="line"><span class="number">14</span>:                 }</span><br /><span class="line"><span class="number">15</span>:             }</span><br /><span class="line"><span class="number">16</span>:         }</span><br /><span class="line"><span class="number">17</span>:         <span class="comment">// 使用 Loadbalance ，选择一个 Invoker 对象。</span></span><br /><span class="line"><span class="number">18</span>:         <span class="keyword">if</span> (!reselectInvokers.isEmpty()) {</span><br /><span class="line"><span class="number">19</span>:             <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br /><span class="line"><span class="number">20</span>:         }</span><br /><span class="line"><span class="number">21</span>:     } <span class="keyword">else</span> { <span class="comment">// do not check invoker.isAvailable()</span></span><br /><span class="line"><span class="number">22</span>:         <span class="comment">// 获得非选择过的 Invoker 集合</span></span><br /><span class="line"><span class="number">23</span>:         <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) {</span><br /><span class="line"><span class="number">24</span>:             <span class="keyword">if</span> (selected == <span class="keyword">null</span> || !selected.contains(invoker)) {</span><br /><span class="line"><span class="number">25</span>:                 reselectInvokers.add(invoker);</span><br /><span class="line"><span class="number">26</span>:             }</span><br /><span class="line"><span class="number">27</span>:         }</span><br /><span class="line"><span class="number">28</span>:         <span class="comment">// 使用 Loadbalance ，选择一个 Invoker 对象。</span></span><br /><span class="line"><span class="number">29</span>:         <span class="keyword">if</span> (!reselectInvokers.isEmpty()) {</span><br /><span class="line"><span class="number">30</span>:             <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br /><span class="line"><span class="number">31</span>:         }</span><br /><span class="line"><span class="number">32</span>:     }</span><br /><span class="line"><span class="number">33</span>:     <span class="comment">// Just pick an available invoker using loadbalance policy</span></span><br /><span class="line"><span class="number">34</span>:     <span class="comment">// 最后从select中选可用的.</span></span><br /><span class="line"><span class="number">35</span>:     {</span><br /><span class="line"><span class="number">36</span>:         <span class="comment">// 获得选择过的，并且可用的 Invoker 集合</span></span><br /><span class="line"><span class="number">37</span>:         <span class="keyword">if</span> (selected != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">38</span>:             <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : selected) {</span><br /><span class="line"><span class="number">39</span>:                 <span class="keyword">if</span> ((invoker.isAvailable()) <span class="comment">// available first</span></span><br /><span class="line"><span class="number">40</span>:                         &amp;&amp; !reselectInvokers.contains(invoker)) {</span><br /><span class="line"><span class="number">41</span>:                     reselectInvokers.add(invoker);</span><br /><span class="line"><span class="number">42</span>:                 }</span><br /><span class="line"><span class="number">43</span>:             }</span><br /><span class="line"><span class="number">44</span>:         }</span><br /><span class="line"><span class="number">45</span>:         <span class="comment">// 使用 Loadbalance ，选择一个 Invoker 对象。</span></span><br /><span class="line"><span class="number">46</span>:         <span class="keyword">if</span> (!reselectInvokers.isEmpty()) {</span><br /><span class="line"><span class="number">47</span>:             <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br /><span class="line"><span class="number">48</span>:         }</span><br /><span class="line"><span class="number">49</span>:     }</span><br /><span class="line"><span class="number">50</span>:     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line"><span class="number">51</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 4 行：预先创建一个重选 Invoker 集合，我们会发现很奇怪的一段&nbsp;<code>invokers.size() - 1</code>&nbsp;代码。这是为什么呢？笔者的理解是，出现重选&nbsp;<code>#reselect(...)</code>&nbsp;的原因，说明&nbsp;<code>#doselect(...)</code>&nbsp;的【第三种】选择的 Invoker 对象，在&nbsp;<code>selected</code>&nbsp;中，因此需要<strong>去掉一个</strong>。</li>
<li>一共有<strong>两类三种</strong>的选择方式：
<ul>
<li>【第一种】第 10 至 16 行：获得<strong>非选择过</strong>(&nbsp;<code>invokers</code>&nbsp;)， 并且<strong>必须</strong>可用的 Invoker 集合。</li>
<li>【第二种】第 22 至 27 行：获得<strong>非选择过</strong>(&nbsp;<code>invokers</code>&nbsp;)， 并且<strong>不考虑</strong>可用的 Invoker 集合。</li>
<li>【第三种】第 36 至 44 行：获得<strong>选择过</strong>(&nbsp;<code>selected</code>&nbsp;)，并且<strong>必须</strong>可用的 Invoker 集合。</li>
</ul>
</li>
<li>第 19 行 || 第 30 行 || 第 47 行：调用&nbsp;<code>Loadbalance#select(invokers, url, invocation)</code>&nbsp;方法，使用 Loadbalance ，选择一个 Invoker 对象。</li>
</ul>
<h2 id="6-4-invoke">6.4 invoke</h2>
<p><code>#invoke(invocation)</code>&nbsp;方法，调用服务<strong>提供者</strong>的逻辑。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 校验是否销毁</span></span><br /><span class="line"> <span class="number">4</span>:     checkWhetherDestroyed();</span><br /><span class="line"> <span class="number">5</span>: </span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// 获得所有服务提供者 Invoker 集合</span></span><br /><span class="line"> <span class="number">7</span>:     List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br /><span class="line"> <span class="number">8</span>: </span><br /><span class="line"> <span class="number">9</span>:     <span class="comment">// 获得 LoadBalance 对象</span></span><br /><span class="line"><span class="number">10</span>:     LoadBalance loadbalance;</span><br /><span class="line"><span class="number">11</span>:     <span class="keyword">if</span> (invokers != <span class="keyword">null</span> &amp;&amp; !invokers.isEmpty()) {</span><br /><span class="line"><span class="number">12</span>:         loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(<span class="number">0</span>).getUrl()</span><br /><span class="line"><span class="number">13</span>:                 .getMethodParameter(invocation.getMethodName(), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));</span><br /><span class="line"><span class="number">14</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">15</span>:         loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);</span><br /><span class="line"><span class="number">16</span>:     }</span><br /><span class="line"><span class="number">17</span>: </span><br /><span class="line"><span class="number">18</span>:     <span class="comment">// 设置调用编号，若是异步调用</span></span><br /><span class="line"><span class="number">19</span>:     RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br /><span class="line"><span class="number">20</span>: </span><br /><span class="line"><span class="number">21</span>:     <span class="comment">// 执行调用</span></span><br /><span class="line"><span class="number">22</span>:     <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br /><span class="line"><span class="number">23</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>第 4 行：调用&nbsp;<code>#checkWhetherDestroyed()</code>&nbsp;方法，<strong>校验</strong>是否已经销毁。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkWhetherDestroyed</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (destroyed.get()) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Rpc cluster invoker for "</span> + getInterface() + <span class="string">" on consumer "</span> + NetUtils.getLocalHost()</span><br /><span class="line">                + <span class="string">" use dubbo version "</span> + Version.getVersion()</span><br /><span class="line">                + <span class="string">" is now destroyed! Can not invoke any more."</span>);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>第 7 行：调用&nbsp;<code>#list(invocation)</code>&nbsp;方法，基于 Directory ，获得所有服务提供者 Invoker 集合。</p>
</li>
<li>第 9 至 16 行：获得 Loadbalance 对象。</li>
<li>第 19 行：调用&nbsp;<code>RpcUtils#attachInvocationIdIfAsync(url, invocation)</code>&nbsp;方法，设置<strong>调用编号</strong>，若是异步调用。</li>
<li>第 22 行：调用&nbsp;<code>#doInvoke(invocation, invokers, loadbalance)</code>&nbsp;<strong>抽象</strong>方法，执行调用。🙂 子 Cluster 的 Invoker 实现类的<strong>服务调用</strong>的差异逻辑。</li>
</ul>
<h2 id="6-5-其它实现方法">6.5 其它实现方法</h2>
<h3 id="6-5-1-getInterface">6.5.1 getInterface</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> directory.getInterface();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="6-5-2-getUrl">6.5.2 getUrl</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">return</span> directory.getUrl();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="6-5-3-isAvailable">6.5.3 isAvailable</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 如有粘滞连接 Invoker ，基于它判断。</span></span><br /><span class="line">    Invoker&lt;T&gt; invoker = stickyInvoker; <span class="comment">// 指向，避免并发</span></span><br /><span class="line">    <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">return</span> invoker.isAvailable();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 基于 Directory 判断</span></span><br /><span class="line">    <span class="keyword">return</span> directory.isAvailable();</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="6-5-4-checkInvokers">6.5.4 checkInvokers</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkInvokers</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty()) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke the method "</span></span><br /><span class="line">                + invocation.getMethodName() + <span class="string">" in the service "</span> + getInterface().getName()</span><br /><span class="line">                + <span class="string">". No provider available for the service "</span> + directory.getUrl().getServiceKey()</span><br /><span class="line">                + <span class="string">" from registry "</span> + directory.getUrl().getAddress()</span><br /><span class="line">                + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost()</span><br /><span class="line">                + <span class="string">" using the dubbo version "</span> + Version.getVersion()</span><br /><span class="line">                + <span class="string">". Please check if the providers have been started and registered."</span>);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="6-5-5-destroy">6.5.5 destroy</h3>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br /><span class="line">        directory.destroy();</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="7-FailoverClusterInvoker">7. FailoverClusterInvoker</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker</code>&nbsp;，实现 AbstractClusterInvoker 抽象类，<strong>FailoverCluster</strong>&nbsp;Invoker 实现类。</p>
<p>失败自动切换，当出现失败，重试其它服务器。通常用于<strong>读操作</strong>，但重试会带来更长延迟。可通过&nbsp;<code>retries="2"</code>&nbsp;来设置重试次数(不含第一次)。</p>
<p>在看具体的&nbsp;<code>#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)</code>&nbsp;的实现代码之前，我们先来瞅瞅<strong>调用顺序图</strong>：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_04_01/04.png" alt="调用顺序图" /></p>
<ul>
<li>实际逻辑很简单：<strong>循环</strong>，查找一个 Invoker 对象，进行调用，直到<strong>成功</strong>。</li>
</ul>
<p><code>#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)</code>&nbsp;方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line"> <span class="number">3</span>:     List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">// 检查copyinvokers即可用Invoker集合是否为空，如果为空，那么抛出异常</span></span><br /><span class="line"> <span class="number">5</span>:     checkInvokers(copyinvokers, invocation);</span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// 得到最大可调用次数：最大可重试次数+1，默认最大可重试次数Constants.DEFAULT_RETRIES=2</span></span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">int</span> len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class="number">1</span>;</span><br /><span class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">9</span>:         len = <span class="number">1</span>;</span><br /><span class="line"><span class="number">10</span>:     }</span><br /><span class="line"><span class="number">11</span>:     <span class="comment">// 保存最后一次调用的异常</span></span><br /><span class="line"><span class="number">12</span>:     RpcException le = <span class="keyword">null</span>;</span><br /><span class="line"><span class="number">13</span>:     <span class="comment">// 保存已经调用过的Invoker</span></span><br /><span class="line"><span class="number">14</span>:     List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); <span class="comment">// invoked invokers.</span></span><br /><span class="line"><span class="number">15</span>:     Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br /><span class="line"><span class="number">16</span>:     <span class="comment">// failover机制核心实现：如果出现调用失败，那么重试其他服务器</span></span><br /><span class="line"><span class="number">17</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br /><span class="line"><span class="number">18</span>:         <span class="comment">// 重试时，进行重新选择，避免重试时invoker列表已发生变化.</span></span><br /><span class="line"><span class="number">19</span>:         <span class="comment">// 注意：如果列表发生了变化，那么invoked判断会失效，因为invoker示例已经改变</span></span><br /><span class="line"><span class="number">20</span>:         <span class="keyword">if</span> (i &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">21</span>:             checkWhetherDestroyed();</span><br /><span class="line"><span class="number">22</span>:             <span class="comment">// 根据Invocation调用信息从Directory中获取所有可用Invoker</span></span><br /><span class="line"><span class="number">23</span>:             copyinvokers = list(invocation);</span><br /><span class="line"><span class="number">24</span>:             <span class="comment">// check again</span></span><br /><span class="line"><span class="number">25</span>:             <span class="comment">// 重新检查一下</span></span><br /><span class="line"><span class="number">26</span>:             checkInvokers(copyinvokers, invocation);</span><br /><span class="line"><span class="number">27</span>:         }</span><br /><span class="line"><span class="number">28</span>:         <span class="comment">// 根据负载均衡机制从copyinvokers中选择一个Invoker</span></span><br /><span class="line"><span class="number">29</span>:         Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br /><span class="line"><span class="number">30</span>:         <span class="comment">// 保存每次调用的Invoker</span></span><br /><span class="line"><span class="number">31</span>:         invoked.add(invoker);</span><br /><span class="line"><span class="number">32</span>:         <span class="comment">// 设置已经调用的 Invoker 集合，到 Context 中</span></span><br /><span class="line"><span class="number">33</span>:         RpcContext.getContext().setInvokers((List) invoked);</span><br /><span class="line"><span class="number">34</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">35</span>:             <span class="comment">// RPC 调用得到 Result</span></span><br /><span class="line"><span class="number">36</span>:             Result result = invoker.invoke(invocation);</span><br /><span class="line"><span class="number">37</span>:             <span class="comment">// 重试过程中，将最后一次调用的异常信息以 warn 级别日志输出</span></span><br /><span class="line"><span class="number">38</span>:             <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) {</span><br /><span class="line"><span class="number">39</span>:                 logger.warn(<span class="string">"Although retry the method "</span> + invocation.getMethodName()</span><br /><span class="line"><span class="number">40</span>:                         + <span class="string">" in the service "</span> + getInterface().getName()</span><br /><span class="line"><span class="number">41</span>:                         + <span class="string">" was successful by the provider "</span> + invoker.getUrl().getAddress()</span><br /><span class="line"><span class="number">42</span>:                         + <span class="string">", but there have been failed providers "</span> + providers</span><br /><span class="line"><span class="number">43</span>:                         + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyinvokers.size()</span><br /><span class="line"><span class="number">44</span>:                         + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br /><span class="line"><span class="number">45</span>:                         + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost()</span><br /><span class="line"><span class="number">46</span>:                         + <span class="string">" using the dubbo version "</span> + Version.getVersion() + <span class="string">". Last error is: "</span></span><br /><span class="line"><span class="number">47</span>:                         + le.getMessage(), le);</span><br /><span class="line"><span class="number">48</span>:             }</span><br /><span class="line"><span class="number">49</span>:             <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">50</span>:         } <span class="keyword">catch</span> (RpcException e) {</span><br /><span class="line"><span class="number">51</span>:             <span class="comment">// 如果是业务性质的异常，不再重试，直接抛出</span></span><br /><span class="line"><span class="number">52</span>:             <span class="keyword">if</span> (e.isBiz()) { <span class="comment">// biz exception.</span></span><br /><span class="line"><span class="number">53</span>:                 <span class="keyword">throw</span> e;</span><br /><span class="line"><span class="number">54</span>:             }</span><br /><span class="line"><span class="number">55</span>:             <span class="comment">// 其他性质的异常统一封装成RpcException</span></span><br /><span class="line"><span class="number">56</span>:             le = e;</span><br /><span class="line"><span class="number">57</span>:         } <span class="keyword">catch</span> (Throwable e) {</span><br /><span class="line"><span class="number">58</span>:             le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br /><span class="line"><span class="number">59</span>:         } <span class="keyword">finally</span> {</span><br /><span class="line"><span class="number">60</span>:             providers.add(invoker.getUrl().getAddress());</span><br /><span class="line"><span class="number">61</span>:         }</span><br /><span class="line"><span class="number">62</span>:     }</span><br /><span class="line"><span class="number">63</span>:     <span class="comment">// 最大可调用次数用完还得到Result的话，抛出RpcException异常：重试了N次还是失败，并输出最后一次异常信息</span></span><br /><span class="line"><span class="number">64</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(le != <span class="keyword">null</span> ? le.getCode() : <span class="number">0</span>, <span class="string">"Failed to invoke the method "</span></span><br /><span class="line"><span class="number">65</span>:             + invocation.getMethodName() + <span class="string">" in the service "</span> + getInterface().getName()</span><br /><span class="line"><span class="number">66</span>:             + <span class="string">". Tried "</span> + len + <span class="string">" times of the providers "</span> + providers</span><br /><span class="line"><span class="number">67</span>:             + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyinvokers.size()</span><br /><span class="line"><span class="number">68</span>:             + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br /><span class="line"><span class="number">69</span>:             + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" using the dubbo version "</span></span><br /><span class="line"><span class="number">70</span>:             + Version.getVersion() + <span class="string">". Last error is: "</span></span><br /><span class="line"><span class="number">71</span>:             + (le != <span class="keyword">null</span> ? le.getMessage() : <span class="string">""</span>), le != <span class="keyword">null</span> &amp;&amp; le.getCause() != <span class="keyword">null</span> ? le.getCause() : le);</span><br /><span class="line"><span class="number">72</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 行：<code>copyinvokers</code>&nbsp;变量，候选的 Invoker 集合。</li>
<li>第 5 行：调用<strong>父</strong>&nbsp;<code>#checkInvokers(copyinvokers, invocation)</code>&nbsp;方法，<strong>校验</strong>候选的 Invoker 集合<strong>非空</strong>。如果为空，抛出 RpcException 异常。</li>
<li>第 6 至 10 行：获得<strong>最大可调用次数</strong>：最大<strong>可重试</strong>次数 +1 。默认最大可重试次数<code>Constants.DEFAULT_RETRIES = 2</code>&nbsp;。</li>
<li>第 12 行：<code>le</code>&nbsp;变量，保存最后一次调用的<strong>异常</strong>。</li>
<li>第 14 行：<code>invoked</code>&nbsp;变量，保存已经调用的 Invoker 集合。</li>
<li>第 15 行：<code>providers</code>&nbsp;变量，保存已经调用的<strong>网络地址</strong>集合。</li>
<li>第 16 至 62 行：<strong>failover 机制核心实现：如果出现调用失败，那么重试其他服务器</strong>。
<ul>
<li>第 20 至 27 行：<strong>重试时</strong>(&nbsp;<code>i &gt; 0</code>&nbsp;)， 进行重新选择，避免重试时，候选 Invoker 集合，已发生变化。</li>
<li>【重要】第 29 行：调用<strong>父</strong>&nbsp;<code>#select(loadbalance, invocation, copyinvokers, invoked)</code>&nbsp;方法，根据 Loadbalance 负载均衡机制，从&nbsp;<code>copyinvokers</code>&nbsp;中，选择一个被调用的 Invoker 对象。</li>
<li>第 31 行：保存每次调用的 Invoker 对象，到&nbsp;<code>invoked</code>&nbsp;中。</li>
<li>第 33 行：保存已经调用的 Invoker 集合，到 Context 中。</li>
<li>【重要】第 36 行：调用&nbsp;<code>Invoker#invoke(invocation)</code>&nbsp;方法，<strong>发起 RPC 调用</strong>。</li>
<li>第 37 至 48 行：若&nbsp;<code>le</code>&nbsp;非空，说明此时是<strong>重试调用成功</strong>，将最后一次调用的异常信息以&nbsp;<strong>warn</strong>&nbsp;级别日志输出，方便未来追溯。</li>
<li>========== 异常相关 ===========</li>
<li>第 55 至 54 行：如果是业务性质的异常，不再重试，直接抛出。</li>
<li>第 56 行：保存异常到&nbsp;<code>le</code>&nbsp;。</li>
<li>第 58 行：非 RpcException 异常，<strong>封装</strong>成 RpcException 异常。</li>
<li>第 59 至 61 行：保存每次调用的<strong>网络地址</strong>，到&nbsp;<code>providers</code>&nbsp;中。</li>
</ul>
</li>
<li>第 63 至 71 行：超过最大调用次数，抛出 RpcException 异常。该异常中，带有最后一次调用异常的信息。</li>
</ul>
</div>