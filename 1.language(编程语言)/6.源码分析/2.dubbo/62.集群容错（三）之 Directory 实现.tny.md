<header class="article-header">
<h1 class="article-title">集群容错（三）之 Directory 实现</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>本文接&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-2-impl-cluster/?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（二）之 Cluster 实现》</a>&nbsp;一文，分享&nbsp;<code>dubbo-cluster</code>&nbsp;模块，&nbsp;<code>directory</code>&nbsp;包，<strong>各种 Directory 实现类</strong>。</p>
<p>Directory ，中文直译为<strong>目录</strong>，代表了<strong>多个</strong>&nbsp;Invoker ，可以把它看成&nbsp;<code>List&lt;Invoker&gt;</code>&nbsp;。但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更。</p>
<p>Directory 子类如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_04_10/01.png" alt="Directory 子类" /></p>
<p>我们看到有两个实现类：</p>
<ul>
<li>StaticDirectory ，<strong>静态</strong>&nbsp;Directory 实现类，从命名上看出它是<strong>静态</strong>的&nbsp;<code>List&lt;Invoker&gt;</code>&nbsp;。</li>
<li>RegistryDirectory ，基于<strong>注册中心</strong>的<strong>动态</strong>&nbsp;Directory 实现类，从命名上看出它是<strong>动态</strong>的，会根据注册中心的推送变更&nbsp;<code>List&lt;Invoker&gt;</code>&nbsp;。</li>
</ul>
<h1 id="2-Directory">2. Directory</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.Directory</code>&nbsp;，继承 Node 接口，Directory 接口。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Directory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * get service type.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 获得服务类型，例如：com.alibaba.dubbo.demo.DemoService</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> service type.</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * list invokers.</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 获得所有服务 Invoker 集合</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> invokers</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>定义了<strong>两个</strong>接口方法，分别返回服务的<strong>类型</strong>和&nbsp;<strong>Invoker 集合</strong>。</li>
<li>一个 Directory&nbsp;<strong>只对应</strong>一个服务类型。</li>
</ul>
<h1 id="3-AbstractDirectory">3. AbstractDirectory</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.directory.AbstractDirectory</code>&nbsp;，实现 Directory 接口，Directory 抽象实现类，实现了公用的<strong>路由规则( Router )</strong>的逻辑。</p>
<h2 id="3-1-构造方法">3.1 构造方法</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否已经销毁</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroyed = <span class="keyword">false</span>;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 注册中心 URL</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 消费者 URL</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 若未显示调用 {<span class="doctag">@link</span> #AbstractDirectory(URL, URL, List)} 构造方法，consumerUrl 等于 {<span class="doctag">@link</span> #url}</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> URL consumerUrl;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Router 数组</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Router&gt; routers;</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>(url, <span class="keyword">null</span>);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url, List&lt;Router&gt; routers)</span> </span>{</span><br /><span class="line">    <span class="keyword">this</span>(url, url, routers);</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url, URL consumerUrl, List&lt;Router&gt; routers)</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">this</span>.url = url;</span><br /><span class="line">    <span class="keyword">this</span>.consumerUrl = consumerUrl;</span><br /><span class="line">    <span class="comment">// 设置 Router 数组</span></span><br /><span class="line">    setRouters(routers);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>consumerUrl</code>&nbsp;字段，认真看下注释和构造方法。</li>
<li>调用&nbsp;<code>#setRouters(routers)</code>&nbsp;方法，初始化并设置 Router 数组。</li>
</ul>
<h2 id="3-2-setRouters">3.2 setRouters</h2>
<p><code>#setRouters(routers)</code>&nbsp;方法，初始化并设置 Router 数组。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-7-impl-router?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（七）之 Router 实现》</a>&nbsp;中。</p>
<h2 id="3-3-list">3.3 list</h2>
<p><code>#list(Invocation)</code>&nbsp;<strong>实现</strong>方法，获得所有服务 Invoker 集合。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException {</span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (destroyed) {</span><br /><span class="line"> <span class="number">4</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Directory already destroyed .url: "</span> + getUrl());</span><br /><span class="line"> <span class="number">5</span>:     }</span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// 获得所有 Invoker 集合</span></span><br /><span class="line"> <span class="number">7</span>:     List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br /><span class="line"> <span class="number">8</span>:     <span class="comment">// 根据路由规则，筛选 Invoker 集合</span></span><br /><span class="line"> <span class="number">9</span>:     List&lt;Router&gt; localRouters = <span class="keyword">this</span>.routers; <span class="comment">// local reference 本地引用，避免并发问题</span></span><br /><span class="line"><span class="number">10</span>:     <span class="keyword">if</span> (localRouters != <span class="keyword">null</span> &amp;&amp; !localRouters.isEmpty()) {</span><br /><span class="line"><span class="number">11</span>:         <span class="keyword">for</span> (Router router : localRouters) {</span><br /><span class="line"><span class="number">12</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">13</span>:                 <span class="keyword">if</span> (router.getUrl() == <span class="keyword">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class="keyword">false</span>)) {</span><br /><span class="line"><span class="number">14</span>:                     invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br /><span class="line"><span class="number">15</span>:                 }</span><br /><span class="line"><span class="number">16</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">17</span>:                 logger.error(<span class="string">"Failed to execute router: "</span> + getUrl() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br /><span class="line"><span class="number">18</span>:             }</span><br /><span class="line"><span class="number">19</span>:         }</span><br /><span class="line"><span class="number">20</span>:     }</span><br /><span class="line"><span class="number">21</span>:     <span class="keyword">return</span> invokers;</span><br /><span class="line"><span class="number">22</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>
<p>第 7 行：调用&nbsp;<code>#doList(invocation)</code>&nbsp;<strong>抽象</strong>方法，获得所有 Invoker 集合。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class="keyword">throws</span> RpcException;</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
</li>
<li>
<p>第 9 至 20 行：根据<strong>路由规则( Router )</strong>，进一步筛选合适的 Invoker 集合。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（七）之 Router 实现》</a>&nbsp;。</p>
</li>
</ul>
<h1 id="4-RegistryDirectory">4. RegistryDirectory</h1>
<p><code>com.alibaba.dubbo.registry.integration.RegistryDirectory</code>&nbsp;，实现 NotifyListener 接口，实现 AbstractDirectory 抽象类，基于<strong>注册中心</strong>的 Directory 实现类。</p>
<ol>
<li>RegistryDirectory 在&nbsp;<code>dubbo-registry</code>&nbsp;模块，<code>integration</code>&nbsp;包下，是 Dubbo 注册中心模块集成 Directory 的实现类。</li>
<li>RegistryDirectory 作为一个 NotifyListener ，<strong>订阅</strong>注册中心( Registry ) 的数据，实现对变更的<strong>监听</strong>。</li>
</ol>
<h2 id="4-1-构造方法">4.1 构造方法</h2>
<blockquote>
<p>RegistryDirectory 的字段有&nbsp;<strong>17</strong>&nbsp;个，比较多，所以胖友请耐心。</p>
</blockquote>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// ========== Dubbo SPI Adaptive 对象 BEGIN ==========</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Cluster$Adaptive 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * RouterFactory$Adaptive 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension();</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * ConfiguratorFactory$Adaptive 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).getAdaptiveExtension();</span><br /><br /><span class="line"><span class="comment">// ========== 服务消费者相关 BEGIN ==========</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 服务类型，例如：com.alibaba.dubbo.demo.DemoService</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; serviceType; <span class="comment">// Initialization at construction time, assertion not null</span></span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Consumer URL 的配置项 Map</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; queryMap; <span class="comment">// Initialization at construction time, assertion not null</span></span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 服务方法数组</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] serviceMethods;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否引用多分组</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 服务分组：http://dubbo.apache.org/zh-cn/docs/user/demos/service-group.html</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> multiGroup;</span><br /><br /><span class="line"><span class="comment">// ========== 注册中心相关 BEGIN ==========</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 注册中心的 Protocol 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Protocol protocol; <span class="comment">// Initialization at the time of injection, the assertion is not null</span></span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 注册中心</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> Registry registry; <span class="comment">// Initialization at the time of injection, the assertion is not null</span></span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 注册中心的服务类，目前是 com.alibaba.dubbo.registry.RegistryService</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 通过 {<span class="doctag">@link</span> #url} 的 {<span class="doctag">@link</span> URL#getServiceKey()} 获得</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String serviceKey; <span class="comment">// Initialization at construction time, assertion not null</span></span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 是否禁止访问。</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 有两种情况会导致：</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 1. 没有服务提供者</span></span><br /><span class="line"><span class="comment"> * 2. 服务提供者被禁用</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> forbidden = <span class="keyword">false</span>;</span><br /><br /><span class="line"><span class="comment">// ========== 配置规则相关 BEGIN ==========</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 原始的目录 URL</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * 例如：zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&amp;callbacks=1000&amp;check=false&amp;client=netty4&amp;cluster=failback&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello,callbackParam,save,update,say03,delete,say04,demo,say01,bye,say02,saves&amp;payload=1000&amp;pid=63400&amp;qos.port=33333&amp;register.ip=192.168.16.23&amp;sayHello.async=true&amp;side=consumer&amp;timeout=10000&amp;timestamp=1527056491064</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> URL directoryUrl; <span class="comment">// Initialization at construction time, assertion not null, and always assign non null value</span></span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 覆写的目录 URL ，结合配置规则</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> URL overrideDirectoryUrl; <span class="comment">// Initialization at construction time, assertion not null, and always assign non null value</span></span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * 配置规则数组</span></span><br /><span class="line"><span class="comment"> *</span></span><br /><span class="line"><span class="comment"> * override rules</span></span><br /><span class="line"><span class="comment"> * Priority: override&gt;-D&gt;consumer&gt;provider</span></span><br /><span class="line"><span class="comment"> * Rule one: for a certain provider &lt;ip:port,timeout=100&gt;</span></span><br /><span class="line"><span class="comment"> * Rule two: for all providers &lt;* ,timeout=5000&gt;</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Configurator&gt; configurators; <span class="comment">// The initial value is null and the midway may be assigned to null, please use the local variable reference</span></span><br /><br /><span class="line"><span class="comment">// ========== 服务提供者相关 BEGIN ==========</span></span><br /><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * [url]与[服务提供者 Invoker 集合]的映射缓存</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="comment">// Map&lt;url, Invoker&gt; cache service url to invoker mapping.</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Invoker&lt;T&gt;&gt; urlInvokerMap; <span class="comment">// The initial value is null and the midway may be assigned to null, please use the local variable reference</span></span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * [方法名]与[服务提供者 Invoker 集合]的映射缓存</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="comment">// Map&lt;methodName, Invoker&gt; cache service method to invokers mapping.</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodInvokerMap; <span class="comment">// The initial value is null and the midway may be assigned to null, please use the local variable reference</span></span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * [服务提供者 Invoker 集合]缓存</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="comment">// Set&lt;invokerUrls&gt; cache invokeUrls to invokers mapping.</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;URL&gt; cachedInvokerUrls; <span class="comment">// The initial value is null and the midway may be assigned to null, please use the local variable reference</span></span><br /><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RegistryDirectory</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> </span>{</span><br /><span class="line">    <span class="keyword">super</span>(url);</span><br /><span class="line">    <span class="keyword">if</span> (serviceType == <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service type is null."</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">if</span> (url.getServiceKey() == <span class="keyword">null</span> || url.getServiceKey().length() == <span class="number">0</span>) {</span><br /><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"registry serviceKey is null."</span>);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">this</span>.serviceType = serviceType;</span><br /><span class="line">    <span class="keyword">this</span>.serviceKey = url.getServiceKey();</span><br /><span class="line">    <span class="comment">// 获得 queryMap</span></span><br /><span class="line">    <span class="keyword">this</span>.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));</span><br /><span class="line">    <span class="comment">// 获得 overrideDirectoryUrl 和 directoryUrl</span></span><br /><span class="line">    <span class="keyword">this</span>.overrideDirectoryUrl = <span class="keyword">this</span>.directoryUrl = url.setPath(url.getServiceInterface()).clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY);</span><br /><span class="line">    <span class="comment">// 初始化 multiGroup</span></span><br /><span class="line">    String group = directoryUrl.getParameter(Constants.GROUP_KEY, <span class="string">""</span>);</span><br /><span class="line">    <span class="keyword">this</span>.multiGroup = group != <span class="keyword">null</span> &amp;&amp; (<span class="string">"*"</span>.equals(group) || group.contains(<span class="string">","</span>));</span><br /><span class="line">    <span class="comment">// 初始化 serviceMethods</span></span><br /><span class="line">    String methods = queryMap.get(Constants.METHODS_KEY);</span><br /><span class="line">    <span class="keyword">this</span>.serviceMethods = methods == <span class="keyword">null</span> ? <span class="keyword">null</span> : Constants.COMMA_SPLIT_PATTERN.split(methods);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>分成<strong>五类</strong>变量。胖友自己看注释。</li>
<li>如果不理解，可以结合下面的具体方法的使用。🙂 当然也可以给我留言，因为确实变量有点多和复杂。</li>
</ul>
<h2 id="4-2-subscribe">4.2 subscribe</h2>
<p><code>#subscribe(URL)</code>&nbsp;方法，向<strong>注册中心</strong>发起订阅。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>{</span><br /><span class="line">    <span class="comment">// 设置消费者 URL</span></span><br /><span class="line">    setConsumerUrl(url);</span><br /><span class="line">    <span class="comment">// 向注册中心，发起订阅</span></span><br /><span class="line">    registry.subscribe(url, <span class="keyword">this</span>);</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>调用<strong>父</strong>&nbsp;<code>#setConsumerUrl(url)</code>&nbsp;方法，设置&nbsp;<code>consumerUrl</code>&nbsp;消费者 URL 。</li>
<li>调用&nbsp;<code>Registry#subscribe(url, NotifyListener)</code>&nbsp;方法，向注册中心，发起订阅。</li>
</ul>
<p>服务消费者，再引用服务时，会创建 RegistryDirectory 对象，并发起<strong>1）服务提供者 + 2）路由规则 + 3）配置规则</strong>的数据订阅。如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_04_10/02.png" alt="doRefer" /></p>
<ul>
<li>对应为&nbsp;<code>RegistryProtocol#doRefer(Cluster, Registry, Class&lt;T&gt; type, URL url)</code>&nbsp;方法。</li>
</ul>
<h2 id="4-3-notify">4.3 notify</h2>
<p>在注册中心( Registry )发现数据发生变化时，会通知对应的 NotifyListener 们。如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_04_10/03.png" alt="notify" /></p>
<ul>
<li>对应为&nbsp;<code>AbstractRegistry#notify(URL url, NotifyListener, List&lt;URL&gt; urls)</code>&nbsp;方法。</li>
<li>因为 RegistryDirectory 作为一个 NotifyListener ，向注册中心( Registry )发起了订阅，所以此时会被通知。<strong>注意，是按照分类循环通知的</strong>，也就是说，<strong>一次只有一类 URL</strong>&nbsp;。</li>
</ul>
<p><code>#notify(List&lt;URL&gt; urls)</code>&nbsp;<strong>实现</strong>方法，代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>{</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 根据 URL 的分类或协议，分组成三个集合 。</span></span><br /><span class="line"> <span class="number">4</span>:     List&lt;URL&gt; invokerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;(); <span class="comment">// 服务提供者 URL 集合</span></span><br /><span class="line"> <span class="number">5</span>:     List&lt;URL&gt; routerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br /><span class="line"> <span class="number">6</span>:     List&lt;URL&gt; configuratorUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">for</span> (URL url : urls) {</span><br /><span class="line"> <span class="number">8</span>:         String protocol = url.getProtocol();</span><br /><span class="line"> <span class="number">9</span>:         String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">if</span> (Constants.ROUTERS_CATEGORY.equals(category) || Constants.ROUTE_PROTOCOL.equals(protocol)) {</span><br /><span class="line"><span class="number">11</span>:             routerUrls.add(url);</span><br /><span class="line"><span class="number">12</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (Constants.CONFIGURATORS_CATEGORY.equals(category) || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {</span><br /><span class="line"><span class="number">13</span>:             configuratorUrls.add(url);</span><br /><span class="line"><span class="number">14</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (Constants.PROVIDERS_CATEGORY.equals(category)) {</span><br /><span class="line"><span class="number">15</span>:             invokerUrls.add(url);</span><br /><span class="line"><span class="number">16</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">17</span>:             logger.warn(<span class="string">"Unsupported category "</span> + category + <span class="string">" in notified url: "</span> + url + <span class="string">" from registry "</span> + getUrl().getAddress() + <span class="string">" to consumer "</span> + NetUtils.getLocalHost());</span><br /><span class="line"><span class="number">18</span>:         }</span><br /><span class="line"><span class="number">19</span>:     }</span><br /><span class="line"><span class="number">20</span>:     <span class="comment">// 处理配置规则 URL 集合</span></span><br /><span class="line"><span class="number">21</span>:     <span class="comment">// configurators</span></span><br /><span class="line"><span class="number">22</span>:     <span class="keyword">if</span> (!configuratorUrls.isEmpty()) {</span><br /><span class="line"><span class="number">23</span>:         <span class="keyword">this</span>.configurators = toConfigurators(configuratorUrls);</span><br /><span class="line"><span class="number">24</span>:     }</span><br /><span class="line"><span class="number">25</span>:     <span class="comment">// 处理路由规则 URL 集合</span></span><br /><span class="line"><span class="number">26</span>:     <span class="comment">// routers</span></span><br /><span class="line"><span class="number">27</span>:     <span class="keyword">if</span> (!routerUrls.isEmpty()) {</span><br /><span class="line"><span class="number">28</span>:         List&lt;Router&gt; routers = toRouters(routerUrls);</span><br /><span class="line"><span class="number">29</span>:         <span class="keyword">if</span> (routers != <span class="keyword">null</span>) { <span class="comment">// null - do nothing</span></span><br /><span class="line"><span class="number">30</span>:             setRouters(routers);</span><br /><span class="line"><span class="number">31</span>:         }</span><br /><span class="line"><span class="number">32</span>:     }</span><br /><span class="line"><span class="number">33</span>:     <span class="comment">// 合并配置规则，到 `directoryUrl` 中，形成 `overrideDirectoryUrl` 变量。</span></span><br /><span class="line"><span class="number">34</span>:     List&lt;Configurator&gt; localConfigurators = <span class="keyword">this</span>.configurators; <span class="comment">// local reference</span></span><br /><span class="line"><span class="number">35</span>:     <span class="comment">// merge override parameters</span></span><br /><span class="line"><span class="number">36</span>:     <span class="keyword">this</span>.overrideDirectoryUrl = directoryUrl;</span><br /><span class="line"><span class="number">37</span>:     <span class="keyword">if</span> (localConfigurators != <span class="keyword">null</span> &amp;&amp; !localConfigurators.isEmpty()) {</span><br /><span class="line"><span class="number">38</span>:         <span class="keyword">for</span> (Configurator configurator : localConfigurators) {</span><br /><span class="line"><span class="number">39</span>:             <span class="keyword">this</span>.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);</span><br /><span class="line"><span class="number">40</span>:         }</span><br /><span class="line"><span class="number">41</span>:     }</span><br /><span class="line"><span class="number">42</span>:     <span class="comment">// 处理服务提供者 URL 集合</span></span><br /><span class="line"><span class="number">43</span>:     refreshInvoker(invokerUrls);</span><br /><span class="line"><span class="number">44</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><strong>注意</strong>，这是一个<strong>同步</strong>的方法。</li>
<li>第 3 至 19 行：根据 URL 的<strong>分类</strong>或协议，分成组<strong>三个</strong>集合：<strong>1）服务提供者 + 2）路由规则 + 3）配置规则</strong>。</li>
<li>第 20 至 24 行：非空，调用&nbsp;<code>#toConfigurators(configuratorUrls)</code>&nbsp;方法，处理<strong>配置规则</strong>&nbsp;URL 集合。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.3.1 toConfigurators」</a>&nbsp;。</li>
<li>第 25 至 32 行：非空，调用&nbsp;<code>#toRouters(routerUrls)</code>&nbsp;方法，处理<strong>路由规则</strong>&nbsp;URL 集合。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.3.2 toRouters」</a>&nbsp;。
<ul>
<li>若转换到&nbsp;<code>routers</code>&nbsp;非空，调用<strong>父</strong>&nbsp;<code>#setRouters(routers)</code>&nbsp;方法，设置路由规则。</li>
</ul>
</li>
<li>第 33 至 41 行：合并配置规则，到&nbsp;<code>directoryUrl</code>&nbsp;中，形成&nbsp;<code>overrideDirectoryUrl</code>&nbsp;变量。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（六）之 Configurator 实现》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.1.2 mergeUrl」</a>&nbsp;。</li>
<li>第 43 行：调用&nbsp;<code>#refreshInvoker(invokerUrls)</code>&nbsp;方法，处理<strong>服务提供者</strong>&nbsp;URL 集合。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.3.3 refreshInvoker」</a>&nbsp;。</li>
</ul>
<h3 id="4-3-1-toConfigurators">4.3.1 toConfigurators</h3>
<p>详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（六）之 Configurator 实现》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.1.1 toConfigurators」</a>&nbsp;。</p>
<h3 id="4-3-2-toRouters">4.3.2 toRouters</h3>
<p>详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（七）之 Router 实现》</a>&nbsp;。</p>
<h2 id="4-7-内部类">4.7 内部类</h2>
<h3 id="4-7-1-InvokerDelegate">4.7.1 InvokerDelegate</h3>
<p>InvokerDelegate ，实现&nbsp;<code>com.alibaba.dubbo.rpc.protocol.InvokerWrapper</code>&nbsp;类，Invoker 代理类，主要用于存储<strong>注册中心下发的 url 地址</strong>(&nbsp;<code>providerUrl</code>&nbsp;)，用于重新重新 refer 时能够根据&nbsp;<code>providerURL</code>queryMap overrideMap 重新组装。 代码如下：</p>
<blockquote>
<p>老艿艿：目前貌似没看到这块逻辑噢 😯😯😯</p>
</blockquote>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerDelegate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InvokerWrapper</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 服务提供者 URL</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * 未经过配置合并</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> URL providerUrl;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokerDelegate</span><span class="params">(Invoker&lt;T&gt; invoker, URL url, URL providerUrl)</span> </span>{</span><br /><span class="line">        <span class="keyword">super</span>(invoker, url);</span><br /><span class="line">        <span class="keyword">this</span>.providerUrl = providerUrl;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getProviderUrl</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> providerUrl;</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="4-7-2-InvokerComparator">4.7.2 InvokerComparator</h3>
<p>InvokerComparator ，实现 Comparator 接口，Invoker 排序器实现类，<strong>根据 URL 升序</strong>&nbsp;。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Invoker</span>&lt;?&gt;&gt; </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 单例</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InvokerComparator comparator = <span class="keyword">new</span> InvokerComparator();</span><br /><br /><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InvokerComparator</span><span class="params">()</span> </span>{</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvokerComparator <span class="title">getComparator</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> comparator;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Invoker&lt;?&gt; o1, Invoker&lt;?&gt; o2)</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> o1.getUrl().toString().compareTo(o2.getUrl().toString());</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="4-3-3-refreshInvoker">4.3.3 refreshInvoker</h3>
<p><code>#refreshInvoker(List&lt;URL&gt; invokerUrls)</code>&nbsp;方法，官方注释其如下：</p>
<blockquote>
<p>根据 invokerURL 列表转换为 invoker 列表。转换规则如下：</p>
<ol>
<li>如果 url 已经被转换为 invoker ，则不在重新引用，直接从缓存中获取，注意如果 url 中任何一个参数变更也会重新引用</li>
<li>如果传入的 invoker 列表不为空，则表示最新的 invoker 列表</li>
<li>如果传入的 invokerUrl 列表是空，则表示只是下发的 override 规则或 route 规则，需要重新交叉对比，决定是否需要重新引用。</li>
</ol>
</blockquote>
<ul>
<li>是不是看起来有点点懵逼？淡定，我们来看看代码。</li>
</ul>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (invokerUrls != <span class="keyword">null</span> &amp;&amp; invokerUrls.size() == <span class="number">1</span> &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span></span><br /><span class="line"> <span class="number">3</span>:             &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) {</span><br /><span class="line"> <span class="number">4</span>:         <span class="comment">// 设置禁止访问</span></span><br /><span class="line"> <span class="number">5</span>:         <span class="keyword">this</span>.forbidden = <span class="keyword">true</span>; <span class="comment">// Forbid to access</span></span><br /><span class="line"> <span class="number">6</span>:         <span class="comment">// methodInvokerMap 置空</span></span><br /><span class="line"> <span class="number">7</span>:         <span class="keyword">this</span>.methodInvokerMap = <span class="keyword">null</span>; <span class="comment">// Set the method invoker map to null</span></span><br /><span class="line"> <span class="number">8</span>:         <span class="comment">// 销毁所有 Invoker 集合</span></span><br /><span class="line"> <span class="number">9</span>:         destroyAllInvokers(); <span class="comment">// Close all invokers</span></span><br /><span class="line"><span class="number">10</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">11</span>:         <span class="comment">// 设置允许访问</span></span><br /><span class="line"><span class="number">12</span>:         <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>; <span class="comment">// Allow to access</span></span><br /><span class="line"><span class="number">13</span>:         <span class="comment">// 引用老的 urlInvokerMap</span></span><br /><span class="line"><span class="number">14</span>:         Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br /><span class="line"><span class="number">15</span>:         <span class="comment">// 传入的 invokerUrls 为空，说明是路由规则或配置规则发生改变，此时 invokerUrls 是空的，直接使用 cachedInvokerUrls 。</span></span><br /><span class="line"><span class="number">16</span>:         <span class="keyword">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class="keyword">this</span>.cachedInvokerUrls != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">17</span>:             invokerUrls.addAll(<span class="keyword">this</span>.cachedInvokerUrls);</span><br /><span class="line"><span class="number">18</span>:         <span class="comment">// 传入的 invokerUrls 非空，更新 cachedInvokerUrls 。</span></span><br /><span class="line"><span class="number">19</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">20</span>:             <span class="keyword">this</span>.cachedInvokerUrls = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br /><span class="line"><span class="number">21</span>:             <span class="keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls); <span class="comment">//Cached invoker urls, convenient for comparison //缓存invokerUrls列表，便于交叉对比</span></span><br /><span class="line"><span class="number">22</span>:         }</span><br /><span class="line"><span class="number">23</span>:         <span class="comment">// 忽略，若无 invokerUrls</span></span><br /><span class="line"><span class="number">24</span>:         <span class="keyword">if</span> (invokerUrls.isEmpty()) {</span><br /><span class="line"><span class="number">25</span>:             <span class="keyword">return</span>;</span><br /><span class="line"><span class="number">26</span>:         }</span><br /><span class="line"><span class="number">27</span>:         <span class="comment">// 将传入的 invokerUrls ，转成新的 urlInvokerMap</span></span><br /><span class="line"><span class="number">28</span>:         Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class="comment">// Translate url list to Invoker map</span></span><br /><span class="line"><span class="number">29</span>:         <span class="comment">// 转换出新的 methodInvokerMap</span></span><br /><span class="line"><span class="number">30</span>:         Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); <span class="comment">// Change method name to map Invoker Map</span></span><br /><span class="line"><span class="number">31</span>:         <span class="comment">// state change</span></span><br /><span class="line"><span class="number">32</span>:         <span class="comment">// If the calculation is wrong, it is not processed. 如果计算错误，则不进行处理.</span></span><br /><span class="line"><span class="number">33</span>:         <span class="keyword">if</span> (newUrlInvokerMap == <span class="keyword">null</span> || newUrlInvokerMap.size() == <span class="number">0</span>) {</span><br /><span class="line"><span class="number">34</span>:             logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"urls to invokers error .invokerUrls.size :"</span> + invokerUrls.size() + <span class="string">", invoker.size :0. urls :"</span> + invokerUrls.toString()));</span><br /><span class="line"><span class="number">35</span>:             <span class="keyword">return</span>;</span><br /><span class="line"><span class="number">36</span>:         }</span><br /><span class="line"><span class="number">37</span>:         <span class="comment">// 若服务引用多 group ，则按照 method + group 聚合 Invoker 集合</span></span><br /><span class="line"><span class="number">38</span>:         <span class="keyword">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br /><span class="line"><span class="number">39</span>:         <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br /><span class="line"><span class="number">40</span>:         <span class="comment">// 销毁不再使用的 Invoker 集合</span></span><br /><span class="line"><span class="number">41</span>:         <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">42</span>:             destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); <span class="comment">// Close the unused Invoker</span></span><br /><span class="line"><span class="number">43</span>:         } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line"><span class="number">44</span>:             logger.warn(<span class="string">"destroyUnusedInvokers error. "</span>, e);</span><br /><span class="line"><span class="number">45</span>:         }</span><br /><span class="line"><span class="number">46</span>:     }</span><br /><span class="line"><span class="number">47</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>========== 第一部分 ==========</li>
<li>第 2 至 3 行：当&nbsp;<code>invokerUrls</code>&nbsp;集合大小为&nbsp;<strong>1</strong>&nbsp;，并且协议为&nbsp;<code>empty://</code>&nbsp;，说明所有服务提供者都已经<strong>下线</strong>。若注册中心为 Zookeeper ，可参见&nbsp;<code>ZookeeperRegistry#toUrlsWithEmpty(URL consumer, String path, List&lt;String&gt; providers)</code>&nbsp;方法。</li>
<li>第 5 行：设置<strong>禁止</strong>访问，因为没有服务提供者了。</li>
<li>第 7 行：<code>methodInvokerMap</code>&nbsp;置空。</li>
<li>第 9 行：调用&nbsp;<code>#destroyAllInvokers()</code>&nbsp;方法，销毁所有服务提供者 Invoker 集合。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.3.3.5 destroyAllInvokers」</a>&nbsp;。</li>
<li>========== 第二部分 ==========</li>
<li>第 12 行：设置<strong>允许</strong>访问，因为有服务提供者了。</li>
<li>第 15 至 17 行：传入的&nbsp;<code>invokerUrls</code>&nbsp;为空，<strong>说明是路由规则或配置规则发生改变</strong>，此时&nbsp;<code>invokerUrls</code>&nbsp;是空的，直接使用&nbsp;<code>cachedInvokerUrls</code>&nbsp;。对应官方注释【第 3 点】（部分，不包括&ldquo;需要重新交叉对比，决定是否需要重新引用&rdquo;）。</li>
<li>第 18 至 22 行：传入的&nbsp;<code>invokerUrls</code>&nbsp;非空，更新&nbsp;<code>cachedInvokerUrls</code>&nbsp;。考虑到并发的问题，更新的方式为创建<strong>新的</strong>&nbsp;HashSet 。对应官方注释【第 2 点】。
<ul>
<li>为什么【第 15 至 17 行】<strong>不需要更新</strong>呢？因为&nbsp;<code>invokerUrls</code>&nbsp;为空，直接使用&nbsp;<code>cachedInvokerUrls</code>&nbsp;，相当于进行了&ldquo;更新&rdquo;。</li>
</ul>
</li>
<li>第 23 至 26 行：忽略，若无&nbsp;<code>invokerUrls</code>&nbsp;。出现情况为，初始是按照&nbsp;<code>configurators =&gt; routers =&gt; providers</code>&nbsp;，所以前两个会出现这个情况。关于这一点，胖友可以调试感受下。</li>
<li>第 28 行：调用&nbsp;<code>#toInvokers(List&lt;URL&gt; urls)</code>&nbsp;方法，将传入的&nbsp;<code>invokerUrls</code>&nbsp;，转换成<strong>新的</strong><code>urlInvokerMap</code>&nbsp;。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.3.3.1 toInvokers」</a>&nbsp;。</li>
<li>第 30 行：调用&nbsp;<code>#toMethodInvokers(newUrlInvokerMap)</code>&nbsp;方法，将&nbsp;<code>urlInvokerMap</code>&nbsp;转成与方法的映射关系，即<strong>新的</strong>&nbsp;<code>methodInvokerMap</code>&nbsp;。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.3.3.2 toMethodInvokers」</a>&nbsp;。</li>
<li>第 31 至 36 行：如果计算错误，则不进行处理。一般来说，是防御性编程。</li>
<li>第 38 行：若服务引用<strong>多</strong>&nbsp;group ，则调用&nbsp;<code>#toMergeMethodInvokerMap(newMethodInvokerMap)</code>&nbsp;方法，按照&nbsp;<strong>method + group</strong>&nbsp;聚合 Invoker 集合。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.3.3.3 toMethodInvokers」</a>&nbsp;。</li>
<li>第 39 行：赋值&nbsp;<code>urlInvokerMap</code>&nbsp;属性。</li>
<li>第 40 至 45 行：调用&nbsp;<code>#destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap)</code>&nbsp;方法，<strong>销毁</strong>不再使用的 Invoker 集合。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.3.3.4 toMethodInvokers」</a>&nbsp;。</li>
</ul>
<h4 id="4-3-3-1-toInvokers">4.3.3.1 toInvokers</h4>
<p><code>#toInvokers(List&lt;URL&gt; urls)</code>&nbsp;方法，</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) {</span><br /><span class="line"> <span class="number">2</span>:     <span class="comment">// 新的 `newUrlInvokerMap`</span></span><br /><span class="line"> <span class="number">3</span>:     Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;String, Invoker&lt;T&gt;&gt;();</span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">// 若为空，直接返回</span></span><br /><span class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) {</span><br /><span class="line"> <span class="number">6</span>:         <span class="keyword">return</span> newUrlInvokerMap;</span><br /><span class="line"> <span class="number">7</span>:     }</span><br /><span class="line"> <span class="number">8</span>:     <span class="comment">// 已初始化的服务器提供 URL 集合</span></span><br /><span class="line"> <span class="number">9</span>:     Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br /><span class="line"><span class="number">10</span>:     <span class="comment">// 获得引用服务的协议</span></span><br /><span class="line"><span class="number">11</span>:     String queryProtocols = <span class="keyword">this</span>.queryMap.get(Constants.PROTOCOL_KEY);</span><br /><span class="line"><span class="number">12</span>:     <span class="comment">// 循环服务提供者 URL 集合，转成 Invoker 集合</span></span><br /><span class="line"><span class="number">13</span>:     <span class="keyword">for</span> (URL providerUrl : urls) {</span><br /><span class="line"><span class="number">14</span>:         <span class="comment">// If protocol is configured at the reference side, only the matching protocol is selected</span></span><br /><span class="line"><span class="number">15</span>:         <span class="comment">// 如果 reference 端配置了 protocol ，则只选择匹配的 protocol</span></span><br /><span class="line"><span class="number">16</span>:         <span class="keyword">if</span> (queryProtocols != <span class="keyword">null</span> &amp;&amp; queryProtocols.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">17</span>:             <span class="keyword">boolean</span> accept = <span class="keyword">false</span>;</span><br /><span class="line"><span class="number">18</span>:             String[] acceptProtocols = queryProtocols.split(<span class="string">","</span>); <span class="comment">// 可配置多个协议</span></span><br /><span class="line"><span class="number">19</span>:             <span class="keyword">for</span> (String acceptProtocol : acceptProtocols) {</span><br /><span class="line"><span class="number">20</span>:                 <span class="keyword">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) {</span><br /><span class="line"><span class="number">21</span>:                     accept = <span class="keyword">true</span>;</span><br /><span class="line"><span class="number">22</span>:                     <span class="keyword">break</span>;</span><br /><span class="line"><span class="number">23</span>:                 }</span><br /><span class="line"><span class="number">24</span>:             }</span><br /><span class="line"><span class="number">25</span>:             <span class="keyword">if</span> (!accept) {</span><br /><span class="line"><span class="number">26</span>:                 <span class="keyword">continue</span>;</span><br /><span class="line"><span class="number">27</span>:             }</span><br /><span class="line"><span class="number">28</span>:         }</span><br /><span class="line"><span class="number">29</span>:         <span class="comment">// 忽略，若为 `empty://` 协议</span></span><br /><span class="line"><span class="number">30</span>:         <span class="keyword">if</span> (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {</span><br /><span class="line"><span class="number">31</span>:             <span class="keyword">continue</span>;</span><br /><span class="line"><span class="number">32</span>:         }</span><br /><span class="line"><span class="number">33</span>:         <span class="comment">// 忽略，若应用程序不支持该协议</span></span><br /><span class="line"><span class="number">34</span>:         <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {</span><br /><span class="line"><span class="number">35</span>:             logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported protocol "</span> + providerUrl.getProtocol() + <span class="string">" in notified url: "</span> + providerUrl + <span class="string">" from registry "</span> + getUrl().getAddress() + <span class="string">" to consumer "</span> + NetUtils.getLocalHost()</span><br /><span class="line"><span class="number">36</span>:                     + <span class="string">", supported protocol: "</span> + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br /><span class="line"><span class="number">37</span>:             <span class="keyword">continue</span>;</span><br /><span class="line"><span class="number">38</span>:         }</span><br /><span class="line"><span class="number">39</span>:         <span class="comment">// 合并 URL 参数</span></span><br /><span class="line"><span class="number">40</span>:         URL url = mergeUrl(providerUrl);</span><br /><span class="line"><span class="number">41</span>:         <span class="comment">// 忽略，若已经初始化</span></span><br /><span class="line"><span class="number">42</span>:         String key = url.toFullString(); <span class="comment">// The parameter urls are sorted</span></span><br /><span class="line"><span class="number">43</span>:         <span class="keyword">if</span> (keys.contains(key)) { <span class="comment">// Repeated url</span></span><br /><span class="line"><span class="number">44</span>:             <span class="keyword">continue</span>;</span><br /><span class="line"><span class="number">45</span>:         }</span><br /><span class="line"><span class="number">46</span>:         <span class="comment">// 添加到 `keys` 中</span></span><br /><span class="line"><span class="number">47</span>:         keys.add(key);</span><br /><span class="line"><span class="number">48</span>:         <span class="comment">// Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again</span></span><br /><span class="line"><span class="number">49</span>:         <span class="comment">// 如果服务端 URL 发生变化，则重新 refer 引用</span></span><br /><span class="line"><span class="number">50</span>:         Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br /><span class="line"><span class="number">51</span>:         Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br /><span class="line"><span class="number">52</span>:         <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) { <span class="comment">// Not in the cache, refer again 未在缓存中，重新引用</span></span><br /><span class="line"><span class="number">53</span>:             <span class="keyword">try</span> {</span><br /><span class="line"><span class="number">54</span>:                 <span class="comment">// 判断是否开启</span></span><br /><span class="line"><span class="number">55</span>:                 <span class="keyword">boolean</span> enabled;</span><br /><span class="line"><span class="number">56</span>:                 <span class="keyword">if</span> (url.hasParameter(Constants.DISABLED_KEY)) {</span><br /><span class="line"><span class="number">57</span>:                     enabled = !url.getParameter(Constants.DISABLED_KEY, <span class="keyword">false</span>);</span><br /><span class="line"><span class="number">58</span>:                 } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">59</span>:                     enabled = url.getParameter(Constants.ENABLED_KEY, <span class="keyword">true</span>);</span><br /><span class="line"><span class="number">60</span>:                 }</span><br /><span class="line"><span class="number">61</span>:                 <span class="comment">// 若开启，创建 Invoker 对象</span></span><br /><span class="line"><span class="number">62</span>:                 <span class="keyword">if</span> (enabled) {</span><br /><span class="line"><span class="number">63</span>:                     <span class="comment">// 注意，引用服务</span></span><br /><span class="line"><span class="number">64</span>:                     invoker = <span class="keyword">new</span> InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br /><span class="line"><span class="number">65</span>:                 }</span><br /><span class="line"><span class="number">66</span>:             } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line"><span class="number">67</span>:                 logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br /><span class="line"><span class="number">68</span>:             }</span><br /><span class="line"><span class="number">69</span>:             <span class="comment">// 添加到 newUrlInvokerMap 中</span></span><br /><span class="line"><span class="number">70</span>:             <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) { <span class="comment">// Put new invoker in cache</span></span><br /><span class="line"><span class="number">71</span>:                 newUrlInvokerMap.put(key, invoker);</span><br /><span class="line"><span class="number">72</span>:             }</span><br /><span class="line"><span class="number">73</span>:         } <span class="keyword">else</span> { <span class="comment">// 在缓存中，直接使用缓存的 Invoker 对象，添加到 newUrlInvokerMap 中</span></span><br /><span class="line"><span class="number">74</span>:             newUrlInvokerMap.put(key, invoker);</span><br /><span class="line"><span class="number">75</span>:         }</span><br /><span class="line"><span class="number">76</span>:     }</span><br /><span class="line"><span class="number">77</span>:     <span class="comment">// 清空 keys</span></span><br /><span class="line"><span class="number">78</span>:     keys.clear();</span><br /><span class="line"><span class="number">79</span>:     <span class="keyword">return</span> newUrlInvokerMap;</span><br /><span class="line"><span class="number">80</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 行：<code>newUrlInvokerMap</code>&nbsp;变量，新的&nbsp;<code>urlInvokerMap</code>&nbsp;字段，后面会赋值给它。</li>
<li>第 4 至 7 行：若&nbsp;<code>urls</code>&nbsp;为空，直接返回，防御性编程。</li>
<li>第 9 行：<code>keys</code>&nbsp;变量，<strong>已初始化</strong>的服务器提供 URL 集合，即服务提供者 URL 已经处理。</li>
<li>第 11 行：获得引用服务的协议。一般情况下，我们不会设置&nbsp;<code>&lt;dubbo:reference protocol=""/&gt;</code>&nbsp;配置项。</li>
<li>第 13 行：<strong>循环</strong>&nbsp;<code>urls</code>&nbsp;集合，转成 Invoker 集合。</li>
<li>协议处理相关
<ul>
<li>第 14 至 28 行：如果 reference 端配置了 protocol ，则<strong>只选择匹配</strong>的 protocol 。</li>
<li>第 29 至 32 行：<strong>忽略</strong>，若为&nbsp;<code>empty://</code>&nbsp;协议。</li>
<li>第 33 至 38 行：<strong>忽略</strong>，若应用程序不支持该协议。</li>
</ul>
</li>
<li>第 40 行：调用&nbsp;<code>#mergeUrl(providerUrl)</code>&nbsp;方法，<strong>合并</strong>&nbsp;URL 参数。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.3.3.1 mergeUrl」</a>&nbsp;。</li>
<li>第 41 至 47 行：<strong>忽略</strong>，通过&nbsp;<code>keys</code>&nbsp;判断已经初始化。
<ul>
<li>若未初始化，添加到&nbsp;<code>keys</code>&nbsp;中。</li>
</ul>
</li>
<li>第 48 至 75 行：&ldquo;创建&rdquo;服务 Invoker 对象。
<ul>
<li>第 50 至 51 行：获得&nbsp;<code>url</code>&nbsp;对应在&nbsp;<code>localUrlInvokerMap</code>&nbsp;缓存的 Invoker 对象。</li>
<li>第 52 至 72 行：不在缓存中，需要重新 refer 引用，创建 Invoker 对象。
<ul>
<li>第 54 至 60 行：通过配置项&nbsp;<code>enable</code>&nbsp;和&nbsp;<code>disable</code>&nbsp;判断，服务是否开启。</li>
<li>第 61 至 65 行： 若开启，创建 Invoker 对象。
<ul>
<li>【重要】<strong>第 64 行：调用&nbsp;<code>Protocol$Adaptive#refer(serviceType, url)</code>&nbsp;方法，引用服务，创建服务提供者 Invoker 对象</strong>。详细解析，在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">《精尽 Dubbo 源码解析 &mdash;&mdash; 服务引用》</a>&nbsp;已经有了。</li>
<li>第 64 行：创建 InvokerDelegate 对象。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.7.1 InvokerDelegate」</a>&nbsp;。</li>
</ul>
</li>
</ul>
</li>
<li>第 73 至 75 行：在缓存中，直接使用缓存的 Invoker 对象，添加到&nbsp;<code>newUrlInvokerMap</code>&nbsp;中。</li>
</ul>
</li>
<li>第 78 行：清空&nbsp;<code>keys</code>&nbsp;。</li>
<li>第 79 行：返回结果&nbsp;<code>newUrlInvokerMap</code>&nbsp;。</li>
</ul>
<h5 id="4-3-3-1-1-mergeUrl">4.3.3.1.1 mergeUrl</h5>
<p><code>#mergeUrl(providerUrl)</code>&nbsp;方法，合并 URL 参数，<strong>优先级</strong>为配置规则 &gt; 服务消费者配置 &gt; 服务提供者配置。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> URL <span class="title">mergeUrl</span><span class="params">(URL providerUrl)</span> </span>{</span><br /><span class="line"> <span class="number">2</span>:     <span class="comment">// 合并消费端参数</span></span><br /><span class="line"> <span class="number">3</span>:     providerUrl = ClusterUtils.mergeUrl(providerUrl, queryMap); <span class="comment">// Merge the consumer side parameters</span></span><br /><span class="line"> <span class="number">4</span>: </span><br /><span class="line"> <span class="number">5</span>:     <span class="comment">// 合并配置规则</span></span><br /><span class="line"> <span class="number">6</span>:     List&lt;Configurator&gt; localConfigurators = <span class="keyword">this</span>.configurators; <span class="comment">// local reference</span></span><br /><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (localConfigurators != <span class="keyword">null</span> &amp;&amp; !localConfigurators.isEmpty()) {</span><br /><span class="line"> <span class="number">8</span>:         <span class="keyword">for</span> (Configurator configurator : localConfigurators) {</span><br /><span class="line"> <span class="number">9</span>:             providerUrl = configurator.configure(providerUrl);</span><br /><span class="line"><span class="number">10</span>:         }</span><br /><span class="line"><span class="number">11</span>:     }</span><br /><span class="line"><span class="number">12</span>: </span><br /><span class="line"><span class="number">13</span>:     <span class="comment">// 不检查连接是否成功，总是创建 Invoker ！</span></span><br /><span class="line"><span class="number">14</span>:     providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)); <span class="comment">// Do not check whether the connection is successful or not, always create Invoker!</span></span><br /><span class="line"><span class="number">15</span>: </span><br /><span class="line"><span class="number">16</span>:     <span class="comment">// The combination of directoryUrl and override is at the end of notify, which can't be handled here</span></span><br /><span class="line"><span class="number">17</span>:     <span class="comment">// 仅合并提供者参数，因为 directoryUrl 与 override 合并是在 notify 的最后，这里不能够处理</span></span><br /><span class="line"><span class="number">18</span>:     <span class="keyword">this</span>.overrideDirectoryUrl = <span class="keyword">this</span>.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); <span class="comment">// Merge the provider side parameters // 合并提供者参数</span></span><br /><span class="line"><span class="number">19</span>: </span><br /><span class="line"><span class="number">20</span>:     <span class="comment">// 【忽略】因为是对 1.0 版本的兼容</span></span><br /><span class="line"><span class="number">21</span>:     <span class="keyword">if</span> ((providerUrl.getPath() == <span class="keyword">null</span> || providerUrl.getPath().length() == <span class="number">0</span>)</span><br /><span class="line"><span class="number">22</span>:             &amp;&amp; <span class="string">"dubbo"</span>.equals(providerUrl.getProtocol())) { <span class="comment">// Compatible version 1.0</span></span><br /><span class="line"><span class="number">23</span>:         <span class="comment">//fix by tony.chenl DUBBO-44</span></span><br /><span class="line"><span class="number">24</span>:         String path = directoryUrl.getParameter(Constants.INTERFACE_KEY);</span><br /><span class="line"><span class="number">25</span>:         <span class="keyword">if</span> (path != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">26</span>:             <span class="keyword">int</span> i = path.indexOf(<span class="string">'/'</span>);</span><br /><span class="line"><span class="number">27</span>:             <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</span><br /><span class="line"><span class="number">28</span>:                 path = path.substring(i + <span class="number">1</span>);</span><br /><span class="line"><span class="number">29</span>:             }</span><br /><span class="line"><span class="number">30</span>:             i = path.lastIndexOf(<span class="string">':'</span>);</span><br /><span class="line"><span class="number">31</span>:             <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</span><br /><span class="line"><span class="number">32</span>:                 path = path.substring(<span class="number">0</span>, i);</span><br /><span class="line"><span class="number">33</span>:             }</span><br /><span class="line"><span class="number">34</span>:             providerUrl = providerUrl.setPath(path);</span><br /><span class="line"><span class="number">35</span>:         }</span><br /><span class="line"><span class="number">36</span>:     }</span><br /><span class="line"><span class="number">37</span>: </span><br /><span class="line"><span class="number">38</span>:     <span class="comment">// 返回服务提供者 URL</span></span><br /><span class="line"><span class="number">39</span>:     <span class="keyword">return</span> providerUrl;</span><br /><span class="line"><span class="number">40</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>【<strong>重要</strong>】第 3 行：调用&nbsp;<code>ClusterUtils#mergeUrl(providerUrl, queryMap)</code>&nbsp;方法，合并服务消费者配置到&nbsp;<code>providerUrl</code>&nbsp;。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「6. ClusterUtils」</a>&nbsp;。</li>
<li>第 5 至 11 行：合并<strong>配置规则</strong>到&nbsp;<code>providerUrl</code>&nbsp;中。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（六）之 Configurator 实现》</a></li>
<li>第 14 行：设置&nbsp;<code>providerUrl</code>&nbsp;不检查连接是否成功，总是创建 Invoker ！</li>
<li>第 18 行：仅合并提供者参数。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（六）之 Configurator 实现》</a></li>
<li>第 20 至 36 行：【<strong>忽略</strong>】因为是对 1.0 版本的兼容。</li>
</ul>
<h4 id="4-3-3-2-toMethodInvokers">4.3.3.2 toMethodInvokers</h4>
<p><code>#toMethodInvokers(Map&lt;String, Invoker&lt;T&gt;&gt; invokersMap)</code>&nbsp;方法，将&nbsp;<code>invokersMap</code>&nbsp;转成<strong>与方法</strong>的映射关系。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="keyword">private</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; toMethodInvokers(Map&lt;String, Invoker&lt;T&gt;&gt; invokersMap) {</span><br /><span class="line"> <span class="number">2</span>:     <span class="comment">// 创建新的 `methodInvokerMap`</span></span><br /><span class="line"> <span class="number">3</span>:     Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();</span><br /><span class="line"> <span class="number">4</span>:     <span class="comment">// 创建 Invoker 集合</span></span><br /><span class="line"> <span class="number">5</span>:     List&lt;Invoker&lt;T&gt;&gt; invokersList = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br /><span class="line"> <span class="number">6</span>:     <span class="comment">// According to the methods classification declared by the provider URL, the methods is compatible with the registry to execute the filtered methods</span></span><br /><span class="line"> <span class="number">7</span>:     <span class="comment">// 按服务提供者 URL 所声明的 methods 分类，兼容注册中心执行路由过滤掉的 methods</span></span><br /><span class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (invokersMap != <span class="keyword">null</span> &amp;&amp; invokersMap.size() &gt; <span class="number">0</span>) {</span><br /><span class="line"> <span class="number">9</span>:         <span class="comment">// 循环每个服务提供者 Invoker</span></span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokersMap.values()) {</span><br /><span class="line"><span class="number">11</span>:             String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY); <span class="comment">// methods</span></span><br /><span class="line"><span class="number">12</span>:             <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; parameter.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">13</span>:                 String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);</span><br /><span class="line"><span class="number">14</span>:                 <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">15</span>:                     <span class="comment">// 循环每个方法，按照方法名为维度，聚合到 `methodInvokerMap` 中</span></span><br /><span class="line"><span class="number">16</span>:                     <span class="keyword">for</span> (String method : methods) {</span><br /><span class="line"><span class="number">17</span>:                         <span class="keyword">if</span> (method != <span class="keyword">null</span> &amp;&amp; method.length() &gt; <span class="number">0</span> &amp;&amp; !Constants.ANY_VALUE.equals(method)) { <span class="comment">// 当服务提供者的方法为 "*" ，代表泛化调用</span></span><br /><span class="line"><span class="number">18</span>:                             List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);</span><br /><span class="line"><span class="number">19</span>:                             <span class="keyword">if</span> (methodInvokers == <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">20</span>:                                 methodInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br /><span class="line"><span class="number">21</span>:                                 newMethodInvokerMap.put(method, methodInvokers);</span><br /><span class="line"><span class="number">22</span>:                             }</span><br /><span class="line"><span class="number">23</span>:                             methodInvokers.add(invoker);</span><br /><span class="line"><span class="number">24</span>:                         }</span><br /><span class="line"><span class="number">25</span>:                     }</span><br /><span class="line"><span class="number">26</span>:                 }</span><br /><span class="line"><span class="number">27</span>:             }</span><br /><span class="line"><span class="number">28</span>:             <span class="comment">// 添加到 `invokersList` 中</span></span><br /><span class="line"><span class="number">29</span>:             invokersList.add(invoker);</span><br /><span class="line"><span class="number">30</span>:         }</span><br /><span class="line"><span class="number">31</span>:     }</span><br /><span class="line"><span class="number">32</span>:     <span class="comment">// 路由全 `invokersList` ，匹配合适的 Invoker 集合。</span></span><br /><span class="line"><span class="number">33</span>:     List&lt;Invoker&lt;T&gt;&gt; newInvokersList = route(invokersList, <span class="keyword">null</span>);</span><br /><span class="line"><span class="number">34</span>:     <span class="comment">// 添加 `newInvokersList` 到 `newMethodInvokerMap` 中，表示该服务提供者的全量 Invoker 集合</span></span><br /><span class="line"><span class="number">35</span>:     newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);</span><br /><span class="line"><span class="number">36</span>:     <span class="comment">// 循环，基于每个方法路由，匹配合适的 Invoker 集合</span></span><br /><span class="line"><span class="number">37</span>:     <span class="keyword">if</span> (serviceMethods != <span class="keyword">null</span> &amp;&amp; serviceMethods.length &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">38</span>:         <span class="keyword">for</span> (String method : serviceMethods) {</span><br /><span class="line"><span class="number">39</span>:             List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);</span><br /><span class="line"><span class="number">40</span>:             <span class="keyword">if</span> (methodInvokers == <span class="keyword">null</span> || methodInvokers.isEmpty()) {</span><br /><span class="line"><span class="number">41</span>:                 methodInvokers = newInvokersList;</span><br /><span class="line"><span class="number">42</span>:             }</span><br /><span class="line"><span class="number">43</span>:             newMethodInvokerMap.put(method, route(methodInvokers, method));</span><br /><span class="line"><span class="number">44</span>:         }</span><br /><span class="line"><span class="number">45</span>:     }</span><br /><span class="line"><span class="number">46</span>:     <span class="comment">// 循环排序每个方法的 Invoker 集合，并设置为不可变</span></span><br /><span class="line"><span class="number">47</span>:     <span class="comment">// sort and unmodifiable</span></span><br /><span class="line"><span class="number">48</span>:     <span class="keyword">for</span> (String method : <span class="keyword">new</span> HashSet&lt;String&gt;(newMethodInvokerMap.keySet())) {</span><br /><span class="line"><span class="number">49</span>:         List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);</span><br /><span class="line"><span class="number">50</span>:         Collections.sort(methodInvokers, InvokerComparator.getComparator());</span><br /><span class="line"><span class="number">51</span>:         newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));</span><br /><span class="line"><span class="number">52</span>:     }</span><br /><span class="line"><span class="number">53</span>:     <span class="keyword">return</span> Collections.unmodifiableMap(newMethodInvokerMap);</span><br /><span class="line"><span class="number">54</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 3 行：<code>newMethodInvokerMap</code>&nbsp;变量，新的&nbsp;<code>methodInvokerMap</code>&nbsp;字段，后面会赋值给它。</li>
<li>第 5 行：创建 Invoker 集合。在【第 29 行】，我们可以看到，实际就是&nbsp;<code>invokersMap</code>&nbsp;的值的集合。</li>
<li>第 8 至 31 行：按照方法名为<strong>维度</strong>( KEY ) ，聚合<strong>对应的 Invoker 集合</strong>到&nbsp;<code>newMethodInvokerMap</code>&nbsp;中。</li>
<li>第 33 行：路由全&nbsp;<code>invokersList</code>&nbsp;，匹配合适的 Invoker 集合。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（七）之 Router 实现》</a>&nbsp;。</li>
<li>第 35 行：添加&nbsp;<code>newInvokersList</code>&nbsp;到&nbsp;<code>newMethodInvokerMap</code>&nbsp;中，表示该服务提供者的<strong>全量</strong>&nbsp;Invoker 集合。</li>
<li>第 36 至 45 行：<strong>循环</strong>，基于每个方法路由，匹配合适的 Invoker 集合。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（七）之 Router 实现》</a>&nbsp;。</li>
<li>第 46 至 53 行：循环<strong>排序</strong>每个方法的 Invoker 集合，并设置为<strong>不可变</strong>。</li>
</ul>
<h4 id="4-3-3-3-toMergeMethodInvokerMap">4.3.3.3 toMergeMethodInvokerMap</h4>
<p><code>#toMergeMethodInvokerMap(Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodMap)</code>&nbsp;，按照&nbsp;<strong>method + group</strong>聚合 Invoker 集合。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="keyword">private</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; toMergeMethodInvokerMap(Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodMap) {</span><br /><span class="line"> <span class="number">2</span>:     Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();</span><br /><span class="line"> <span class="number">3</span>:     <span class="comment">// 循环方法，按照 method + group 聚合 Invoker 集合</span></span><br /><span class="line"> <span class="number">4</span>:     <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; entry : methodMap.entrySet()) {</span><br /><span class="line"> <span class="number">5</span>:         String method = entry.getKey();</span><br /><span class="line"> <span class="number">6</span>:         List&lt;Invoker&lt;T&gt;&gt; invokers = entry.getValue();</span><br /><span class="line"> <span class="number">7</span>:         <span class="comment">// 按照 Group 聚合 Invoker 集合的结果。其中，KEY：group VALUE：Invoker 集合。</span></span><br /><span class="line"> <span class="number">8</span>:         Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; groupMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();</span><br /><span class="line"> <span class="number">9</span>:         <span class="comment">// 循环 Invoker 集合，按照 group 聚合 Invoker 集合</span></span><br /><span class="line"><span class="number">10</span>:         <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) {</span><br /><span class="line"><span class="number">11</span>:             String group = invoker.getUrl().getParameter(Constants.GROUP_KEY, <span class="string">""</span>);</span><br /><span class="line"><span class="number">12</span>:             List&lt;Invoker&lt;T&gt;&gt; groupInvokers = groupMap.get(group);</span><br /><span class="line"><span class="number">13</span>:             <span class="keyword">if</span> (groupInvokers == <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">14</span>:                 groupInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br /><span class="line"><span class="number">15</span>:                 groupMap.put(group, groupInvokers);</span><br /><span class="line"><span class="number">16</span>:             }</span><br /><span class="line"><span class="number">17</span>:             groupInvokers.add(invoker);</span><br /><span class="line"><span class="number">18</span>:         }</span><br /><span class="line"><span class="number">19</span>:         <span class="comment">// 大小为 1，使用第一个</span></span><br /><span class="line"><span class="number">20</span>:         <span class="keyword">if</span> (groupMap.size() == <span class="number">1</span>) {</span><br /><span class="line"><span class="number">21</span>:             result.put(method, groupMap.values().iterator().next());</span><br /><span class="line"><span class="number">22</span>:         <span class="comment">// 大于 1，将每个 Group 的 Invoker 集合，创建成 Cluster Invoker 对象。</span></span><br /><span class="line"><span class="number">23</span>:         } <span class="keyword">else</span> <span class="keyword">if</span> (groupMap.size() &gt; <span class="number">1</span>) {</span><br /><span class="line"><span class="number">24</span>:             List&lt;Invoker&lt;T&gt;&gt; groupInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br /><span class="line"><span class="number">25</span>:             <span class="keyword">for</span> (List&lt;Invoker&lt;T&gt;&gt; groupList : groupMap.values()) {</span><br /><span class="line"><span class="number">26</span>:                 groupInvokers.add(cluster.join(<span class="keyword">new</span> StaticDirectory&lt;T&gt;(groupList)));</span><br /><span class="line"><span class="number">27</span>:             }</span><br /><span class="line"><span class="number">28</span>:             result.put(method, groupInvokers);</span><br /><span class="line"><span class="number">29</span>:         <span class="comment">// 大小为 0 ，使用原有值</span></span><br /><span class="line"><span class="number">30</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">31</span>:             result.put(method, invokers);</span><br /><span class="line"><span class="number">32</span>:         }</span><br /><span class="line"><span class="number">33</span>:     }</span><br /><span class="line"><span class="number">34</span>:     <span class="keyword">return</span> result;</span><br /><span class="line"><span class="number">35</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>第 2 行：<code>result</code>&nbsp;属性，<strong>新的</strong>&nbsp;<code>methodInvokerMap</code>&nbsp;字段，后面会赋值给它。</li>
<li>第 3 终 33 行：<strong>循环</strong>，按照&nbsp;<strong>method + group</strong>&nbsp;聚合 Invoker 集合。
<ul>
<li>第 8 行： 按照 Group 聚合 Invoker 集合的结果。其中，<strong>KEY</strong>：group ，<strong>VALUE</strong>：Invoker 集合。</li>
<li>第 9 至 18 行：<strong>循环</strong>&nbsp;Invoker 集合，按照&nbsp;<strong>group</strong>&nbsp;聚合 Invoker 集合。</li>
<li>========== 结果&nbsp;<code>groupMap</code>&nbsp;处理 ==========</li>
<li>第 19 至 21 行：若数量为 1 ，使用第一个。</li>
<li>第 29 至 32 行：若数量为 0 ，使用原有值&nbsp;<code>invokers</code>&nbsp;。实际上，和【第 19 至 21 行】<strong>等价</strong>。</li>
<li>第 22 至 28 行：若数量<strong>大于</strong>&nbsp;1 ，循环<strong>每个</strong>&nbsp;Group 的 Invoker 集合，调用&nbsp;<code>Cluster$Adaptive#join(Directory)</code>&nbsp;方法，创建对应的 Cluster Invoker 对象。
<ul>
<li>我们发现，此处创建&nbsp;<strong>StaticDirectory</strong>&nbsp;对象。详细解析，见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「5. StaticDirectory」</a>&nbsp;。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>那么，引用多个服务分组有什么用呢？为什么要按照&nbsp;<strong>group</strong>&nbsp;进行聚合，直接调用不可以么？让我们来打开&nbsp;<code>ProtocolRegistry#refer(Class&lt;T&gt; type, URL url)</code>&nbsp;方法，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_04_10/04.png" alt="refer" /></p>
<ul>
<li>当引用多个服务分组时，会<strong>自动</strong>使用到<strong>分组聚合</strong>的特性。那么之后 MergeableCluster 会怎么做呢？详细解析，见后文 😈。</li>
</ul>
<h4 id="4-3-3-4-destroyUnusedInvokers">4.3.3.4 destroyUnusedInvokers</h4>
<p><code>#destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap)</code>&nbsp;方法，<strong>销毁</strong>不再使用的 Invoker 集合。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroyUnusedInvokers</span><span class="params">(Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap, Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap)</span> </span>{</span><br /><span class="line">    <span class="comment">// 防御性编程，目前不存在这个情况</span></span><br /><span class="line">    <span class="keyword">if</span> (newUrlInvokerMap == <span class="keyword">null</span> || newUrlInvokerMap.size() == <span class="number">0</span>) {</span><br /><span class="line">        <span class="comment">// 销毁所有服务提供者 Invoker</span></span><br /><span class="line">        destroyAllInvokers();</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// check deleted invoker</span></span><br /><span class="line">    <span class="comment">// 对比新老集合，计算需要销毁的 Invoker 集合</span></span><br /><span class="line">    List&lt;String&gt; deleted = <span class="keyword">null</span>;</span><br /><span class="line">    <span class="keyword">if</span> (oldUrlInvokerMap != <span class="keyword">null</span>) {</span><br /><span class="line">        Collection&lt;Invoker&lt;T&gt;&gt; newInvokers = newUrlInvokerMap.values();</span><br /><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Invoker&lt;T&gt;&gt; entry : oldUrlInvokerMap.entrySet()) {</span><br /><span class="line">            <span class="comment">// 若不存在，添加到 `deleted` 中</span></span><br /><span class="line">            <span class="keyword">if</span> (!newInvokers.contains(entry.getValue())) {</span><br /><span class="line">                <span class="keyword">if</span> (deleted == <span class="keyword">null</span>) {</span><br /><span class="line">                    deleted = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br /><span class="line">                }</span><br /><span class="line">                deleted.add(entry.getKey());</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">// 若有需要销毁的 Invoker ，则进行销毁</span></span><br /><span class="line">    <span class="keyword">if</span> (deleted != <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="keyword">for</span> (String url : deleted) {</span><br /><span class="line">            <span class="keyword">if</span> (url != <span class="keyword">null</span>) {</span><br /><span class="line">                <span class="comment">// 移除出 `urlInvokerMap`</span></span><br /><span class="line">                Invoker&lt;T&gt; invoker = oldUrlInvokerMap.remove(url);</span><br /><span class="line">                <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) {</span><br /><span class="line">                    <span class="keyword">try</span> {</span><br /><span class="line">                        <span class="comment">// 销毁 Invoker</span></span><br /><span class="line">                        invoker.destroy();</span><br /><span class="line">                        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br /><span class="line">                            logger.debug(<span class="string">"destroy invoker["</span> + invoker.getUrl() + <span class="string">"] success. "</span>);</span><br /><span class="line">                        }</span><br /><span class="line">                    } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line">                        logger.warn(<span class="string">"destroy invoker["</span> + invoker.getUrl() + <span class="string">"] failed. "</span> + e.getMessage(), e);</span><br /><span class="line">                    }</span><br /><span class="line">                }</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h4 id="4-3-3-5-destroyAllInvokers">4.3.3.5 destroyAllInvokers</h4>
<p><code>#destroyAllInvokers()</code>&nbsp;方法，销毁所有服务提供者 Invoker 。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroyAllInvokers</span><span class="params">()</span> </span>{</span><br /><span class="line">    Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference 本地引用，避免并发问题</span></span><br /><span class="line">    <span class="keyword">if</span> (localUrlInvokerMap != <span class="keyword">null</span>) {</span><br /><span class="line">        <span class="comment">// 循环 urlInvokerMap ，销毁所有服务提供者 Invoker</span></span><br /><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(localUrlInvokerMap.values())) {</span><br /><span class="line">            <span class="keyword">try</span> {</span><br /><span class="line">                invoker.destroy();</span><br /><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">                logger.warn(<span class="string">"Failed to destroy service "</span> + serviceKey + <span class="string">" to provider "</span> + invoker.getUrl(), t);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// urlInvokerMap 清空</span></span><br /><span class="line">        localUrlInvokerMap.clear();</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// methodInvokerMap 置空</span></span><br /><span class="line">    methodInvokerMap = <span class="keyword">null</span>;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="4-4-doList">4.4 doList</h2>
<p><code>#doList(Invocation)</code>&nbsp;<strong>实现</strong>方法，获得对应的 Invoker 集合。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line"> <span class="number">2</span>: <span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) {</span><br /><span class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (forbidden) {</span><br /><span class="line"> <span class="number">4</span>:         <span class="comment">// 1. No service provider 2. Service providers are disabled</span></span><br /><span class="line"> <span class="number">5</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.FORBIDDEN_EXCEPTION,</span><br /><span class="line"> <span class="number">6</span>:             <span class="string">"No provider available from registry "</span> + getUrl().getAddress() + <span class="string">" for service "</span> + getConsumerUrl().getServiceKey() + <span class="string">" on consumer "</span> +  NetUtils.getLocalHost()</span><br /><span class="line"> <span class="number">7</span>:                     + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", please check status of providers(disabled, not registered or in blacklist)."</span>);</span><br /><span class="line"> <span class="number">8</span>:     }</span><br /><span class="line"> <span class="number">9</span>:     List&lt;Invoker&lt;T&gt;&gt; invokers = <span class="keyword">null</span>;</span><br /><span class="line"><span class="number">10</span>:     Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = <span class="keyword">this</span>.methodInvokerMap; <span class="comment">// local reference</span></span><br /><span class="line"><span class="number">11</span>:     <span class="comment">// 获得 Invoker 集合</span></span><br /><span class="line"><span class="number">12</span>:     <span class="keyword">if</span> (localMethodInvokerMap != <span class="keyword">null</span> &amp;&amp; localMethodInvokerMap.size() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">13</span>:         <span class="comment">// 获得方法名、方法参数</span></span><br /><span class="line"><span class="number">14</span>:         String methodName = RpcUtils.getMethodName(invocation);</span><br /><span class="line"><span class="number">15</span>:         Object[] args = RpcUtils.getArguments(invocation);</span><br /><span class="line"><span class="number">16</span>:         <span class="comment">// 【第一】可根据第一个参数枚举路由</span></span><br /><span class="line"><span class="number">17</span>:         <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span></span><br /><span class="line"><span class="number">18</span>:                 &amp;&amp; (args[<span class="number">0</span>] <span class="keyword">instanceof</span> String || args[<span class="number">0</span>].getClass().isEnum())) {</span><br /><span class="line"><span class="number">19</span>: <span class="comment">//            invokers = localMethodInvokerMap.get(methodName + "." + args[0]); // The routing can be enumerated according to the first parameter</span></span><br /><span class="line"><span class="number">20</span>:             invokers = localMethodInvokerMap.get(methodName + args[<span class="number">0</span>]); <span class="comment">// The routing can be enumerated according to the first parameter</span></span><br /><span class="line"><span class="number">21</span>:         }</span><br /><span class="line"><span class="number">22</span>:         <span class="comment">// 【第二】根据方法名获得 Invoker 集合</span></span><br /><span class="line"><span class="number">23</span>:         <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">24</span>:             invokers = localMethodInvokerMap.get(methodName);</span><br /><span class="line"><span class="number">25</span>:         }</span><br /><span class="line"><span class="number">26</span>:         <span class="comment">// 【第三】使用全量 Invoker 集合。例如，`#$echo(name)` ，回声方法</span></span><br /><span class="line"><span class="number">27</span>:         <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">28</span>:             invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);</span><br /><span class="line"><span class="number">29</span>:         }</span><br /><span class="line"><span class="number">30</span>:         <span class="comment">// 【第四】使用 `methodInvokerMap` 第一个 Invoker 集合。防御性编程。</span></span><br /><span class="line"><span class="number">31</span>:         <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">32</span>:             Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator();</span><br /><span class="line"><span class="number">33</span>:             <span class="keyword">if</span> (iterator.hasNext()) {</span><br /><span class="line"><span class="number">34</span>:                 invokers = iterator.next();</span><br /><span class="line"><span class="number">35</span>:             }</span><br /><span class="line"><span class="number">36</span>:         }</span><br /><span class="line"><span class="number">37</span>:     }</span><br /><span class="line"><span class="number">38</span>:     <span class="keyword">return</span> invokers == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(<span class="number">0</span>) : invokers;</span><br /><span class="line"><span class="number">39</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>通过四种方式，从&nbsp;<code>methodInvokerMap</code>&nbsp;中，获得对应的 Invoker 集合。</li>
<li>
<p>第一种，可根据<strong>第一个参数</strong>枚举路由。这是个非常小众的场景，胖友不必理解。例子如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">// DemoService 接口定义</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>{</span><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello01</span><span class="params">(String name)</span></span>;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello02</span><span class="params">(String name)</span></span>;</span><br /><span class="line">}</span><br /><br /><span class="line"><span class="comment">// 消费者调用</span></span><br /><span class="line">DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>);</span><br /><span class="line">demoService.hello(<span class="string">"01"</span>);</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>通过这样的方式，调用到的服务提供者的&nbsp;<code>DemoServiceImpl#hello01(name)</code>&nbsp;方法。</li>
<li>如果使用该<strong>特性</strong>，注意避免出现<strong>无关</strong>的几个方法，例如&nbsp;<code>#hello(name)</code>&nbsp;和&nbsp;<code>#hello01(name)</code>&nbsp;是毫无关系的两个方法，而我真的想调用&nbsp;<code>#hello(name)</code>&nbsp;方法，结果调用到了&nbsp;<code>#hello01(name)</code>&nbsp;方法。</li>
<li>
<p>如下是 Dubbo Commiter&nbsp;<strong>诣极</strong>&nbsp;的解惑，非常感谢。</p>
<blockquote>
<p>动态的方法名本身就是接口中已经定义的</p>
<p>举个例子吧借口定义了 method, method1,method2， 如果我发起rpc调用method(1, 2, 3), 这个时候会去查找方法method1的invokers， 如果我这个时候发起rpc method(2, 1, 3), 这个时候会去查找方法method2的invokers， 然后调用invokers的method方法</p>
</blockquote>
<ul>
<li>另外，经过沟通，【第 19 行】的&nbsp;<code>"."</code>&nbsp;是个 BUG ，方法里不能包含该字符，因此，笔者改成了【第 20 行】，去掉了&nbsp;<code>"."</code>&nbsp;进行测试。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第二种，根据<strong>方法名</strong>获得 Invoker 集合。一般情况下，都能匹配到。</p>
</li>
<li>第三种，使用全量 Invoker 集合。例如，<code>#$echo(name)</code>&nbsp;回声方法。</li>
<li>第四种，使用&nbsp;<code>methodInvokerMap</code>&nbsp;第一个 Invoker 集合。防御性编程。</li>
</ul>
<h2 id="4-5-isAvailable">4.5 isAvailable</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="comment">// 若已销毁，返回不可用</span></span><br /><span class="line">    <span class="keyword">if</span> (isDestroyed()) {</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 任意一个 Invoker 可用，则返回可用</span></span><br /><span class="line">    Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = urlInvokerMap;</span><br /><span class="line">    <span class="keyword">if</span> (localUrlInvokerMap != <span class="keyword">null</span> &amp;&amp; localUrlInvokerMap.size() &gt; <span class="number">0</span>) {</span><br /><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(localUrlInvokerMap.values())) {</span><br /><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) {</span><br /><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="4-6-destroy">4.6 destroy</h2>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@Override</span></span><br /><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">    <span class="keyword">if</span> (isDestroyed()) {</span><br /><span class="line">        <span class="keyword">return</span>;</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 取消订阅</span></span><br /><span class="line">    <span class="comment">// unsubscribe.</span></span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        <span class="keyword">if</span> (getConsumerUrl() != <span class="keyword">null</span> &amp;&amp; registry != <span class="keyword">null</span> &amp;&amp; registry.isAvailable()) {</span><br /><span class="line">            registry.unsubscribe(getConsumerUrl(), <span class="keyword">this</span>);</span><br /><span class="line">        }</span><br /><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">        logger.warn(<span class="string">"unexpeced error when unsubscribe service "</span> + serviceKey + <span class="string">"from registry"</span> + registry.getUrl(), t);</span><br /><span class="line">    }</span><br /><span class="line">    <span class="comment">// 标记已经销毁</span></span><br /><span class="line">    <span class="keyword">super</span>.destroy(); <span class="comment">// must be executed after unsubscribing</span></span><br /><span class="line">    <span class="comment">// 销毁所有 Invoker </span></span><br /><span class="line">    <span class="keyword">try</span> {</span><br /><span class="line">        destroyAllInvokers();</span><br /><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br /><span class="line">        logger.warn(<span class="string">"Failed to destroy service "</span> + serviceKey, t);</span><br /><span class="line">    }</span><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="5-StaticDirectory">5. StaticDirectory</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.directory.StaticDirectory</code>&nbsp;，实现 AbstractDirectory 抽象类，<strong>静态</strong>&nbsp;Directory 实现类。逻辑比较简单，将传入的&nbsp;<code>invokers</code>&nbsp;集合，封装成静态的 Directory 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Invoker 集合</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers;</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers)</span> </span>{</span><br /><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, invokers, <span class="keyword">null</span>);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Router&gt; routers)</span> </span>{</span><br /><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, invokers, routers);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(URL url, List&lt;Invoker&lt;T&gt;&gt; invokers)</span> </span>{</span><br /><span class="line">        <span class="keyword">this</span>(url, invokers, <span class="keyword">null</span>);</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(URL url, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Router&gt; routers)</span> </span>{</span><br /><span class="line">        <span class="comment">// 默认使用 `url` 参数。当它为空时，使用 `invokers[0].url` 。</span></span><br /><span class="line">        <span class="keyword">super</span>(url == <span class="keyword">null</span> &amp;&amp; invokers != <span class="keyword">null</span> &amp;&amp; !invokers.isEmpty() ? invokers.get(<span class="number">0</span>).getUrl() : url, routers);</span><br /><span class="line">        <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty()) {</span><br /><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invokers == null"</span>);</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">this</span>.invokers = invokers;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>).getInterface();</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="comment">// 若已经销毁，则不可用</span></span><br /><span class="line">        <span class="keyword">if</span> (isDestroyed()) {</span><br /><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 任一一个 Invoker 可用，则为可用</span></span><br /><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) {</span><br /><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) {</span><br /><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br /><span class="line">        <span class="comment">// 若已经销毁， 跳过</span></span><br /><span class="line">        <span class="keyword">if</span> (isDestroyed()) {</span><br /><span class="line">            <span class="keyword">return</span>;</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 销毁</span></span><br /><span class="line">        <span class="keyword">super</span>.destroy();</span><br /><span class="line">        <span class="comment">// 销毁每个 Invoker</span></span><br /><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) {</span><br /><span class="line">            invoker.destroy();</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 清空 Invoker 集合</span></span><br /><span class="line">        invokers.clear();</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class="keyword">throws</span> RpcException {</span><br /><span class="line">        <span class="keyword">return</span> invokers;</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>代码比较易懂，胖友自己看下。</li>
</ul>
<hr />
<p>除了在&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/">「4.3.3.3 toMergeMethodInvokerMap」</a>&nbsp;方法中，使用到了 StaticDirectory 对象。我们来看看&nbsp;<code>ReferenceConfig#createProxy(Map&lt;String, String&gt; map)</code>&nbsp;的使用，代码如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_04_10/05.png" alt="createProxy" /></p>
<ul>
<li>
<p>第 522 至 527 行：当&nbsp;<code>registryURL</code>&nbsp;非空时，意味着<strong>有注册中心</strong>，使用&nbsp;<code>cluster=available</code>&nbsp;集群方式，并调用&nbsp;<code>Cluster$Adaptive#join(StaticDirectory)</code>&nbsp;方法，创建对应的 Cluster Invoker 对象。这意味着，服务调用时，因为使用的是&nbsp;<code>cluster=available</code>&nbsp;，<strong>仅调用第一个可用的 Invoker 对象</strong>。下面，我们来做一个 YY ：</p>
<ul>
<li>目前我们有 A , B 两个机房，分别对应 zk01 集群，zk02 集群。这两个 zk 集群<strong>不互通</strong>&nbsp;。</li>
<li>A , B 机房，分别部署了&nbsp;<strong>User 服务提供者</strong>，仅注册到自己机房的 zk 集群。</li>
<li>
<p>A , B 机房，部署了对应的&nbsp;<strong>User 服务消费</strong>，那么如果我们希望优先调用本机房。当本机房&nbsp;<strong>User 服务提供者</strong>全挂的情况下，使用另外一个机房，该如何配置呢？</p>
<figure class="highlight xml">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">// A 机房</span><br /><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.UserService"</span> <span class="attr">registry</span>=<span class="string">"zk01,zk02"</span> /&gt;</span></span><br /><span class="line">// B 机房</span><br /><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.UserService"</span> <span class="attr">registry</span>=<span class="string">"zk02,zk01"</span> /&gt;</span></span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>即在&nbsp;<code>"registry"</code>&nbsp;配置项中，将自己的 zk 集群放在前面。</li>
<li>当然，大多数情况下，很少会出现一个机房服务提供者全挂，zk 集群还存活着。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="6-ClusterUtils">6. ClusterUtils</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.support.ClusterUtils</code>&nbsp;，Cluster 工具类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClusterUtils</span> </span>{</span><br /><span class="line"> <span class="number">2</span>:</span><br /><span class="line"> <span class="number">3</span>:     <span class="function"><span class="keyword">private</span> <span class="title">ClusterUtils</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">4</span>:     }</span><br /><span class="line"> <span class="number">5</span>:</span><br /><span class="line"> <span class="number">6</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URL <span class="title">mergeUrl</span><span class="params">(URL remoteUrl, Map&lt;String, String&gt; localMap)</span> </span>{</span><br /><span class="line"> <span class="number">7</span>:         <span class="comment">// 合并配置 Map 结果</span></span><br /><span class="line"> <span class="number">8</span>:         Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br /><span class="line"> <span class="number">9</span>:         <span class="comment">// 远程配置 Map 结果</span></span><br /><span class="line"><span class="number">10</span>:         Map&lt;String, String&gt; remoteMap = remoteUrl.getParameters();</span><br /><span class="line"><span class="number">11</span>:</span><br /><span class="line"><span class="number">12</span>:         <span class="comment">// 添加 `remoteMap` 到 `map` 中，并移除不必要的配置</span></span><br /><span class="line"><span class="number">13</span>:         <span class="keyword">if</span> (remoteMap != <span class="keyword">null</span> &amp;&amp; remoteMap.size() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">14</span>:             map.putAll(remoteMap);</span><br /><span class="line"><span class="number">15</span>:</span><br /><span class="line"><span class="number">16</span>:             <span class="comment">// Remove configurations from provider, some items should be affected by provider. 线程池配置不使用提供者的</span></span><br /><span class="line"><span class="number">17</span>:             map.remove(Constants.THREAD_NAME_KEY);</span><br /><span class="line"><span class="number">18</span>:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREAD_NAME_KEY);</span><br /><span class="line"><span class="number">19</span>:</span><br /><span class="line"><span class="number">20</span>:             map.remove(Constants.THREADPOOL_KEY);</span><br /><span class="line"><span class="number">21</span>:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREADPOOL_KEY);</span><br /><span class="line"><span class="number">22</span>:</span><br /><span class="line"><span class="number">23</span>:             map.remove(Constants.CORE_THREADS_KEY);</span><br /><span class="line"><span class="number">24</span>:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.CORE_THREADS_KEY);</span><br /><span class="line"><span class="number">25</span>:</span><br /><span class="line"><span class="number">26</span>:             map.remove(Constants.THREADS_KEY);</span><br /><span class="line"><span class="number">27</span>:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREADS_KEY);</span><br /><span class="line"><span class="number">28</span>:</span><br /><span class="line"><span class="number">29</span>:             map.remove(Constants.QUEUES_KEY);</span><br /><span class="line"><span class="number">30</span>:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.QUEUES_KEY);</span><br /><span class="line"><span class="number">31</span>:</span><br /><span class="line"><span class="number">32</span>:             map.remove(Constants.ALIVE_KEY);</span><br /><span class="line"><span class="number">33</span>:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.ALIVE_KEY);</span><br /><span class="line"><span class="number">34</span>:</span><br /><span class="line"><span class="number">35</span>:             map.remove(Constants.TRANSPORTER_KEY);</span><br /><span class="line"><span class="number">36</span>:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.TRANSPORTER_KEY);</span><br /><span class="line"><span class="number">37</span>:         }</span><br /><span class="line"><span class="number">38</span>:         <span class="comment">// 添加 `localMap` 到 `map` 中</span></span><br /><span class="line"><span class="number">39</span>:         <span class="keyword">if</span> (localMap != <span class="keyword">null</span> &amp;&amp; localMap.size() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">40</span>:             map.putAll(localMap);</span><br /><span class="line"><span class="number">41</span>:         }</span><br /><span class="line"><span class="number">42</span>:</span><br /><span class="line"><span class="number">43</span>:         <span class="comment">// 添加指定的 `remoteMap` 的配置项到 `map` 中，因为上面被 `localMap` 覆盖了。</span></span><br /><span class="line"><span class="number">44</span>:         <span class="keyword">if</span> (remoteMap != <span class="keyword">null</span> &amp;&amp; remoteMap.size() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">45</span>:             <span class="comment">// Use version passed from provider side</span></span><br /><span class="line"><span class="number">46</span>:             String dubbo = remoteMap.get(Constants.DUBBO_VERSION_KEY);</span><br /><span class="line"><span class="number">47</span>:             <span class="keyword">if</span> (dubbo != <span class="keyword">null</span> &amp;&amp; dubbo.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">48</span>:                 map.put(Constants.DUBBO_VERSION_KEY, dubbo);</span><br /><span class="line"><span class="number">49</span>:             }</span><br /><span class="line"><span class="number">50</span>:             String version = remoteMap.get(Constants.VERSION_KEY);</span><br /><span class="line"><span class="number">51</span>:             <span class="keyword">if</span> (version != <span class="keyword">null</span> &amp;&amp; version.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">52</span>:                 map.put(Constants.VERSION_KEY, version);</span><br /><span class="line"><span class="number">53</span>:             }</span><br /><span class="line"><span class="number">54</span>:             String group = remoteMap.get(Constants.GROUP_KEY);</span><br /><span class="line"><span class="number">55</span>:             <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">56</span>:                 map.put(Constants.GROUP_KEY, group);</span><br /><span class="line"><span class="number">57</span>:             }</span><br /><span class="line"><span class="number">58</span>:             String methods = remoteMap.get(Constants.METHODS_KEY);</span><br /><span class="line"><span class="number">59</span>:             <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">60</span>:                 map.put(Constants.METHODS_KEY, methods);</span><br /><span class="line"><span class="number">61</span>:             }</span><br /><span class="line"><span class="number">62</span>:             <span class="comment">// Reserve timestamp of provider url. 保留 provider 的启动 timestamp</span></span><br /><span class="line"><span class="number">63</span>:             String remoteTimestamp = remoteMap.get(Constants.TIMESTAMP_KEY);</span><br /><span class="line"><span class="number">64</span>:             <span class="keyword">if</span> (remoteTimestamp != <span class="keyword">null</span> &amp;&amp; remoteTimestamp.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">65</span>:                 map.put(Constants.REMOTE_TIMESTAMP_KEY, remoteMap.get(Constants.TIMESTAMP_KEY));</span><br /><span class="line"><span class="number">66</span>:             }</span><br /><span class="line"><span class="number">67</span>:             <span class="comment">// Combine filters and listeners on Provider and Consumer 合并 filter 和 listener</span></span><br /><span class="line"><span class="number">68</span>:             String remoteFilter = remoteMap.get(Constants.REFERENCE_FILTER_KEY);</span><br /><span class="line"><span class="number">69</span>:             String localFilter = localMap.get(Constants.REFERENCE_FILTER_KEY);</span><br /><span class="line"><span class="number">70</span>:             <span class="keyword">if</span> (remoteFilter != <span class="keyword">null</span> &amp;&amp; remoteFilter.length() &gt; <span class="number">0</span></span><br /><span class="line"><span class="number">71</span>:                     &amp;&amp; localFilter != <span class="keyword">null</span> &amp;&amp; localFilter.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">72</span>:                 localMap.put(Constants.REFERENCE_FILTER_KEY, remoteFilter + <span class="string">","</span> + localFilter);</span><br /><span class="line"><span class="number">73</span>:             }</span><br /><span class="line"><span class="number">74</span>:             String remoteListener = remoteMap.get(Constants.INVOKER_LISTENER_KEY);</span><br /><span class="line"><span class="number">75</span>:             String localListener = localMap.get(Constants.INVOKER_LISTENER_KEY);</span><br /><span class="line"><span class="number">76</span>:             <span class="keyword">if</span> (remoteListener != <span class="keyword">null</span> &amp;&amp; remoteListener.length() &gt; <span class="number">0</span></span><br /><span class="line"><span class="number">77</span>:                     &amp;&amp; localListener != <span class="keyword">null</span> &amp;&amp; localListener.length() &gt; <span class="number">0</span>) {</span><br /><span class="line"><span class="number">78</span>:                 localMap.put(Constants.INVOKER_LISTENER_KEY, remoteListener + <span class="string">","</span> + localListener);</span><br /><span class="line"><span class="number">79</span>:             }</span><br /><span class="line"><span class="number">80</span>:         }</span><br /><span class="line"><span class="number">81</span>:</span><br /><span class="line"><span class="number">82</span>:         <span class="comment">// 清空原有配置，使用合并的配置覆盖</span></span><br /><span class="line"><span class="number">83</span>:         <span class="keyword">return</span> remoteUrl.clearParameters().addParameters(map);</span><br /><span class="line"><span class="number">84</span>:     }</span><br /><span class="line"><span class="number">85</span>:</span><br /><span class="line"><span class="number">86</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>将&nbsp;<code>localMap</code>&nbsp;和&nbsp;<code>remoteUrl.parameters</code>&nbsp;<strong>合并</strong>成&nbsp;<code>map</code>&nbsp;，大多数以<strong>前者</strong>为主【第 12 至 41 行】，部分<strong>指定</strong>以后者为主【第 43 至 80 行】。</li>
<li>将合并的&nbsp;<code>map</code>&nbsp;的结果，<strong>覆盖</strong>设置到&nbsp;<code>remoteUrl</code>&nbsp;中。</li>
</ul>
</div>