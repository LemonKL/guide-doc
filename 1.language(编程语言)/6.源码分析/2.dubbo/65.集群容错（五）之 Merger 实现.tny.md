<header class="article-header">
<h1 class="article-title">集群容错（五）之 Merger 实现</h1>
</header>
<div class="article-entry">
<blockquote>
<p>本文基于 Dubbo 2.6.1 版本，望知悉。</p>
</blockquote>
<h1 id="1-概述">1. 概述</h1>
<p>本文接&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-4-impl-loadbalance/?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（四）之 LoadBalance 实现》</a>&nbsp;一文，分享&nbsp;<code>dubbo-cluster</code>模块，&nbsp;<code>merger</code>&nbsp;包，<strong>各种 Merger 实现类</strong>。</p>
<p>Merger 相关类，如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Dubbo/2019_04_20/01.png" alt="Merger 相关类" /></p>
<p>我们可以看到，目前一共有<strong>两部分</strong>：</p>
<ul>
<li>Merger 以及其实现类。</li>
<li>MergerCluster 以及其 MergerClusterInvoker</li>
</ul>
<blockquote>
<p>老艿艿：本文对应&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 分组聚合》</a>&nbsp;文档。</p>
</blockquote>
<h1 id="2-Merger">2. Merger</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.Merger</code>&nbsp;，Merger&nbsp;<strong>接口</strong>，提供接口方法，将<strong>对象数组</strong>合并成<strong>一个对象</strong>。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="meta">@SPI</span></span><br /><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Merger</span>&lt;<span class="title">T</span>&gt; </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 合并 T 数组，返回合并后的 T 对象</span></span><br /><span class="line"><span class="comment">     *</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@param</span> items T 数组</span></span><br /><span class="line"><span class="comment">     * <span class="doctag">@return</span> T 对象</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="function">T <span class="title">merge</span><span class="params">(T... items)</span></span>;</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li><code>@SPI</code>&nbsp;注解，Dubbo SPI&nbsp;<strong>拓展点</strong>，无默认值。</li>
</ul>
<h2 id="2-1-Merger-实现类">2.1 Merger 实现类</h2>
<p>Merger 内置<strong>十二</strong>个实现类，从代码上看基本类似。我们以 MapMerger 和 ShortArrayMerger 作为例子。</p>
<h3 id="2-1-1-MapMerger">2.1.1 MapMerger</h3>
<p><code>com.alibaba.dubbo.rpc.cluster.merger.MapMerger</code>&nbsp;，实现 Merger 接口，Map Merger 实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMerger</span> <span class="keyword">implements</span> <span class="title">Merger</span>&lt;<span class="title">Map</span>&lt;?, ?&gt;&gt; </span>{</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> Map&lt;?, ?&gt; merge(Map&lt;?, ?&gt;... items) {</span><br /><span class="line">        <span class="keyword">if</span> (items.length == <span class="number">0</span>) {</span><br /><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 创建结果 Map</span></span><br /><span class="line">        Map&lt;Object, Object&gt; result = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br /><span class="line">        <span class="comment">// 合并多个 Map</span></span><br /><span class="line">        <span class="keyword">for</span> (Map&lt;?, ?&gt; item : items) {</span><br /><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span>) {</span><br /><span class="line">                result.putAll(item);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">return</span> result;</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="2-1-2-ShortArrayMerger">2.1.2 ShortArrayMerger</h3>
<p><code>com.alibaba.dubbo.rpc.cluster.merger.ShortArrayMerger</code>&nbsp;，实现 Merger 接口，Short 数组 Merger 实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line">public class ShortArrayMerger implements Merger&lt;short[]&gt; {</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">short</span>[] merge(<span class="keyword">short</span>[]... items) {</span><br /><span class="line">        <span class="comment">// 计算合并后的数组大小</span></span><br /><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br /><span class="line">        <span class="keyword">for</span> (<span class="keyword">short</span>[] array : items) {</span><br /><span class="line">            total += array.length;</span><br /><span class="line">        }</span><br /><span class="line">        <span class="comment">// 创建结果数组</span></span><br /><span class="line">        <span class="keyword">short</span>[] result = <span class="keyword">new</span> <span class="keyword">short</span>[total];</span><br /><span class="line">        <span class="comment">// 合并多个数组</span></span><br /><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br /><span class="line">        <span class="keyword">for</span> (<span class="keyword">short</span>[] array : items) {</span><br /><span class="line">            <span class="keyword">for</span> (<span class="keyword">short</span> item : array) {</span><br /><span class="line">                result[index++] = item;</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">return</span> result;</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="2-2-MergerFactory">2.2 MergerFactory</h2>
<p><code>com.alibaba.dubbo.rpc.cluster.merger.MergerFactory</code>&nbsp;，Merger 工厂类，提供&nbsp;<code>#getMerger(Class&lt;T&gt; returnType)</code>&nbsp;方法，获得<strong>指定类</strong>对应的 Merger 对象。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergerFactory</span> </span>{</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * Merger 对象缓存</span></span><br /><span class="line"><span class="comment">     */</span></span><br /><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Merger&lt;?&gt;&gt; mergerCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Merger&lt;?&gt;&gt;();</span><br /><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Merger&lt;T&gt; <span class="title">getMerger</span><span class="params">(Class&lt;T&gt; returnType)</span> </span>{</span><br /><span class="line">        Merger result;</span><br /><span class="line">        <span class="comment">// 数组类型</span></span><br /><span class="line">        <span class="keyword">if</span> (returnType.isArray()) {</span><br /><span class="line">            Class type = returnType.getComponentType();</span><br /><span class="line">            <span class="comment">// 从缓存中获得 Merger 对象</span></span><br /><span class="line">            result = mergerCache.get(type);</span><br /><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) {</span><br /><span class="line">                loadMergers();</span><br /><span class="line">                result = mergerCache.get(type);</span><br /><span class="line">            }</span><br /><span class="line">            <span class="comment">// 获取不到，使用 ArrayMerger</span></span><br /><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; !type.isPrimitive()) {</span><br /><span class="line">                result = ArrayMerger.INSTANCE;</span><br /><span class="line">            }</span><br /><span class="line">        <span class="comment">// 普通类型</span></span><br /><span class="line">        } <span class="keyword">else</span> {</span><br /><span class="line">            <span class="comment">// 从缓存中获得 Merger 对象</span></span><br /><span class="line">            result = mergerCache.get(returnType);</span><br /><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) {</span><br /><span class="line">                loadMergers();</span><br /><span class="line">                result = mergerCache.get(returnType);</span><br /><span class="line">            }</span><br /><span class="line">        }</span><br /><span class="line">        <span class="keyword">return</span> result;</span><br /><span class="line">    }</span><br /><br /><span class="line">    <span class="comment">/**</span></span><br /><span class="line"><span class="comment">     * 初始化所有的 Merger 拓展对象，到 mergerCache 缓存中。</span></span><br /><span class="line"><span class="comment">      */</span></span><br /><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadMergers</span><span class="params">()</span> </span>{</span><br /><span class="line">        Set&lt;String&gt; names = ExtensionLoader.getExtensionLoader(Merger.class).getSupportedExtensions();</span><br /><span class="line">        <span class="keyword">for</span> (String name : names) {</span><br /><span class="line">            Merger m = ExtensionLoader.getExtensionLoader(Merger.class).getExtension(name);</span><br /><span class="line">            mergerCache.putIfAbsent(ReflectUtils.getGenericClass(m.getClass()), m);</span><br /><span class="line">        }</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<h1 id="3-MergeableCluster">3. MergeableCluster</h1>
<p><code>com.alibaba.dubbo.rpc.cluster.support.MergeableCluster</code>&nbsp;，实现 Cluster 接口，分组聚合 Cluster 实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeableCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>{</span><br /><br /><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"mergeable"</span>;</span><br /><br /><span class="line">    <span class="meta">@Override</span></span><br /><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MergeableClusterInvoker&lt;T&gt;(directory);</span><br /><span class="line">    }</span><br /><br /><span class="line">}</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>对应 Invoker 实现类为 MergeableClusterInvoker 。</li>
</ul>
<p>Merger 的使用，<strong>需要设置 Cluster 的实现类为 MergeableCluster</strong>&nbsp;。但是呢，它的配置方式，和其他 Cluster 实现类不同。</p>
<ul>
<li>使用方式，参见&nbsp;<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html" target="_blank" rel="external nofollow noopener noreferrer">《Dubbo 用户指南 &mdash;&mdash; 分组聚合》</a>&nbsp;文档。</li>
<li>原因，参见&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory?self">《精尽 Dubbo 源码解析 &mdash;&mdash; 集群容错（三）之 Directory 实现》</a>&nbsp;的&nbsp;<a href="http://svip.iocoder.cn/Dubbo/cluster-5-impl-merger/">「4.3.3.3 toMergeMethodInvokerMap」</a>&nbsp;。</li>
</ul>
<h2 id="3-1-MergeableClusterInvoker">3.1 MergeableClusterInvoker</h2>
<p><code>com.alibaba.dubbo.rpc.cluster.support.MergeableClusterInvoker</code>&nbsp;，实现 Invoker 接口，MergeableCluster Invoker 实现类。代码如下：</p>
<figure class="highlight java">
<table>
<tbody>
<tr>
<td class="code">
<pre><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * Directory$Adaptive 对象</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Directory&lt;T&gt; directory;</span><br /><span class="line"><span class="comment">/**</span></span><br /><span class="line"><span class="comment"> * ExecutorService 对象，并且为 CachedThreadPool 。</span></span><br /><span class="line"><span class="comment"> */</span></span><br /><span class="line"><span class="keyword">private</span> ExecutorService executor = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"mergeable-cluster-executor"</span>, <span class="keyword">true</span>));</span><br /><br /><span class="line">  <span class="number">1</span>: <span class="meta">@Override</span></span><br /><span class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>{</span><br /><span class="line">  <span class="number">3</span>:     <span class="comment">// 获得 Invoker 集合</span></span><br /><span class="line">  <span class="number">4</span>:     List&lt;Invoker&lt;T&gt;&gt; invokers = directory.list(invocation);</span><br /><span class="line">  <span class="number">5</span>:     <span class="comment">// 获得 Merger 拓展名</span></span><br /><span class="line">  <span class="number">6</span>:     String merger = getUrl().getMethodParameter(invocation.getMethodName(), Constants.MERGER_KEY);</span><br /><span class="line">  <span class="number">7</span>:     <span class="comment">// 若果未配置拓展，直接调用首个可用的 Invoker 对象</span></span><br /><span class="line">  <span class="number">8</span>:     <span class="keyword">if</span> (ConfigUtils.isEmpty(merger)) { <span class="comment">// If a method doesn't have a merger, only invoke one Group</span></span><br /><span class="line">  <span class="number">9</span>:         <span class="keyword">for</span> (<span class="keyword">final</span> Invoker&lt;T&gt; invoker : invokers) {</span><br /><span class="line"> <span class="number">10</span>:             <span class="keyword">if</span> (invoker.isAvailable()) {</span><br /><span class="line"> <span class="number">11</span>:                 <span class="keyword">return</span> invoker.invoke(invocation);</span><br /><span class="line"> <span class="number">12</span>:             }</span><br /><span class="line"> <span class="number">13</span>:         }</span><br /><span class="line"> <span class="number">14</span>:         <span class="keyword">return</span> invokers.iterator().next().invoke(invocation);</span><br /><span class="line"> <span class="number">15</span>:     }</span><br /><span class="line"> <span class="number">16</span>: </span><br /><span class="line"> <span class="number">17</span>:     <span class="comment">// 通过反射，获得返回类型</span></span><br /><span class="line"> <span class="number">18</span>:     Class&lt;?&gt; returnType;</span><br /><span class="line"> <span class="number">19</span>:     <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">20</span>:         returnType = getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes()).getReturnType();</span><br /><span class="line"> <span class="number">21</span>:     } <span class="keyword">catch</span> (NoSuchMethodException e) {</span><br /><span class="line"> <span class="number">22</span>:         returnType = <span class="keyword">null</span>;</span><br /><span class="line"> <span class="number">23</span>:     }</span><br /><span class="line"> <span class="number">24</span>: </span><br /><span class="line"> <span class="number">25</span>:     <span class="comment">// 提交线程池，并行执行，发起 RPC 调用，并添加到 results 中</span></span><br /><span class="line"> <span class="number">26</span>:     Map&lt;String, Future&lt;Result&gt;&gt; results = <span class="keyword">new</span> HashMap&lt;String, Future&lt;Result&gt;&gt;();</span><br /><span class="line"> <span class="number">27</span>:     <span class="keyword">for</span> (<span class="keyword">final</span> Invoker&lt;T&gt; invoker : invokers) {</span><br /><span class="line"> <span class="number">28</span>:         Future&lt;Result&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;Result&gt;() {</span><br /><span class="line"> <span class="number">29</span>:             <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> </span>{</span><br /><span class="line"> <span class="number">30</span>:                 <span class="comment">// RPC 调用</span></span><br /><span class="line"> <span class="number">31</span>:                 <span class="keyword">return</span> invoker.invoke(<span class="keyword">new</span> RpcInvocation(invocation, invoker));</span><br /><span class="line"> <span class="number">32</span>:             }</span><br /><span class="line"> <span class="number">33</span>:         });</span><br /><span class="line"> <span class="number">34</span>:         results.put(invoker.getUrl().getServiceKey(), future);</span><br /><span class="line"> <span class="number">35</span>:     }</span><br /><span class="line"> <span class="number">36</span>: </span><br /><span class="line"> <span class="number">37</span>:     <span class="comment">// 阻塞等待执行执行结果，并添加到 resultList 中</span></span><br /><span class="line"> <span class="number">38</span>:     List&lt;Result&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Result&gt;(results.size());</span><br /><span class="line"> <span class="number">39</span>:     <span class="keyword">int</span> timeout = getUrl().getMethodParameter(invocation.getMethodName(), Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br /><span class="line"> <span class="number">40</span>:     <span class="keyword">for</span> (Map.Entry&lt;String, Future&lt;Result&gt;&gt; entry : results.entrySet()) {</span><br /><span class="line"> <span class="number">41</span>:         Future&lt;Result&gt; future = entry.getValue();</span><br /><span class="line"> <span class="number">42</span>:         <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">43</span>:             Result r = future.get(timeout, TimeUnit.MILLISECONDS);</span><br /><span class="line"> <span class="number">44</span>:             <span class="keyword">if</span> (r.hasException()) { <span class="comment">// 异常 Result ，打印错误日志，忽略</span></span><br /><span class="line"> <span class="number">45</span>:                 log.error(<span class="keyword">new</span> StringBuilder(<span class="number">32</span>).append(<span class="string">"Invoke "</span>).append(getGroupDescFromServiceKey(entry.getKey())).append(<span class="string">" failed: "</span>).append(r.getException().getMessage()).toString(), r.getException());</span><br /><span class="line"> <span class="number">46</span>:             } <span class="keyword">else</span> { <span class="comment">// 正常 Result ，添加到 resultList 中</span></span><br /><span class="line"> <span class="number">47</span>:                 resultList.add(r);</span><br /><span class="line"> <span class="number">48</span>:             }</span><br /><span class="line"> <span class="number">49</span>:         } <span class="keyword">catch</span> (Exception e) { <span class="comment">// 异常，抛出 RpcException 异常</span></span><br /><span class="line"> <span class="number">50</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="keyword">new</span> StringBuilder(<span class="number">32</span>).append(<span class="string">"Failed to invoke service "</span>).append(entry.getKey()).append(<span class="string">": "</span>).append(e.getMessage()).toString(), e);</span><br /><span class="line"> <span class="number">51</span>:         }</span><br /><span class="line"> <span class="number">52</span>:     }</span><br /><span class="line"> <span class="number">53</span>: </span><br /><span class="line"> <span class="number">54</span>:     <span class="comment">// 结果大小为空，返回空的 RpcResult</span></span><br /><span class="line"> <span class="number">55</span>:     <span class="keyword">if</span> (resultList.isEmpty()) {</span><br /><span class="line"> <span class="number">56</span>:         <span class="keyword">return</span> <span class="keyword">new</span> RpcResult((Object) <span class="keyword">null</span>);</span><br /><span class="line"> <span class="number">57</span>:     <span class="comment">// 结果大小为 1 ，返回首个 RpcResult</span></span><br /><span class="line"> <span class="number">58</span>:     } <span class="keyword">else</span> <span class="keyword">if</span> (resultList.size() == <span class="number">1</span>) {</span><br /><span class="line"> <span class="number">59</span>:         <span class="keyword">return</span> resultList.iterator().next();</span><br /><span class="line"> <span class="number">60</span>:     }</span><br /><span class="line"> <span class="number">61</span>:     <span class="comment">// 返回类型为 void ，返回空的 RpcResult</span></span><br /><span class="line"> <span class="number">62</span>:     <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) {</span><br /><span class="line"> <span class="number">63</span>:         <span class="keyword">return</span> <span class="keyword">new</span> RpcResult((Object) <span class="keyword">null</span>);</span><br /><span class="line"> <span class="number">64</span>:     }</span><br /><span class="line"> <span class="number">65</span>: </span><br /><span class="line"> <span class="number">66</span>:     Object result;</span><br /><span class="line"> <span class="number">67</span>:     <span class="comment">// 【第 1 种】基于合并方法</span></span><br /><span class="line"> <span class="number">68</span>:     <span class="keyword">if</span> (merger.startsWith(<span class="string">"."</span>)) {</span><br /><span class="line"> <span class="number">69</span>:         <span class="comment">// 获得合并方法 Method</span></span><br /><span class="line"> <span class="number">70</span>:         merger = merger.substring(<span class="number">1</span>);</span><br /><span class="line"> <span class="number">71</span>:         Method method;</span><br /><span class="line"> <span class="number">72</span>:         <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">73</span>:             method = returnType.getMethod(merger, returnType);</span><br /><span class="line"> <span class="number">74</span>:         } <span class="keyword">catch</span> (NoSuchMethodException e) {</span><br /><span class="line"> <span class="number">75</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="keyword">new</span> StringBuilder(<span class="number">32</span>).append(<span class="string">"Can not merge result because missing method [ "</span>).append(merger).append(<span class="string">" ] in class [ "</span>).append(returnType.getClass().getName()).append(<span class="string">" ]"</span>).toString());</span><br /><span class="line"> <span class="number">76</span>:         }</span><br /><span class="line"> <span class="number">77</span>:         <span class="comment">// 有 Method ，进行合并</span></span><br /><span class="line"> <span class="number">78</span>:         <span class="keyword">if</span> (method != <span class="keyword">null</span>) {</span><br /><span class="line"> <span class="number">79</span>:             <span class="keyword">if</span> (!Modifier.isPublic(method.getModifiers())) {</span><br /><span class="line"> <span class="number">80</span>:                 method.setAccessible(<span class="keyword">true</span>);</span><br /><span class="line"> <span class="number">81</span>:             }</span><br /><span class="line"> <span class="number">82</span>:             result = resultList.remove(<span class="number">0</span>).getValue();</span><br /><span class="line"> <span class="number">83</span>:             <span class="keyword">try</span> {</span><br /><span class="line"> <span class="number">84</span>:                 <span class="comment">// 方法返回类型匹配，合并时，修改 result</span></span><br /><span class="line"> <span class="number">85</span>:                 <span class="keyword">if</span> (method.getReturnType() != <span class="keyword">void</span>.class &amp;&amp; method.getReturnType().isAssignableFrom(result.getClass())) {</span><br /><span class="line"> <span class="number">86</span>:                     <span class="keyword">for</span> (Result r : resultList) {</span><br /><span class="line"> <span class="number">87</span>:                         result = method.invoke(result, r.getValue());</span><br /><span class="line"> <span class="number">88</span>:                     }</span><br /><span class="line"> <span class="number">89</span>:                 <span class="comment">// 方法返回类型不匹配，合并时，不修改 result</span></span><br /><span class="line"> <span class="number">90</span>:                 } <span class="keyword">else</span> {</span><br /><span class="line"> <span class="number">91</span>:                     <span class="keyword">for</span> (Result r : resultList) {</span><br /><span class="line"> <span class="number">92</span>:                         method.invoke(result, r.getValue());</span><br /><span class="line"> <span class="number">93</span>:                     }</span><br /><span class="line"> <span class="number">94</span>:                 }</span><br /><span class="line"> <span class="number">95</span>:             } <span class="keyword">catch</span> (Exception e) {</span><br /><span class="line"> <span class="number">96</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="keyword">new</span> StringBuilder(<span class="number">32</span>).append(<span class="string">"Can not merge result: "</span>).append(e.getMessage()).toString(), e);</span><br /><span class="line"> <span class="number">97</span>:             }</span><br /><span class="line"> <span class="number">98</span>:         <span class="comment">// 无 Method ，抛出 RpcException 异常</span></span><br /><span class="line"> <span class="number">99</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">100</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="keyword">new</span> StringBuilder(<span class="number">32</span>).append(<span class="string">"Can not merge result because missing method [ "</span>).append(merger).append(<span class="string">" ] in class [ "</span>).append(returnType.getClass().getName()).append(<span class="string">" ]"</span>).toString());</span><br /><span class="line"><span class="number">101</span>:         }</span><br /><span class="line"><span class="number">102</span>:     <span class="comment">// 【第 2 种】基于 Merger</span></span><br /><span class="line"><span class="number">103</span>:     } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">104</span>:         Merger resultMerger;</span><br /><span class="line"><span class="number">105</span>:         <span class="comment">// 【第 2.1 种】根据返回值类型自动匹配 Merger</span></span><br /><span class="line"><span class="number">106</span>:         <span class="keyword">if</span> (ConfigUtils.isDefault(merger)) {</span><br /><span class="line"><span class="number">107</span>:             resultMerger = MergerFactory.getMerger(returnType);</span><br /><span class="line"><span class="number">108</span>:         <span class="comment">// 【第 2.2 种】指定 Merger</span></span><br /><span class="line"><span class="number">109</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">110</span>:             resultMerger = ExtensionLoader.getExtensionLoader(Merger.class).getExtension(merger);</span><br /><span class="line"><span class="number">111</span>:         }</span><br /><span class="line"><span class="number">112</span>:         <span class="comment">// 有 Merger ，进行合并</span></span><br /><span class="line"><span class="number">113</span>:         <span class="keyword">if</span> (resultMerger != <span class="keyword">null</span>) {</span><br /><span class="line"><span class="number">114</span>:             List&lt;Object&gt; rets = <span class="keyword">new</span> ArrayList&lt;Object&gt;(resultList.size());</span><br /><span class="line"><span class="number">115</span>:             <span class="keyword">for</span> (Result r : resultList) {</span><br /><span class="line"><span class="number">116</span>:                 rets.add(r.getValue());</span><br /><span class="line"><span class="number">117</span>:             }</span><br /><span class="line"><span class="number">118</span>:             result = resultMerger.merge(rets.toArray((Object[]) Array.newInstance(returnType, <span class="number">0</span>)));</span><br /><span class="line"><span class="number">119</span>:         <span class="comment">// 无 Merger ，抛出 RpcException 异常</span></span><br /><span class="line"><span class="number">120</span>:         } <span class="keyword">else</span> {</span><br /><span class="line"><span class="number">121</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"There is no merger to merge result."</span>);</span><br /><span class="line"><span class="number">122</span>:         }</span><br /><span class="line"><span class="number">123</span>:     }</span><br /><span class="line"><span class="number">124</span>:     <span class="comment">// 返回 RpcResult 结果</span></span><br /><span class="line"><span class="number">125</span>:     <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(result);</span><br /><span class="line"><span class="number">126</span>: }</span></pre>
</td>
</tr>
</tbody>
</table>
</figure>
<ul>
<li>🙂 看似比较长，实际很易懂。</li>
<li>第 4 行：调用&nbsp;<code>Directory#list(invocation)</code>&nbsp;方法，获得服务 Invoker&nbsp;<strong>集合</strong>。</li>
<li>第 6 行：调用&nbsp;<code>URL#getMethodParameter(methodName, "merger")</code>&nbsp;方法，获得 Merger 拓展名，<strong>方法级</strong>。</li>
<li>第 7 至 15 行：若<strong>未配置</strong>&nbsp;Merger 拓展名，优先调用首个<strong>可用</strong>的 Invoker 对象，其次调用首个 Invoker 对象。</li>
<li>第 17 至 23 行：通过反射，获得调用方法的<strong>返回类型</strong>。</li>
<li>第 25 至 35 行：提交线程池，<strong>并行</strong>执行，发起 RPC 调用，并添加 Future 到&nbsp;<code>results</code>&nbsp;中。</li>
<li>第 37 至 52 行：<strong>阻塞</strong>等待执行结果，并添加到&nbsp;<code>resultList</code>&nbsp;中。<strong>注意</strong>，分成正常 Result、异常 Result（<strong>忽略</strong>）、Exception 三种情况。</li>
<li>第 54 至 56 行：结果大小为<strong>空</strong>，返回<strong>空</strong>的 RpcResult 。</li>
<li>第 57 至 60 行：结果大小为&nbsp;<strong>1</strong>&nbsp;，返回<strong>首个</strong>&nbsp;RpcResult 。</li>
<li>第 61 至 64 行：返回类型为&nbsp;<strong>void</strong>&nbsp;，返回<strong>空</strong>的 RpcResult 。</li>
<li>========== 【<strong>第 1 种</strong>】基于 Method 合并==========</li>
<li>第 68 行：若&nbsp;<code>merger</code>&nbsp;为&nbsp;<code>"."</code>&nbsp;开头，指定合并方法，将调用返回结果的指定方法进行合并，合并方法的参数类型必须是返回结果类型<strong>本身</strong>。</li>
<li>第 69 至 76 行：调用&nbsp;<code>Class#getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>&nbsp;方法，获得<strong>合并方法 Method</strong>&nbsp;。这个方法，意味着&ldquo;合并方法的参数类型必须是返回结果类型<strong>本身</strong>&rdquo;！！！具体原因，见&nbsp;<a href="https://www.jianshu.com/p/512e2211f84c" target="_blank" rel="external nofollow noopener noreferrer">《dubbo源码-集群容错之MergeableCluster》</a>&nbsp;，搜索&nbsp;<code>"在条件分支if ( merger.startsWith(".") ) {}"</code>&nbsp;。</li>
<li>第 77 至 97 行：<strong>有</strong>&nbsp;Method ，<strong>循环</strong>调用&nbsp;<code>Method#invoke(Object obj, Object... args)</code>&nbsp;方法，进行合并。</li>
<li>第 98 至 101 行：<strong>无</strong>&nbsp;Method ，抛出 RpcException 异常。</li>
<li>========== 【<strong>第 2 种</strong>】基于 Merger 合并 ==========</li>
<li>【第&nbsp;<strong>2.1</strong>&nbsp;种】第 105 至 107 行：当&nbsp;<code>merger</code>&nbsp;为&nbsp;<code>"default"</code>&nbsp;或&nbsp;<code>"true"</code>&nbsp;时，调用&nbsp;<code>MergerFactory#getMerger(Class&lt;T&gt; returnType)</code>&nbsp;方法，根据<strong>返回值类型</strong>自动匹配 Merger 。</li>
<li>【第&nbsp;<strong>2.2</strong>&nbsp;种】第 108 至 111 行：调用&nbsp;<code>ExtensionLoader#getExtension(merger)</code>&nbsp;方法啊，获得<strong>指定</strong>&nbsp;Merger 。</li>
<li>第 112 至 118 行：<strong>有</strong>&nbsp;Merger ，<strong>循环</strong>调用&nbsp;<code>Merger#merge(T... items)</code>&nbsp;方法，进行合并。</li>
<li>第 119 至 122 行：<strong>无</strong>&nbsp;Method ，抛出 RpcException 异常。</li>
</ul>
</div>