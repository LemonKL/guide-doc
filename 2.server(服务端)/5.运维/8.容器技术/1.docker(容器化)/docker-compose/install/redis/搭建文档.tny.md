<div id="content_views" class="markdown_views">
<!-- flowchart 箭头图标 勿删 -->
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
<path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p>前言:本文记录了如何使用docker-compose和redis官方镜像和第三方redis-trib镜像组建3主3从的redis集群并设置密码.踩坑不易,未经本人允许不得转载.</p>

<p></p><div class="toc"><div class="toc">
<ul>
<li><ul>
<li><a href="#一-创建文件结构" rel="nofollow" data-token="5a76a2126754fe09d278c906b38e17d4" target="_self">一 创建文件结构</a></li>
<li><a href="#二-配置redisconf文件" rel="nofollow" data-token="ea3cd9d714f0cb1f4c8c2437822f4a2a" target="_self">二 配置redis.conf文件</a></li>
<li><a href="#三-编写dockerfile" rel="nofollow" data-token="a5485fa9622bea9a93f08d214050f26a" target="_self">三 编写Dockerfile</a></li>
<li><a href="#四-编写docker-composeyml文件" rel="nofollow" data-token="d32cd8358a1e0e52137cc5d73c74e8f6" target="_self">四 编写docker-compose.yml文件</a></li>
<li><a href="#五-启动" rel="nofollow" data-token="18dbf323527b8601115ad4d397bb870d" target="_self">五 启动</a></li>
<li><a href="#六-连接集群" rel="nofollow" data-token="329f0cf1bc6843622db01ba1898006ee" target="_self">六 连接集群</a></li>
<li><a href="#七-验证集群" rel="nofollow" data-token="a5a0d2330148fead87af84872adc8eb9" target="_self">七 验证集群</a></li>
<li><a href="#八-设置集群密码" rel="nofollow" data-token="1bc5aefb5010ea0000cc81909a944596" target="_self">八 设置集群密码</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p></p>



<h2 id="一-创建文件结构"><a name="t0"></a>一 创建文件结构</h2>

<ol>
<li>新建redis文件夹</li>
<li>在redis文件夹下新建docker-compose.yml文件</li>
<li>在redis文件夹下新建slave1到slave6共6个文件夹作为从属结点的文件夹 <br>
<img src="https://img-blog.csdn.net/20180706133455477?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaW55dWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></li>
</ol>



<h2 id="二-配置redisconf文件"><a name="t1"></a>二 配置redis.conf文件</h2>

<ol>
<li>到<a href="http://download.redis.io/redis-stable/redis.conf" rel="nofollow" data-token="65eb1a8373494841d03f3169c1af2f21">http://download.redis.io/redis-stable/redis.conf</a>下载官方redis.conf文件</li>
<li>拷贝到各个slave文件夹下,分别配置如下内容,以端口6061为例(默认为6379)</li>
</ol>



<pre class="prettyprint" name="code"><code class="hljs vala has-numbering" onclick="mdcp.signin(event)"><span class="hljs-preprocessor"># bind 127.0.0.1 //加上注释#</span>
<span class="hljs-keyword">protected</span>-mode no <span class="hljs-comment">//关闭保护模式</span>
port <span class="hljs-number">6061</span>  <span class="hljs-comment">//绑定自定义端口</span>
<span class="hljs-preprocessor">#daemonize yes //禁止redis后台运行</span>
pidfile /<span class="hljs-keyword">var</span>/run/redis_6061.pid 
cluster-enabled yes <span class="hljs-comment">//开启集群 把注释#去掉</span>
cluster-config-file nodes_6061.conf <span class="hljs-comment">//集群的配置 配置文件首次启动自动生成 </span>

<p>配置文件是最容易出问题的,这里面有一些注意事项:</p>

<ul>
<li><p>requirepass和masterauth不能启用 <br>
因为使用redis-trib连接集群时是不能指定密码的,如果开启了requirepass或者masterauth会导致集群连接失败,所以应该等集群创建好后再修改密码,这个后文会说</p></li>
<li><p>bind <br>
表示设置redis监听哪个ip,设置了监听之后,只有使用这些ip才能访问这个redis服务,不指定则默认所有ip都能访问该redis服务 <br>
注意:这里的ip指的是redis的ip而非访问方的ip,bind并不直接限制哪些ip能够访问redis,显示ip访问是限制监听后的效果,如果想限制ip访问应使用Linux防火墙功能. <br>
比方说,在生产条件下的redis服务器有3个ip(外网ip 122.122.122.122,局域网ip192.128.0.1,本地ip127.0.0.1),则为了安全,bind后面只应该写局域网ip和本地ip,这样就只有局域网用户(包括本机)可以通过192.128.0.1访问redis服务,间接起到限制ip访问的作用.</p></li>
<li><p>protected-mode</p>

<ul><li>作用: <br>
禁止公网访问redis cache，加强redis安全的</li>
<li>启用条件: <br>
<ol><li>没有bind IP</li>
<li>没有设置requirepass访问密码</li></ol></li>
<li>解释: <br>
由于前面提及的原因,保护模式会开启导致无法通过公网访问,故这里需要关闭保护模式,但注意集群建好后要及时添加密码,增强安全性</li></ul></li>
<li><p>daemonize 和 pidfile <br>
实测开启守护模式(daemonize yes)容器会启动失败,因为是使用docker,所以前台启动也没什么关系,pidfile的文件名和端口号一致是一个良好的习惯</p></li>
</ul>

<h2 id="三-编写dockerfile"><a name="t2"></a>三 编写Dockerfile</h2>

<p>首先先贴出配置,同样以6061端口为例</p>



<pre class="prettyprint" name="code"><code class="hljs vala has-numbering" onclick="mdcp.signin(event)"><span class="hljs-preprocessor">#基础镜像</span>
FROM redis

<span class="hljs-preprocessor">#将自定义conf文件拷入</span>
COPY redis.conf /usr/local/etc/redis/redis.conf

<span class="hljs-preprocessor">#修复时区</span>
RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
RUN echo <span class="hljs-string">'Asia/Shanghai'</span> &gt;/etc/timezone

<span class="hljs-preprocessor">#修改文件权限,使之可以通过config rewrite重写</span>
RUN chmod <span class="hljs-number">777</span> /usr/local/etc/redis/redis.conf

<span class="hljs-preprocessor"># Redis客户端连接端口</span>
EXPOSE <span class="hljs-number">6061</span>
<span class="hljs-preprocessor"># 集群总线端口:redis客户端连接的端口 + 10000</span>
EXPOSE <span class="hljs-number">16061</span>

<span class="hljs-preprocessor">#使用自定义conf启动</span>
CMD [ <span class="hljs-string">"redis-server"</span>, <span class="hljs-string">"/usr/local/etc/redis/redis.conf"</span> ]

<p>注意:</p>

<ol>
<li>集群总线端口 <br>
Redis集群中每个redis实例（可能一台机部署多个实例）会使用两个Tcp端口，一个用于给客户端（redis-cli或应用程序等）使用的端口，另一个是用于集群中实例相互通信的内部总线端口，且第二个端口比第一个端口一定大10000.内部总线端口通信使用特殊协议，以便实现集群内部高带宽低时延的数据交换。所以配置redis实例时只需要指明第一个端口就可以了。 <br>
但是由于我们使用的是docker,所以要将这个端口暴露出来,否则集群无法建立(使用<strong>redis-trib</strong>时会一直显示<code>Waiting for the cluster to join</code>)</li>
<li>修改redis.conf文件权限,否则后面写入访问密码到文件的时候会提示<code>Permission denied</code></li>
<li>修复时区是个人习惯,与本文无关,想了解的可见:<a href="https://blog.csdn.net/alinyua/article/details/80944543" rel="nofollow" data-token="2510882489e4406c7e24026198320ad2">https://blog.csdn.net/alinyua/article/details/80944543</a></li>
</ol>



<h2 id="四-编写docker-composeyml文件"><a name="t3"></a>四 编写docker-compose.yml文件</h2>

<p>先贴出配置如下,没什么好说的,是最简单的配置了</p>



<pre class="prettyprint" name="code"><code class="hljs haml has-numbering" onclick="mdcp.signin(event)">redis-slave1:
build: ./slave1
ports:
-<span class="ruby"> <span class="hljs-number">6061</span><span class="hljs-symbol">:</span><span class="hljs-number">6061</span>
</span>   -<span class="ruby"> <span class="hljs-number">16061</span><span class="hljs-symbol">:</span><span class="hljs-number">16061</span>
</span>redis-slave2:
build: ./slave2
ports:
-<span class="ruby"> <span class="hljs-number">6062</span><span class="hljs-symbol">:</span><span class="hljs-number">6062</span>
</span>   -<span class="ruby"> <span class="hljs-number">16062</span><span class="hljs-symbol">:</span><span class="hljs-number">16062</span>
</span>redis-slave3:
build: ./slave3
ports:
-<span class="ruby"> <span class="hljs-number">6063</span><span class="hljs-symbol">:</span><span class="hljs-number">6063</span>
</span>   -<span class="ruby"> <span class="hljs-number">16063</span><span class="hljs-symbol">:</span><span class="hljs-number">16063</span>
</span>redis-slave4:
build: ./slave4
ports:
-<span class="ruby"> <span class="hljs-number">6064</span><span class="hljs-symbol">:</span><span class="hljs-number">6064</span>
</span>   -<span class="ruby"> <span class="hljs-number">16064</span><span class="hljs-symbol">:</span><span class="hljs-number">16064</span>
</span>redis-slave5:
build: ./slave5
ports:
-<span class="ruby"> <span class="hljs-number">6065</span><span class="hljs-symbol">:</span><span class="hljs-number">6065</span>
</span>   -<span class="ruby"> <span class="hljs-number">16065</span><span class="hljs-symbol">:</span><span class="hljs-number">16065</span>
</span>redis-slave6:
build: ./slave6
ports:
-<span class="ruby"> <span class="hljs-number">6066</span><span class="hljs-symbol">:</span><span class="hljs-number">6066</span>
</span>   -<span class="ruby"> <span class="hljs-number">16066</span><span class="hljs-symbol">:</span><span class="hljs-number">16066</span></span>



<h2 id="五-启动"><a name="t4"></a>五 启动</h2>

<p>在redis目录下(即docker-compose.yml同级目录),运行</p>



<pre class="prettyprint" name="code"><code class="hljs lasso has-numbering" onclick="mdcp.signin(event)">docker<span class="hljs-attribute">-compose</span> up <span class="hljs-attribute">-d</span><div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>再查看容器运行情况</p>



<pre class="prettyprint" name="code"><code class="hljs bash has-numbering" onclick="mdcp.signin(event)">docker ps <span class="hljs-operator">-a</span><div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>结果如下 <br>
<img src="https://img-blog.csdn.net/2018070611063412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaW55dWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br>
这时启动使用redis客户端连接测试一下,我这里使用的是Redis Desktop Manager,注意,此时连接还不需要密码,十分不安全,以6061端口为例,测试结果如下: <br>
<img src="https://img-blog.csdn.net/20180706111321764?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaW55dWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br>
可以看到此时请求访问密码和访问master密码是空白的,另外集群状态是失败 <br>
这个时候使用redis会报<code>"CLUSTERDOWN Hash slot not served"</code>错误</p>



<h2 id="六-连接集群"><a name="t5"></a>六 连接集群</h2>

<p>连接集群非常简单,不需要去修改什么配置,只需要一条docker指令</p>



<pre class="prettyprint" name="code"><code class="hljs brainfuck has-numbering" onclick="mdcp.signin(event)"><span class="hljs-comment">docker</span> <span class="hljs-comment">run</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">rm</span> <span class="hljs-literal">-</span><span class="hljs-comment">it</span> <span class="hljs-comment">zvelo/redis</span><span class="hljs-literal">-</span><span class="hljs-comment">trib</span> <span class="hljs-comment">create</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">replicas</span> <span class="hljs-comment">1</span> <span class="hljs-comment">ip:6061</span> <span class="hljs-comment">ip:6062</span> <span class="hljs-comment">ip:6063</span> <span class="hljs-comment">ip:6064</span> <span class="hljs-comment">ip:6065</span> <span class="hljs-comment">ip:6066</span>
<p>ip替换成实际ip地址,结果如下,中间需要用yes来同意集群方案 <br>
结果如下 <br>
<img src="https://img-blog.csdn.net/2018070611303770?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaW55dWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p>



<h2 id="七-验证集群"><a name="t6"></a>七 验证集群</h2>

<p>输入<code>cluster info</code>查看集群信息,此时已为 <code>ok</code>,再测试一下set和get,另外可以看到,结点会自己切换,并且6061端口set和数据可以在6062端口get到 <br>
<img src="https://img-blog.csdn.net/20180706123701138?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaW55dWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""></p>



<h2 id="八-设置集群密码"><a name="t7"></a>八 设置集群密码</h2>

<ol>
<li>使用redis-trib.rb工具构建集群，集群构建完成前不要配置密码，集群构建完毕再通过config set + config rewrite命令<code>逐个机器</code>设置密码</li>
<li>如果对集群设置密码，那么<code>requirepass和masterauth</code>都需要设置，否则发生主从切换时，就会遇到授权问题</li>
<li>各个节点的<code>密码都必须一致</code>，否则Redirected就会失败</li>
</ol>

<p>具体指令如下:</p>

<ul>
<li>设置masterauth</li>
</ul>



<pre class="prettyprint" name="code"><code class="hljs bash has-numbering" onclick="mdcp.signin(event)">config <span class="hljs-keyword">set</span> masterauth 密码
<ul>
<li>设置requirepass</li>
</ul>



<pre class="prettyprint" name="code"><code class="hljs bash has-numbering" onclick="mdcp.signin(event)">config <span class="hljs-keyword">set</span> requirepass 密码<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<ul>
<li>验证密码,以继续操作</li>
</ul>



<pre class="prettyprint" name="code"><code class="hljs bash has-numbering" onclick="mdcp.signin(event)">auth L<span class="hljs-keyword">in</span>Shen<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<ul>
<li>回写到文件,使其永久生效(如果这里出现Permission denied,则说明Dockerfile少了<code>RUN chmod 777 /usr/local/etc/redis/redis.conf</code>)</li>
</ul>



<pre class="prettyprint" name="code"><code class="hljs  has-numbering" onclick="mdcp.signin(event)">config rewrite<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>如下图 <br>
<img src="https://img-blog.csdn.net/20180706124914345?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaW55dWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br>
然后再使用docker exec指令进入容器内部看一下masterauth和requirepass是否写入到文件里</p>



<pre class="prettyprint" name="code"><code class="hljs bash has-numbering" onclick="mdcp.signin(event)">docker <span class="hljs-keyword">exec</span> -it 容器ID /bin/bash</pre>

<p>cat指令查看</p>



<pre class="prettyprint" name="code"><code class="hljs lua has-numbering" onclick="mdcp.signin(event)">cat /usr/<span class="hljs-keyword">local</span>/etc/redis/redis.conf<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>得到如下图 <br>
<img src="https://img-blog.csdn.net/20180706130231328?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaW55dWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br>
可以看到masterauth和requirepass被追加到文件的最后,即使重启密码也还生效</p>

<p>至此,利用docker-compose组建redis集群结束</p>

<p>可以看到,其实docker-compose起的作用并不大,因为在单机上部署redis集群确实没什么实际意义,但是,你完全可以把slave结点放到不同的服务器上,再通过docker的redis-trib容器来连接,十分灵活和方便.</p>                                    </div>