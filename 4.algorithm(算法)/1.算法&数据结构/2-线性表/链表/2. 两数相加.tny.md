<p>题目：</p>
<p>给出两个&nbsp;非空 的链表用来表示两个非负的整数。</p>
<p>其中，它们各自的位数是按照&nbsp;逆序&nbsp;的方式存储的，并且它们的每个节点只能存储&nbsp;一位&nbsp;数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0&nbsp;开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br />输出：7 -&gt; 0 -&gt; 8<br />原因：342 + 465 = 807</p>
<p>解答：</p>
<div>方法：初等数学</div>
<div>思路</div>
<div>&nbsp;</div>
<div>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>图1，对两数相加方法的可视化: 342 + 465 = 807342+465=807，每个结点都包含一个数字，并且数字按位逆序存储。</div>
<div>&nbsp;</div>
<div>算法</div>
<div>&nbsp;</div>
<div>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1l1 和 l2l2 的表头开始相加。由于每位数字都应当处于 0 \ldots 90&hellip;9 的范围内，我们计算两个数字的和时可能会出现 &ldquo;溢出&rdquo;。例如，5 + 7 = 125+7=12。在这种情况下，我们会将当前位的数值设置为 22，并将进位 carry = 1carry=1 带入下一次迭代。进位 carrycarry 必定是 00 或 11，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 199+9+1=19。</div>
<div>&nbsp;</div>
<div>伪代码如下：</div>
<div>&nbsp;</div>
<div>将当前结点初始化为返回列表的哑结点。</div>
<div>将进位 carrycarry 初始化为 00。</div>
<div>将 pp 和 qq 分别初始化为列表 l1l1 和 l2l2 的头部。</div>
<div>遍历列表 l1l1 和 l2l2 直至到达它们的尾端。</div>
<div>将 xx 设为结点 pp 的值。如果 pp 已经到达 l1l1 的末尾，则将其值设置为 00。</div>
<div>将 yy 设为结点 qq 的值。如果 qq 已经到达 l2l2 的末尾，则将其值设置为 00。</div>
<div>设定 sum = x + y + carrysum=x+y+carry。</div>
<div>更新进位的值，carry = sum / 10carry=sum/10。</div>
<div>创建一个数值为 (sum \bmod 10)(summod10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。</div>
<div>同时，将 pp 和 qq 前进到下一个结点。</div>
<div>检查 carry = 1carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 11 的新结点。</div>
<div>返回哑结点的下一个结点。</div>
<div>请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。</div>
<div>&nbsp;</div>
<div>请特别注意以下情况：</div>
<div>&nbsp;</div>
<div>测试用例 说明</div>
<div>l1=[0,1]l1=[0,1]，l2=[0,1,2]l2=[0,1,2] 当一个列表比另一个列表长时</div>
<div>l1=[]l1=[]，l2=[0,1]l2=[0,1] 当一个列表为空时，即出现空列表</div>
<div>l1=[9,9]l1=[9,9]，l2=[1]l2=[1] 求和运算最后可能出现额外的进位，这一点很容易被遗忘</div>
<div>Java</div>
<div>public ListNode addTwoNumbers(ListNode l1, ListNode l2) {</div>
<div>&nbsp; &nbsp; ListNode dummyHead = new ListNode(0);</div>
<div>&nbsp; &nbsp; ListNode p = l1, q = l2, curr = dummyHead;</div>
<div>&nbsp; &nbsp; int carry = 0;</div>
<div>&nbsp; &nbsp; while (p != null || q != null) {</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; int x = (p != null) ? p.val : 0;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; int y = (q != null) ? q.val : 0;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; int sum = carry + x + y;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; carry = sum / 10;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; curr.next = new ListNode(sum % 10);</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; curr = curr.next;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; if (p != null) p = p.next;</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; if (q != null) q = q.next;</div>
<div>&nbsp; &nbsp; }</div>
<div>&nbsp; &nbsp; if (carry &gt; 0) {</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; curr.next = new ListNode(carry);</div>
<div>&nbsp; &nbsp; }</div>
<div>&nbsp; &nbsp; return dummyHead.next;</div>
<div>}</div>
<div>复杂度分析</div>
<div>&nbsp;</div>
<div>时间复杂度：O(\max(m, n))O(max(m,n))，假设 mm 和 nn 分别表示 l1l1 和 l2l2 的长度，上面的算法最多重复 \max(m, n)max(m,n) 次。</div>
<div>&nbsp;</div>
<div>空间复杂度：O(\max(m, n))O(max(m,n))， 新列表的长度最多为 \max(m,n) + 1max(m,n)+1。</div>
<div>&nbsp;</div>
<div>拓展</div>
<div>&nbsp;</div>
<div>如果链表中的数字不是按逆序存储的呢？例如：</div>
<div>&nbsp;</div>
<div>(3 \to 4 \to 2) + (4 \to 6 \to 5) = 8 \to 0 \to 7</div>
<div>(3&rarr;4&rarr;2)+(4&rarr;6&rarr;5)=8&rarr;0&rarr;7</div>
<div>&nbsp;</div>
<div>作者：LeetCode</div>
<div>链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-xiang-jia-by-leetcode/</div>
<div>来源：力扣（LeetCode）</div>
<div>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div>
<p>来源：力扣（LeetCode）<br />链接：https://leetcode-cn.com/problems/add-two-numbers<br />著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>