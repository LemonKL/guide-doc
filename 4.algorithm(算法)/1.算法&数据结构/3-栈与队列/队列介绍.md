**1.先入先出的数据结构**

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/14/screen-shot-2018-05-03-at-151021.png)

在 FIFO 数据结构中，将

首先处理添加到队列中的第一个元素
。

如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在

队列的末尾
。 删除（delete）操作也被称为出队（dequeue)。 你只能移除

第一个元素
。

### 示例 - 队列

1. 入队：您可以单击下面的

Enqueue
以查看如何将新元素 6 添加到队列中。

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/14/screen-shot-2018-05-02-at-174355.png) Enqueue

2. 出队：您可以单击下面的

Dequeue
以查看将删除哪个元素。

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/14/screen-shot-2018-05-02-at-172840.png) Dequeue

**2.队列 - 实现**
为了实现队列，我们可以使用动态数组和指向队列头部的索引。

如上所述，队列应支持两种操作：入队和出队。入队会向队列追加一个新元素，而出队会删除第一个元素。 所以我们需要一个索引来指出起点。

这是一个供你参考的实现：

```
// "static void main" must be defined in a public class. class MyQueue { // store elements private List<Integer> data; // a pointer to indicate the start position private int p_start; public MyQueue() { data = new ArrayList<Integer>(); p_start = 0; } //*/* Insert an element into the queue. Return true if the operation is successful. /*/ public boolean enQueue(int x) { data.add(x); return true; }; //*/* Delete an element from the queue. Return true if the operation is successful. /*/ public boolean deQueue() { if (isEmpty() == true) { return false; } p_start++; return true; } //*/* Get the front item from the queue. /*/ public int Front() { return data.get(p_start); } //*/* Checks whether the queue is empty or not. /*/ public boolean isEmpty() { return p_start >= data.size(); } }; public class Main { public static void main(String[] args) { MyQueue q = new MyQueue(); q.enQueue(5); q.enQueue(3); if (q.isEmpty() == false) { System.out.println(q.Front()); } q.deQueue(); if (q.isEmpty() == false) { System.out.println(q.Front()); } q.deQueue(); if (q.isEmpty() == false) { System.out.println(q.Front()); } } }
```

### 缺点

上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/21/screen-shot-2018-07-21-at-153558.png)

让我们考虑一种情况，即我们只能分配一个最大长度为 5 的数组。当我们只添加少于 5 个元素时，我们的解决方案很有效。 例如，如果我们只调用入队函数四次后还想要将元素 10 入队，那么我们可以成功。

但是我们不能接受更多的入队请求，这是合理的，因为现在队列已经满了。但是如果我们将一个元素出队呢？

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/21/screen-shot-2018-07-21-at-153713.png)
实际上，在这种情况下，我们应该能够再接受一个元素。

循环队列
此前，我们提供了一种简单但低效的队列实现。

更有效的方法是使用循环队列。 具体来说，我们可以使用

固定大小的数组
和

两个指针
来指示起始位置和结束位置。 目的是

重用
我们之前提到的

被浪费的存储
。

让我们通过一个示例来查看循环队列的工作原理。 你应该注意我们

入队
或

出队
元素时使用的策略。

![Current]()

6 / 17

仔细检查动画，找出我们用来检查队列是

空
还是

满
的策略。

下一个练习，我们将让你自己尝试实现循环队列，之后会提供给你一个解决方案。

**3.循环队列 - 实现**
在循环队列中，我们使用一个

数组
和两个指针（

head
和

tail
）。

head
表示队列的起始位置，

tail
表示队列的结束位置。

这里我们提供了代码供你参考：

```
class MyCircularQueue { private int[] data; private int head; private int tail; private int size; //*/* Initialize your data structure here. Set the size of the queue to be k. /*/ public MyCircularQueue(int k) { data = new int[k]; head = -1; tail = -1; size = k; } //*/* Insert an element into the circular queue. Return true if the operation is successful. /*/ public boolean enQueue(int value) { if (isFull() == true) { return false; } if (isEmpty() == true) { head = 0; } tail = (tail + 1) % size; data[tail] = value; return true; } //*/* Delete an element from the circular queue. Return true if the operation is successful. /*/ public boolean deQueue() { if (isEmpty() == true) { return false; } if (head == tail) { head = -1; tail = -1; return true; } head = (head + 1) % size; return true; } //*/* Get the front item from the queue. /*/ public int Front() { if (isEmpty() == true) { return -1; } return data[head]; } //*/* Get the last item from the queue. /*/ public int Rear() { if (isEmpty() == true) { return -1; } return data[tail]; } //*/* Checks whether the circular queue is empty or not. /*/ public boolean isEmpty() { return head == -1; } //*/* Checks whether the circular queue is full or not. /*/ public boolean isFull() { return ((tail + 1) % size) == head; } } //*/* /* Your MyCircularQueue object will be instantiated and called as such: /* MyCircularQueue obj = new MyCircularQueue(k); /* boolean param_1 = obj.enQueue(value); /* boolean param_2 = obj.deQueue(); /* int param_3 = obj.Front(); /* int param_4 = obj.Rear(); /* boolean param_5 = obj.isEmpty(); /* boolean param_6 = obj.isFull(); /*/
```

4.队列 - 用法
大多数流行语言都提供内置的队列库，因此您无需重新发明轮子。

如前所述，队列有两个重要的操作，

入队 enqueue
和

出队 dequeue
。 此外，我们应该能够

获得队列中的第一个元素
，因为应该首先处理它。

下面是使用内置队列库及其常见操作的一些示例：

```
// "static void main" must be defined in a public class. public class Main { public static void main(String[] args) { // 1. Initialize a queue. Queue<Integer> q = new LinkedList(); // 2. Get the first element - return null if queue is empty. System.out.println("The first element is: " + q.peek()); // 3. Push new element. q.offer(5); q.offer(13); q.offer(8); q.offer(6); // 4. Pop an element. q.poll(); // 5. Get the first element. System.out.println("The first element is: " + q.peek()); // 7. Get the size of the queue. System.out.println("The size is: " + q.size()); } }
```

参考：

[https://leetcode-cn.com/explore/learn/card/queue-stack/216/queue-first-in-first-out-data-structure/867/](https://leetcode-cn.com/explore/learn/card/queue-stack/216/queue-first-in-first-out-data-structure/867/)