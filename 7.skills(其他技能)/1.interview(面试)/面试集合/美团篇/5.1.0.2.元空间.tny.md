<div id="post_detail">
	<div class="post">
		<div class="posthead">
			<h2>
				<a id="cb_post_title_url" class="singleposttitle" href="https://www.cnblogs.com/dennyzhangdd/p/6770188.html">JDK8-废弃永久代（PermGen）迎来元空间（Metaspace）</a>
			</h2>
 			Posted on <span id="post-date">2017-04-27 11:01</span> <a href="https://www.cnblogs.com/dennyzhangdd/">只会一点java</a> 阅读(<span id="post_view_count">13869</span>) 评论(<span id="post_comment_count">6</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6770188" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6770188);return false;">收藏</a>
			<script type="text/javascript">var allowComments=true,cb_blogId=283243,cb_entryId=6770188,cb_blogApp=currentBlogApp,cb_blogUserGuid='5c933f56-2653-e311-8d02-90b11c0b17d6',cb_entryCreatedDate='2017/4/27 11:01:00';loadViewCount(cb_entryId);var cb_postType=1;var isMarkdown=false;</script>
			
		</div>
		<div class="postbody"><div id="cnblogs_post_body" class="blogpost-body"><a name="_labelTop"></a><div id="navCategory"><p style="font-size:18px"><b>目录</b></p><ul><li><a href="#_label0">一、背景</a><ul><li><a href="#_label0_0">1.1 永久代（PermGen）在哪里？</a></li><li><a href="#_label0_1">1.2 JDK8永久代的废弃</a></li></ul></li><li><a href="#_label1">&nbsp;二、为什么废弃永久代（PermGen）</a><ul><li><a href="#_label1_0">&nbsp;2.1 官方说明</a></li><li><a href="#_label1_1">Motivation</a></li><li><a href="#_label1_2">&nbsp;2.2 现实使用中易出问题</a></li></ul></li><li><a href="#_label2">三、深入理解元空间（Metaspace）</a><ul><li><a href="#_label2_0">3.1元空间的内存大小</a></li><li><a href="#_label2_1">3.2常用配置参数</a></li><li><a href="#_label2_2">3.3测试并追踪元空间大小</a></li></ul></li><li><a href="#_label3">&nbsp;四、总结</a></li></ul></div><p>&nbsp;</p><p style="font-size:18px"><b>正文</b></p><div style="text-align: right"><a href="#_labelTop">回到顶部</a><a name="_label0"></a></div><h2>一、背景</h2>
<a name="_label0_0"></a><h3>1.1 永久代（PermGen）在哪里？</h3>
<p>根据，hotspot jvm结构如下(虚拟机栈和本地方法栈合一起了)：</p>
<p><img src="https://images2015.cnblogs.com/blog/584866/201704/584866-20170426175411428-34722603.png" alt=""></p>
<p><span style="color: #ff0000;">上图引自网络，但有个问题：方法区和heap堆都是线程共享的内存区域。</span></p>
<p><strong><span style="color: #ff0000;">关于方法区和永久代：</span></strong></p>
<p>在HotSpot JVM中，这次讨论的<strong><span style="color: #ff0000;">永久代</span></strong>，就是上图的方法区（JVM规范中称为方法区）。《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在其他JVM上不存在永久代。<br><br></p>
<a name="_label0_1"></a><h3>1.2 JDK8永久代的废弃</h3>
<p>JDK8 永久代变化如下图：</p>
<p><img src="https://images2015.cnblogs.com/blog/584866/201704/584866-20170426154633834-741444326.jpg" alt=""></p>
<p>1.新生代：Eden+From Survivor+To Survivor</p>
<p>2.老年代：OldGen</p>
<p>3.<span style="color: #ff0000;">永久代（方法区的实现） : PermGen-----&gt;替换为Metaspace(本地内存中)</span></p>
<p>&nbsp;</p>
<div style="text-align: right"><a href="#_labelTop">回到顶部</a><a name="_label1"></a></div><h2>&nbsp;二、为什么废弃永久代（PermGen）</h2>
<a name="_label1_0"></a><h3>&nbsp;2.1 官方说明</h3>
<p>参照JEP122：http://openjdk.java.net/jeps/122，原文截取：</p>
<a name="_label1_1"></a><h3 id="Motivation">Motivation</h3>
<p>This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.</p>
<p>&nbsp;即：移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</p>
<a name="_label1_2"></a><h3>&nbsp;2.2 现实使用中易出问题</h3>
<p>由于永久代内存经常不够用或发生内存泄露，爆出异常<em>java.lang.OutOfMemoryError: PermGen</em></p>
<div style="text-align: right"><a href="#_labelTop">回到顶部</a><a name="_label2"></a></div><h2>三、深入理解元空间（Metaspace）</h2>
<a name="_label2_0"></a><h3>3.1元空间的内存大小</h3>
<p>元空间是方法区的在HotSpot jvm 中的实现，<span style="color: #000000;">方法区主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 </span></p>
<p><span style="color: #ff0000;">元空间的本质和永久代类似，都是对JVM规范中方法区的实现</span>。<span style="font-size: 12px;"><span style="color: #333333;">不过<strong><span style="color: #ff0000;">元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</span></strong></span></span>，理论上取决于32位/64位系统可虚拟的内存大小。可见也不是无限制的，需要配置参数。</p>
<a name="_label2_1"></a><h3>3.2常用配置参数</h3>
<p>1.<span style="color: #ff0000;">MetaspaceSize</span></p>
<p>初始化的Metaspace大小，<span style="color: #ff0000;">控制元空间发生GC的阈值</span>。GC后，动态增加或降低<span style="color: #ff0000;">MetaspaceSize</span>。在默认情况下，这个值大小根据不同的平台在12M到20M浮动。使用<a title="Java SE知识库" href="http://lib.csdn.net/base/javase" target="_blank">Java</a> -XX:+PrintFlagsInitial命令查看本机的初始化参数</p>
<p>2.<span style="color: #ff0000;">MaxMetaspaceSize</span></p>
<p>限制Metaspace增长的上限，防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序。在本机上该参数的默认值为4294967295B（大约4096MB）。</p>
<p>3.<span style="color: #ff0000;">MinMetaspaceFreeRatio</span></p>
<p>当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数（即实际非空闲占比过大，内存不够用），那么虚拟机将增长Metaspace的大小。默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。</p>
<p>4.<span style="color: #ff0000;">MaxMetasaceFreeRatio</span></p>
<p>当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。默认值为70，也就是70%。</p>
<p>5.MaxMetaspaceExpansion</p>
<p>Metaspace增长时的最大幅度。在本机上该参数的默认值为5452592B（大约为5MB）。</p>
<p>6.MinMetaspaceExpansion</p>
<p>Metaspace增长时的最小幅度。在本机上该参数的默认值为340784B（大约330KB为）。</p>
<a name="_label2_2"></a><h3>3.3测试并追踪元空间大小</h3>
<h4>&nbsp;3.3.1.测试字符串常量</h4>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> StringOomMock {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">static</span> String  base = "string"<span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span>     
<span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 5</span>         List&lt;String&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
</span><span style="color: #008080;"> 6</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=0;i&lt; Integer.MAX_VALUE;i++<span style="color: #000000;">){
</span><span style="color: #008080;"> 7</span>             String str = base +<span style="color: #000000;"> base;
</span><span style="color: #008080;"> 8</span>             base =<span style="color: #000000;"> str;
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">            list.add(str.intern());
</span><span style="color: #008080;">10</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">12</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>在eclipse中选中类--》run configuration--&gt;java application--》new 参数如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/584866/201704/584866-20170426183906365-1825744722.png" alt=""></p>
<p>&nbsp;由于设定了最大内存20M，很快就溢出，如下图：</p>
<p><img src="https://images2015.cnblogs.com/blog/584866/201704/584866-20170426184206881-69720212.png" alt=""></p>
<p>&nbsp;可见在jdk8中：</p>
<p>1.字符串常量由永久代转移到堆中。</p>
<p>2.持久代已不存在，PermSize MaxPermSize参数已移除。（看图中最后两行）</p>
<h4>3.3.2.测试元空间溢出</h4>
<p><span style="color: #000000;">根据定义，我们以加载类来测试元空间溢出，代码如下：</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">package</span><span style="color: #000000;"> jdk8;
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.File;
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.management.ClassLoadingMXBean;
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.management.ManagementFactory;
</span><span style="color: #008080;"> 6</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.net.URL;
</span><span style="color: #008080;"> 7</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.net.URLClassLoader;
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.ArrayList;
</span><span style="color: #008080;"> 9</span> <span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.List;
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;">12</span> <span style="color: #008000;"> * 
</span><span style="color: #008080;">13</span> <span style="color: #008000;"> * @ClassName:OOMTest
</span><span style="color: #008080;">14</span> <span style="color: #008000;"> * @Description:模拟类加载溢出（元空间oom）
</span><span style="color: #008080;">15</span> <span style="color: #008000;"> * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> diandian.zhang
</span><span style="color: #008080;">16</span> <span style="color: #008000;"> * @date 2017年4月27日上午9:45:40
</span><span style="color: #008080;">17</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">18</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> OOMTest {  
</span><span style="color: #008080;">19</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {  
</span><span style="color: #008080;">20</span>         <span style="color: #0000ff;">try</span><span style="color: #000000;"> {  
</span><span style="color: #008080;">21</span>             <span style="color: #008000;">//</span><span style="color: #008000;">准备url  </span>
<span style="color: #008080;">22</span>             URL url = <span style="color: #0000ff;">new</span> File("D:/58workplace/11study/src/main/java/jdk8"<span style="color: #000000;">).toURI().toURL();  
</span><span style="color: #008080;">23</span>             URL[] urls =<span style="color: #000000;"> {url};  
</span><span style="color: #008080;">24</span>             <span style="color: #008000;">//</span><span style="color: #008000;">获取有关类型加载的JMX接口  </span>
<span style="color: #008080;">25</span>             ClassLoadingMXBean loadingBean =<span style="color: #000000;"> ManagementFactory.getClassLoadingMXBean();  
</span><span style="color: #008080;">26</span>             <span style="color: #008000;">//</span><span style="color: #008000;">用于缓存类加载器  </span>
<span style="color: #008080;">27</span>             List&lt;ClassLoader&gt; classLoaders = <span style="color: #0000ff;">new</span> ArrayList&lt;ClassLoader&gt;<span style="color: #000000;">();  
</span><span style="color: #008080;">28</span>             <span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {  
</span><span style="color: #008080;">29</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">加载类型并缓存类加载器实例  </span>
<span style="color: #008080;">30</span>                 ClassLoader classLoader = <span style="color: #0000ff;">new</span><span style="color: #000000;"> URLClassLoader(urls);  
</span><span style="color: #008080;">31</span> <span style="color: #000000;">                classLoaders.add(classLoader);  
</span><span style="color: #008080;">32</span>                 classLoader.loadClass("ClassA"<span style="color: #000000;">);  
</span><span style="color: #008080;">33</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">显示数量信息（共加载过的类型数目，当前还有效的类型数目，已经被卸载的类型数目）  </span>
<span style="color: #008080;">34</span>                 System.out.println("total: " +<span style="color: #000000;"> loadingBean.getTotalLoadedClassCount());  
</span><span style="color: #008080;">35</span>                 System.out.println("active: " +<span style="color: #000000;"> loadingBean.getLoadedClassCount());  
</span><span style="color: #008080;">36</span>                 System.out.println("unloaded: " +<span style="color: #000000;"> loadingBean.getUnloadedClassCount());  
</span><span style="color: #008080;">37</span> <span style="color: #000000;">            }  
</span><span style="color: #008080;">38</span>         } <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {  
</span><span style="color: #008080;">39</span> <span style="color: #000000;">            e.printStackTrace();  
</span><span style="color: #008080;">40</span> <span style="color: #000000;">        }  
</span><span style="color: #008080;">41</span> <span style="color: #000000;">    }  
</span><span style="color: #008080;">42</span> }  </pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<p>为了快速溢出，设置参数：-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=80m，运行结果如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/584866/201704/584866-20170427095449428-1484864673.png" alt=""></p>
<p>&nbsp;</p>
<p>&nbsp;上图证实了，我们的JDK8中类加载（方法区的功能）已经不在永久代PerGem中了，而是Metaspace中。可以配合JVisualVM来看，更直观一些。</p>
<div style="text-align: right"><a href="#_labelTop">回到顶部</a><a name="_label3"></a></div><h2>&nbsp;四、总结</h2>
<p>本文讲解了元空间（Metaspace）的由来和本质，常用配置，以及监控测试。元空间的大小是动态变更的，但不是无限大的，最好也时常关注一下大小，以免影响服务器内存。</p>
<p>&nbsp;</p>
<p>==================</p>
<p>参考：</p>
<p><span class="link_title"><a href="http://blog.csdn.net/sczyh22/article/details/46662279">深入探究JVM（2） - 探秘Metaspace </a></span></p>
<p><span class="link_title"><span class="link_title"><a href="http://blog.csdn.net/moshenglv/article/details/52027216">【理解JVM】JVM内存模型 </a></span></span></p></div><div id="MySignature" style="display: block;">------------------
掌控自己的生命轨迹，身心自由！
------------------</div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag">标签: <a href="https://www.cnblogs.com/dennyzhangdd/tag/jdk%E6%96%B0%E7%89%B9%E6%80%A7/">jdk新特性</a></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(6770188,cb_blogId,1);green_channel_success(this,'谢谢推荐！');">好文要顶</a>
            <a id="green_channel_follow" onclick="follow('5c933f56-2653-e311-8d02-90b11c0b17d6');" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="//common.cnblogs.com/images/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="//common.cnblogs.com/images/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/dennyzhangdd/" target="_blank"><img src="//pic.cnblogs.com/face/584866/20170409192956.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/dennyzhangdd/">只会一点java</a><br>
            <a href="https://home.cnblogs.com/u/dennyzhangdd/followees">关注 - 7</a><br>
            <a href="https://home.cnblogs.com/u/dennyzhangdd/followers">粉丝 - 184</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow('5c933f56-2653-e311-8d02-90b11c0b17d6');return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(6770188,'Digg')">
        <span class="diggnum" id="digg_count">8</span>
    </div>
    <div class="buryit" onclick="votePost(6770188,'Bury')">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
<script type="text/javascript">
    currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="https://www.cnblogs.com/dennyzhangdd/p/6745282.html" class="p_n_p_prefix">« </a> 上一篇：<a href="https://www.cnblogs.com/dennyzhangdd/p/6745282.html" title="发布于2017-04-21 20:03">jdk源码剖析四：JDK1.7升级1.8 HashMap原理的变化</a><br><a href="https://www.cnblogs.com/dennyzhangdd/p/6808321.html" class="p_n_p_prefix">» </a> 下一篇：<a href="https://www.cnblogs.com/dennyzhangdd/p/6808321.html" title="发布于2017-05-04 17:28">apache的MultipartEntityBuilder文件上传</a><br></div>
</div>

</div>
	</div></div>
	
参考:
https://www.cnblogs.com/dennyzhangdd/p/6770188.html