<div class="article">
        <h1 class="title">深入浅出CAS</h1>

<!-- 作者区域 -->
<div class="author">
  <a class="avatar" href="/u/90ab66c248e6">
    <img src="//upload.jianshu.io/users/upload_avatars/2184951/e504c85fb1dc.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96" alt="96">
</a>          <div class="info">
            <span class="name"><a href="/u/90ab66c248e6">占小狼</a></span>
              <img class="badge-icon" data-toggle="tooltip" title="" src="//upload.jianshu.io/user_badge/11f8cfa8-ec9f-4f82-be92-d6a39f61b5c1" alt="11f8cfa8 ec9f 4f82 be92 d6a39f61b5c1" data-original-title="程序员优秀作者">
            <!-- 关注用户按钮 -->
            <a class="btn btn-success follow"><i class="iconfont ic-follow"></i><span>关注</span></a>
            <!-- 文章数据信息 -->
            <div class="meta">
              <!-- 简书钻 -->
                <span class="jsd-meta">
                  <i class="iconfont ic-paid1"></i> 4.3
                </span>
              <!-- 如果文章更新时间大于发布时间，那么使用 tooltip 显示更新时间 -->
                <span class="publish-time" data-toggle="tooltip" data-placement="bottom" title="" data-original-title="最后编辑于 2017.12.31 21:06">2016.07.12 13:42*</span>
              <span class="wordage">字数 1637</span>
            <span class="views-count">阅读 46285</span><span class="comments-count">评论 102</span><span class="likes-count">喜欢 266</span><span class="rewards-count ">赞赏 2</span></div>
          </div>
          <!-- 如果是当前作者，加入编辑按钮 -->
        </div>


<!-- 文章内容 -->
<div data-note-content="" class="show-content">
  <div class="show-content-free">
    <blockquote>
<p><a href="https://www.jianshu.com/users/90ab66c248e6/latest_articles" target="_blank">占小狼</a> 转载请注明原创出处，谢谢！</p>
</blockquote>
<h3>前言</h3>
<p>CAS（Compare and Swap），即比较并替换，实现并发算法时常用到的一种技术，Doug lea大神在java同步器中大量使用了CAS技术，鬼斧神工的实现了多线程执行的安全性。</p>
<p>CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>
<h3>问题</h3>
<p>一个<code>n++</code>的问题。</p>
<pre class="hljs cpp"><code class="cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Case</span> {</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> n;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>{
        n++;
    }
}
</code></pre>
<p>通过<code>javap -verbose Case</code>看看add方法的字节码指令</p>
<pre class="hljs cpp"><code class="cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;
    flags: ACC_PUBLIC
    Code:
      <span class="hljs-built_in">stack</span>=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>
         <span class="hljs-number">0</span>: aload_0       
         <span class="hljs-number">1</span>: dup           
         <span class="hljs-number">2</span>: getfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field n:I</span>
         <span class="hljs-number">5</span>: iconst_1      
         <span class="hljs-number">6</span>: iadd          
         <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field n:I</span>
        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span>        
</code></pre>
<p><code>n++</code>被拆分成了几个指令：</p>
<ol>
<li>执行<code>getfield</code>拿到原始n；</li>
<li>执行<code>iadd</code>进行加1操作；</li>
<li>执行<code>putfield</code>写把累加后的值写回n；</li>
</ol>
<p>通过volatile修饰的变量可以保证线程之间的可见性，但并不能保证这3个指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果，那么应该如何解决呢？</p>
<h3>如何解决</h3>
<p>在<code>add</code>方法加上synchronized修饰解决。</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Case</span> </span>{

<span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> n;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>{
    n++;
}
}
</code></pre>
<p>这个方案当然可行，但是性能上差了点，还有其它方案么？</p>
<p>再来看一段代码</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>) {
        a = b;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
</code></pre>
<p>如果这段代码在并发下执行，会发生什么？</p>
<p>假设线程1和线程2都过了<code>a==1</code>的检测，都准备执行对a进行赋值，结果就是两个线程同时修改了变量a，显然这种结果是无法符合预期的，无法确定a的最终值。</p>
<p>解决方法也同样暴力，在compareAndSwapInt方法加锁同步，变成一个原子操作，同一时刻只有一个线程才能修改变量a。</p>
<p>除了低性能的加锁方案，我们还可以使用JDK自带的CAS方案，在CAS中，比较和替换是一组原子操作，不会被外部打断，且在性能上更占有优势。</p>
<p>下面以<code>AtomicInteger</code>的实现为例，分析一下CAS是如何实现的。</p>
<pre class="hljs java"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>{
    <span class="hljs-comment">// setup to use Unsafe.compareAndSwapInt for updates</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;

<span class="hljs-keyword">static</span> {
<span class="hljs-keyword">try</span> {
    valueOffset = unsafe.objectFieldOffset
        (AtomicInteger.class.getDeclaredField(<span class="hljs-string">"value"</span>));
} <span class="hljs-keyword">catch</span> (Exception ex) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); }
}

<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> value;}
}
</code></pre>
<ol>
<li>Unsafe，是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。</li>
<li>变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。</li>
<li>变量value用volatile修饰，保证了多线程之间的内存可见性。</li>
</ol>
<p>看看<code>AtomicInteger</code>如何实现并发下的累加操作：</p>
<pre class="hljs java"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delta)</span> </span>{    
    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, delta);
}

<span class="hljs-comment">//unsafe.getAndAddInt</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>{
    <span class="hljs-keyword">int</span> var5;
    <span class="hljs-keyword">do</span> {
        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);
    } <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));
    <span class="hljs-keyword">return</span> var5;
}
</code></pre>
<p>假设线程A和线程B同时执行getAndAdd操作（分别跑在不同CPU上）：</p>
<ol>
<li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据Java内存模型，线程A和线程B各自持有一份value的副本，值为3。</li>
<li>线程A通过<code>getIntVolatile(var1, var2)</code>拿到value值3，这时线程A被挂起。</li>
<li>线程B也通过<code>getIntVolatile(var1, var2)</code>方法获取到value值3，运气好，线程B没有被挂起，并执行<code>compareAndSwapInt</code>方法比较内存值也为3，成功修改内存值为2。</li>
<li>这时线程A恢复，执行<code>compareAndSwapInt</code>方法比较，发现自己手里的值(3)和内存的值(2)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。</li>
<li>重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行<code>compareAndSwapInt</code>进行比较替换，直到成功。</li>
</ol>
<p>整个过程中，利用CAS保证了对于value的修改的并发安全，继续深入看看Unsafe类中的compareAndSwapInt方法实现。</p>
<pre class="hljs java"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object paramObject, <span class="hljs-keyword">long</span> paramLong, <span class="hljs-keyword">int</span> paramInt1, <span class="hljs-keyword">int</span> paramInt2)</span></span>;
</code></pre>
<p>Unsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于<code>unsafe.cpp</code>中</p>
<pre class="hljs php"><code class="php">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper(<span class="hljs-string">"Unsafe_CompareAndSwapInt"</span>);
  oop p = JNIHandles::resolve(obj);
  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
  <span class="hljs-keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;
UNSAFE_END
</code></pre>
<ol>
<li>先想办法拿到变量value在内存中的地址。</li>
<li>通过<code>Atomic::cmpxchg</code>实现比较替换，其中参数x是即将更新的值，参数e是原内存的值。</li>
</ol>
<p>如果是Linux的x86，<code>Atomic::cmpxchg</code>方法的实现如下：</p>
<pre class="hljs objectivec"><code class="objectivec"><span class="hljs-keyword">inline</span> jint Atomic::cmpxchg (jint exchange_value, <span class="hljs-keyword">volatile</span> jint* dest, jint compare_value) {
  <span class="hljs-keyword">int</span> mp = os::is_MP();
  __asm__ <span class="hljs-keyword">volatile</span> (LOCK_IF_MP(%<span class="hljs-number">4</span>) <span class="hljs-string">"cmpxchgl %1,(%3)"</span>
                    : <span class="hljs-string">"=a"</span> (exchange_value)
                    : <span class="hljs-string">"r"</span> (exchange_value), <span class="hljs-string">"a"</span> (compare_value), <span class="hljs-string">"r"</span> (dest), <span class="hljs-string">"r"</span> (mp)
                    : <span class="hljs-string">"cc"</span>, <span class="hljs-string">"memory"</span>);
  <span class="hljs-keyword">return</span> exchange_value;
}
</code></pre>
<p>看到这汇编，内心崩溃 😖</p>
<p><code>__asm__</code>表示汇编的开始<br>
<code>volatile</code>表示禁止编译器优化<br>
<code>LOCK_IF_MP</code>是个内联函数</p>
<pre class="hljs cpp"><code class="cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOCK_IF_MP(mp) <span class="hljs-meta-string">"cmp $0, "</span> #mp <span class="hljs-meta-string">"; je 1f; lock; 1: "</span></span>
</code></pre>
<p>Window的x86实现如下：</p>
<pre class="hljs objectivec"><code class="objectivec"><span class="hljs-keyword">inline</span> jint Atomic::cmpxchg (jint exchange_value, <span class="hljs-keyword">volatile</span> jint* dest, jint compare_value) {
    <span class="hljs-keyword">int</span> mp = os::isMP(); <span class="hljs-comment">//判断是否是多处理器</span>
    _<span class="hljs-keyword">asm</span> {
        mov edx, dest
        mov ecx, exchange_value
        mov eax, compare_value
        LOCK_IF_MP(mp)
        cmpxchg dword ptr [edx], ecx
    }
}

<span class="hljs-comment">// Adding a lock prefix to an instruction on MP machine</span>
<span class="hljs-comment">// VC++ doesn't like the lock prefix to be on a single line</span>
<span class="hljs-comment">// so we can't insert a label after the lock prefix.</span>
<span class="hljs-comment">// By emitting a lock prefix, we can define a label after it.</span>
<span class="hljs-meta">#define LOCK_IF_MP(mp) __asm cmp mp, 0  \</span>
                       __<span class="hljs-keyword">asm</span> je L0      \
                       __<span class="hljs-keyword">asm</span> _emit <span class="hljs-number">0xF0</span> \
                       __<span class="hljs-keyword">asm</span> L0:
</code></pre>
<p><code>LOCK_IF_MP</code>根据当前系统是否为多核处理器决定是否为cmpxchg指令添加lock前缀。</p>
<ol>
<li>如果是多处理器，为cmpxchg指令添加lock前缀。</li>
<li>反之，就省略lock前缀。（单处理器会不需要lock前缀提供的内存屏障效果）</li>
</ol>
<p>intel手册对lock前缀的说明如下：</p>
<ol>
<li>确保后续指令执行的原子性。<br>
在Pentium及之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存，很显然，这个开销很大。在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销。</li>
<li>禁止该指令与前面和后面的读写指令重排序。</li>
<li>把写缓冲区的所有数据刷新到内存中。</li>
</ol>
<p>上面的第2点和第3点所具有的内存屏障效果，保证了CAS同时具有volatile读和volatile写的内存语义。</p>
<h3>CAS缺点</h3>
<p>CAS存在一个很明显的问题，即ABA问题。</p>
<p>问题：如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？</p>
<p>如果在这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。针对这种情况，java并发包中提供了一个带有标记的原子引用类<code>AtomicStampedReference</code>，它可以通过控制变量值的版本来保证CAS的正确性。</p>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 400px; background-color: transparent;">
<div class="image-container-fill" style="padding-bottom: 57.25%;"></div>
<div class="image-view" data-width="1296" data-height="742"><img data-original-src="//upload-images.jianshu.io/upload_images/2184951-27faefbde89822bf.png" data-original-width="1296" data-original-height="742" data-original-format="image/png" data-original-filesize="340601" style="cursor: zoom-in;" class="" src="//upload-images.jianshu.io/upload_images/2184951-27faefbde89822bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></div>
</div>
<div class="image-caption"></div>
</div>

</div>
</div>
</div>