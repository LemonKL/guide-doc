<div class="postBody">
<div id="cnblogs_post_body" class="blogpost-body"><ul>
<li>NIO</li>
<li>流与块</li>
<li>通道与缓冲区</li>
<li>缓冲区状态变量</li>
<li>文件 NIO 实例</li>
<li>选择器</li>
<li>套接字 NIO 实例</li>
<li>内存映射文件</li>
<li>NIO与IO对比</li>
<li>Path</li>
<li>Files</li>
</ul>
<h2>NIO</h2>
<p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>
<p>NIO核心组件:</p>
<ul>
<li>通道(Channels)</li>
<li>缓冲区(Buffers)</li>
<li>选择器(Selectors)</li>
</ul>
<h2>流与块</h2>
<p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。 为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。 但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。 例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h2>通道与缓冲区</h2>
<h3>1. 通道</h3>
<p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<ul>
<li>FileChannel：从文件中读写数据；</li>
<li>DatagramChannel：通过 UDP 读写网络中数据；</li>
<li>SocketChannel：通过 TCP 读写网络中数据；</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h3>2. 缓冲区</h3>
<p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>缓冲区包括以下类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<h2>缓冲区状态变量</h2>
<ul>
<li>capacity：最大容量；</li>
<li>position：当前已经读写的字节数；</li>
<li>limit：还可以读写的字节数。</li>
</ul>
<p>状态变量的改变过程举例：</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p><img class="origin_image zh-lightbox-thumb lazy" src="https://pic3.zhimg.com/80/v2-8b6864d61dc274d8345ec835ab7661d2_hd.jpg" alt="" width="552" data-caption="" data-size="normal" data-rawwidth="552" data-rawheight="186" data-original="https://pic3.zhimg.com/v2-8b6864d61dc274d8345ec835ab7661d2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-8b6864d61dc274d8345ec835ab7661d2_b.jpg"></p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p><img class="origin_image zh-lightbox-thumb lazy" src="https://pic3.zhimg.com/80/v2-fc890e5883e578a1eceacd564f4fc5ba_hd.jpg" alt="" width="496" data-caption="" data-size="normal" data-rawwidth="496" data-rawheight="148" data-original="https://pic3.zhimg.com/v2-fc890e5883e578a1eceacd564f4fc5ba_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-fc890e5883e578a1eceacd564f4fc5ba_b.jpg"></p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p><img class="origin_image zh-lightbox-thumb lazy" src="https://pic1.zhimg.com/80/v2-fbde9a084339448fa0a8c690a0621420_hd.jpg" alt="" width="549" data-caption="" data-size="normal" data-rawwidth="549" data-rawheight="146" data-original="https://pic1.zhimg.com/v2-fbde9a084339448fa0a8c690a0621420_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-fbde9a084339448fa0a8c690a0621420_b.jpg"></p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p><img class="origin_image zh-lightbox-thumb lazy" src="https://pic3.zhimg.com/80/v2-7d0bc96ce589d38a640241e707e6386e_hd.jpg" alt="" width="527" data-caption="" data-size="normal" data-rawwidth="527" data-rawheight="158" data-original="https://pic3.zhimg.com/v2-7d0bc96ce589d38a640241e707e6386e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-7d0bc96ce589d38a640241e707e6386e_b.jpg"></p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p><img class="origin_image zh-lightbox-thumb lazy" src="https://pic3.zhimg.com/80/v2-0c9bcea8c53459f420055a485797d6ee_hd.jpg" alt="" width="462" data-caption="" data-size="normal" data-rawwidth="462" data-rawheight="151" data-original="https://pic3.zhimg.com/v2-0c9bcea8c53459f420055a485797d6ee_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-0c9bcea8c53459f420055a485797d6ee_b.jpg"></p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<h2>文件 NIO 实例</h2>
<h3>FileChannel的使用</h3>
<ol>
<li>开启FileChannel</li>
<li>从FileChannel读取数据/写入数据</li>
</ol>
<p>3.关闭FileChannel</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FileChannelDemo {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
</span><span style="color: #008000;">//</span><span style="color: #008000;">1.创建一个RandomAccessFile（随机访问文件）对象通过RandomAccessFile对象的getChannel()方法。</span>
RandomAccessFile raf=<span style="color: #0000ff;">new</span> RandomAccessFile("demo6.txt","rw"<span style="color: #000000;">);
FileChannel fc</span>=<span style="color: #000000;">raf.getChannel();

</span><span style="color: #008000;">//</span><span style="color: #008000;">使用FileChannel的read()方法读取数据：</span>
ByteBuffer byteBuffer=ByteBuffer.allocate(1024<span style="color: #000000;">);
</span><span style="color: #0000ff;">int</span> bys=<span style="color: #000000;">fc.read(byteBuffer);

</span><span style="color: #008000;">//</span><span style="color: #008000;">使用FileChannel的write()方法写入数据：</span>
ByteBuffer byteBuffer2=ByteBuffer.allocate(1024<span style="color: #000000;">);
byteBuffer2.put(</span>"hello"<span style="color: #000000;">.getBytes());
fc.write(byteBuffer2);

</span><span style="color: #008000;">//</span><span style="color: #008000;">3.关闭FileChannel</span>
<span style="color: #000000;">        fc.close();
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<ul>
<li>以下展示了使用 NIO 快速复制文件的实例：</li>
</ul>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CopyFile {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
String srcFile</span>="国旗歌.mp4"<span style="color: #000000;">;
String destFile</span>="demo3.mp4"<span style="color: #000000;">;
</span><span style="color: #0000ff;">long</span> start =<span style="color: #000000;"> System.currentTimeMillis();
</span><span style="color: #008000;">//</span><span style="color: #008000;">copyFile(srcFile,destFile); </span><span style="color: #008000;">//</span><span style="color: #008000;">共耗时：75309毫秒
</span><span style="color: #008000;">//</span><span style="color: #008000;">copyFile2(srcFile,destFile); </span><span style="color: #008000;">//</span><span style="color: #008000;">共耗时：153毫秒
</span><span style="color: #008000;">//</span><span style="color: #008000;">copyFile3(srcFile,destFile);</span><span style="color: #008000;">//</span><span style="color: #008000;">共耗时：282毫秒
</span><span style="color: #008000;">//</span><span style="color: #008000;">copyFile4(srcFile,destFile);</span><span style="color: #008000;">//</span><span style="color: #008000;">共耗时：44毫秒</span>
copyFile5(srcFile,destFile);<span style="color: #008000;">//</span><span style="color: #008000;">共耗时：共耗时：113毫秒</span>
<span style="color: #0000ff;">long</span> end =<span style="color: #000000;"> System.currentTimeMillis();
System.out.println(</span>"共耗时：" + (end - start) + "毫秒"<span style="color: #000000;">);
}

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
* 基本字节流一次读写一个字节
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> copyFile(String srcFile,String destFile) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
FileInputStream fis</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(srcFile);
FileOutputStream fos</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileOutputStream(destFile);

</span><span style="color: #0000ff;">int</span> by=0<span style="color: #000000;">;
</span><span style="color: #0000ff;">while</span>((by=fis.read())!=-1<span style="color: #000000;">){
fos.write(by);
}

fis.close();
fos.close();
}

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
* 基本字节流一次读写一个字节数组
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> copyFile2(String srcFile,String destFile) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException{
FileInputStream fis</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(srcFile);
FileOutputStream fos</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileOutputStream(destFile);

</span><span style="color: #0000ff;">int</span> len=0<span style="color: #000000;">;
</span><span style="color: #0000ff;">byte</span>[] bys=<span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[1024<span style="color: #000000;">];
</span><span style="color: #0000ff;">while</span>((len=fis.read(bys))!=-1<span style="color: #000000;">){
fos.write(bys,</span>0<span style="color: #000000;">,len);
}

fis.close();
fos.close();
}

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
* 高效字节流一次读写一个字节
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> copyFile3(String srcFile,String destFile) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException{
BufferedInputStream bis</span>=<span style="color: #0000ff;">new</span> BufferedInputStream(<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(srcFile));
BufferedOutputStream bos</span>=<span style="color: #0000ff;">new</span> BufferedOutputStream(<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileOutputStream(destFile));

</span><span style="color: #0000ff;">int</span> by=0<span style="color: #000000;">;
</span><span style="color: #0000ff;">while</span>((by=bis.read())!=-1<span style="color: #000000;">){
bos.write(by);
}

bis.close();
bos.close();
}

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
* 高效字节流一次读写一个字节数组
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> copyFile4(String srcFile,String destFile) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException{
BufferedInputStream bis</span>=<span style="color: #0000ff;">new</span> BufferedInputStream(<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(srcFile));
BufferedOutputStream bos</span>=<span style="color: #0000ff;">new</span> BufferedOutputStream(<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileOutputStream(destFile));

</span><span style="color: #0000ff;">int</span> len=0<span style="color: #000000;">;
</span><span style="color: #0000ff;">byte</span>[] bys=<span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[1024<span style="color: #000000;">];
</span><span style="color: #0000ff;">while</span>((len=bis.read(bys))!=-1<span style="color: #000000;">){
bos.write(bys,</span>0<span style="color: #000000;">,len);
}

bis.close();
bos.close();
}

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
* 使用FileChannel复制文件
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> copyFile5(String srcFile,String destFile) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException{
FileInputStream fis</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(srcFile);
</span><span style="color: #008000;">//</span><span style="color: #008000;">获取输入字节流的文件通道</span>
FileChannel fcin=<span style="color: #000000;">fis.getChannel();
FileOutputStream fos</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileOutputStream(destFile);
</span><span style="color: #008000;">//</span><span style="color: #008000;">获取输出字节流的文件通道</span>
FileChannel fcout=<span style="color: #000000;">fos.getChannel();

</span><span style="color: #008000;">//</span><span style="color: #008000;">为缓冲区分配 1024 个字节</span>
ByteBuffer buffer = ByteBuffer.allocateDirect(1024<span style="color: #000000;">);

</span><span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">){
</span><span style="color: #008000;">//</span><span style="color: #008000;">从输入通道中读取数据到缓冲区中</span>
<span style="color: #0000ff;">int</span> r =<span style="color: #000000;"> fcin.read(buffer);
</span><span style="color: #008000;">//</span><span style="color: #008000;"> read() 返回 -1 表示 EOF</span>
<span style="color: #0000ff;">if</span>(r==-1<span style="color: #000000;">){
</span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">切换读写</span>
<span style="color: #000000;">            buffer.flip();
</span><span style="color: #008000;">//</span><span style="color: #008000;">把缓冲区的内容写入输出文件中</span>
<span style="color: #000000;">            fcout.write(buffer);
</span><span style="color: #008000;">//</span><span style="color: #008000;">清空缓冲区</span>
<span style="color: #000000;">            buffer.clear();
}
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>SocketChannel和ServerSocketChannel的使用</h3>
<p>SocketChannel用于创建基于TCP协议的客户端对象，因为SocketChannel中不存在accept()方法， 所以，它不能成为一个服务端程序。 通过connect()方法，SocketChannel对象可以连接到其他TCP服务器程序。</p>
<p>ServerSocketChannel允许我们监听TCP协议请求，通过ServerSocketChannel的**accept()**方法创建一个SocketChannel对象用户从客户端读/写数据。</p>
<ul>
<li>服务端:</li>
</ul>
<ol>
<li>通过ServerSocketChannel 绑定ip地址和端口号</li>
<li>通过ServerSocketChannel的accept()方法创建一个SocketChannel对象用户从客户端读/写数据</li>
<li>创建读数据/写数据缓冲区对象来读取客户端数据或向客户端发送数据</li>
<li>关闭SocketChannel和ServerSocketChannel</li>
</ol>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Server {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
</span><span style="color: #008000;">//</span><span style="color: #008000;">通过ServerSocketChannel 的open()方法创建一个ServerSocketChannel对象</span>
ServerSocketChannel ssc=<span style="color: #000000;">ServerSocketChannel.open();

</span><span style="color: #008000;">//</span><span style="color: #008000;">1. 通过ServerSocketChannel 绑定ip地址和端口号</span>
ssc.socket().bind(<span style="color: #0000ff;">new</span> InetSocketAddress(InetAddress.getByName("LAPTOP-D9966H06"),8888<span style="color: #000000;">));

</span><span style="color: #008000;">//</span><span style="color: #008000;">2. 通过ServerSocketChannel的accept()方法创建一个SocketChannel对象用户从客户端读/写数据</span>
SocketChannel sc=<span style="color: #000000;">ssc.accept();

</span><span style="color: #008000;">//</span><span style="color: #008000;">3. 创建读数据/写数据缓冲区对象来读取客户端数据或向客户端发送数据
</span><span style="color: #008000;">//</span><span style="color: #008000;">读取客户端发送的数据</span>
ByteBuffer buffer=ByteBuffer.allocate(1024<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">从通道中读取数据到缓冲区</span>
<span style="color: #000000;">        sc.read(buffer);
StringBuffer sb</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuffer();
buffer.flip();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;">(buffer.hasRemaining()){
sb.append((</span><span style="color: #0000ff;">char</span><span style="color: #000000;">)buffer.get());
}
System.out.println(sb.toString());

ByteBuffer buffer2</span>=ByteBuffer.allocate(1024<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">向客户端发送数据</span>
buffer2.put("data has been received."<span style="color: #000000;">.getBytes());
buffer2.flip();
sc.write(buffer2);

</span><span style="color: #008000;">//</span><span style="color: #008000;">4. 关闭SocketChannel和ServerSocketChannel</span>
<span style="color: #000000;">        sc.close();
ssc.close();
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<ul>
<li>客户端：</li>
</ul>
<p>1.通过SocketChannel连接到远程服务器</p>
<p>2.创建读数据/写数据缓冲区对象来读取服务端数据或向服务端发送数据</p>
<p>3.关闭SocketChannel</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Client {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
</span><span style="color: #008000;">//</span><span style="color: #008000;">1.通过SocketChannel连接到远程服务器</span>
SocketChannel sc=<span style="color: #000000;">SocketChannel.open();
sc.connect(</span><span style="color: #0000ff;">new</span> InetSocketAddress(InetAddress.getByName("LAPTOP-D9966H06"),8888<span style="color: #000000;">));

</span><span style="color: #008000;">//</span><span style="color: #008000;">2.创建读数据/写数据缓冲区对象来读取服务端数据或向服务端发送数据
</span><span style="color: #008000;">//</span><span style="color: #008000;">向通道中写入数据</span>
ByteBuffer buffer=ByteBuffer.allocate(1024<span style="color: #000000;">);
buffer.put(</span>"hello"<span style="color: #000000;">.getBytes());
buffer.flip();
sc.write(buffer);

</span><span style="color: #008000;">//</span><span style="color: #008000;">读取从客户端中获取的数据</span>
ByteBuffer buffer2=ByteBuffer.allocate(1024<span style="color: #000000;">);
sc.read(buffer2);
StringBuffer sb</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuffer();
buffer2.flip();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;">(buffer2.hasRemaining()){
sb.append((</span><span style="color: #0000ff;">char</span><span style="color: #000000;">)buffer2.get());
}
System.out.println(sb.toString());

</span><span style="color: #008000;">//</span><span style="color: #008000;">3.关闭SocketChannel</span>
<span style="color: #000000;">        sc.close();
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>DatagramChannel的使用</h3>
<p>DataGramChannel，类似于java 网络编程的DatagramSocket类；&nbsp;使用UDP进行网络传输， UDP是无连接，面向数据报文段的协议。</p>
<ul>
<li>服务端：</li>
</ul>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Server {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
DatagramChannel dc</span>=<span style="color: #000000;"> DatagramChannel.open();
dc.bind(</span><span style="color: #0000ff;">new</span> InetSocketAddress(InetAddress.getByName("LAPTOP-D9966H06"),8888<span style="color: #000000;">));


</span><span style="color: #008000;">//</span><span style="color: #008000;">创建读数据/写数据缓冲区对象来读取客户端数据或向客户端发送数据
</span><span style="color: #008000;">//</span><span style="color: #008000;">读取客户端发送的数据</span>
ByteBuffer buffer=ByteBuffer.allocate(1024<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">从通道中读取数据到缓冲区</span>
<span style="color: #000000;">        dc.receive(buffer);
StringBuffer sb</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuffer();
buffer.flip();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;">(buffer.hasRemaining()){
sb.append((</span><span style="color: #0000ff;">char</span><span style="color: #000000;">)buffer.get());
}
System.out.println(sb.toString());

ByteBuffer buffer2</span>=ByteBuffer.allocate(1024<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">向客户端发送数据</span>
buffer2.put("data has been received."<span style="color: #000000;">.getBytes());
buffer2.flip();
dc.send(buffer2,</span><span style="color: #0000ff;">new</span> InetSocketAddress(InetAddress.getByName("LAPTOP-D9966H06"),9999<span style="color: #000000;">));

dc.close();
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<ul>
<li>客户端：</li>
</ul>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Client {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
DatagramChannel dc</span>=<span style="color: #000000;"> DatagramChannel.open();
dc.bind(</span><span style="color: #0000ff;">new</span> InetSocketAddress(InetAddress.getByName("LAPTOP-D9966H06"),9999<span style="color: #000000;">));

</span><span style="color: #008000;">//</span><span style="color: #008000;">创建读数据/写数据缓冲区对象来读取服务端数据或向服务端发送数据
</span><span style="color: #008000;">//</span><span style="color: #008000;">向通道中写入数据</span>
ByteBuffer buffer=ByteBuffer.allocate(1024<span style="color: #000000;">);
buffer.put(</span>"hello"<span style="color: #000000;">.getBytes());
buffer.flip();
dc.send(buffer,</span><span style="color: #0000ff;">new</span> InetSocketAddress(InetAddress.getByName("LAPTOP-D9966H06"),8888<span style="color: #000000;">));

</span><span style="color: #008000;">//</span><span style="color: #008000;">读取从客户端中获取的数据</span>
ByteBuffer buffer2=ByteBuffer.allocate(1024<span style="color: #000000;">);
dc.receive(buffer2);
StringBuffer sb</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuffer();
buffer2.flip();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;">(buffer2.hasRemaining()){
sb.append((</span><span style="color: #0000ff;">char</span><span style="color: #000000;">)buffer2.get());
}
System.out.println(sb.toString());

dc.close();
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>通道之间的数据传输</h3>
<p>在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #000000;">transferFrom() :transferFrom方法把数据从通道源传输到FileChannel
transferTo() :transferTo方法把FileChannel数据传输到另一个FileChhannel
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> copyFile6(String srcFile,String destFile) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
FileInputStream fis </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(srcFile);
</span><span style="color: #008000;">//</span><span style="color: #008000;">获取输入字节流的文件通道</span>
FileChannel fcin =<span style="color: #000000;"> fis.getChannel();
FileOutputStream fos </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileOutputStream(destFile);
</span><span style="color: #008000;">//</span><span style="color: #008000;">获取输出字节流的文件通道</span>
FileChannel fcout =<span style="color: #000000;"> fos.getChannel();

</span><span style="color: #008000;">//</span><span style="color: #008000;">fcin通道中读出count bytes ，并写入fcout通道中
</span><span style="color: #008000;">//</span><span style="color: #008000;">fcin.transferTo(0,fcin.size(),fcout);
</span><span style="color: #008000;">//</span><span style="color: #008000;">或者</span>
fcout.transferFrom(fcin,0<span style="color: #000000;">,fcin.size());
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h2>选择器</h2>
<p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式&nbsp;去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时， 就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件， 对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能， 为 FileChannel 配置非阻塞也没有意义。</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p><img class="origin_image zh-lightbox-thumb lazy" src="https://pic3.zhimg.com/80/v2-c1bf6bc3ccff69b6cb121240dafddabe_hd.jpg" alt="" width="541" data-caption="" data-size="normal" data-rawwidth="541" data-rawheight="403" data-original="https://pic3.zhimg.com/v2-c1bf6bc3ccff69b6cb121240dafddabe_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-c1bf6bc3ccff69b6cb121240dafddabe_b.jpg"></p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p>使用Selector的优点：</p>
<p>使用更少的线程来就可以来处理通道了， 相比使用多个线程， 避免了线程上下文切换带来的开销。</p>
<h3>1. 创建选择器</h3>
<div class="highlight">
<pre><code class="language-text">Selector selector = Selector.open();</code></pre>
</div>
<h3>2. 将通道注册到选择器上</h3>
<div class="highlight">
<div class="cnblogs_code">
<pre>ServerSocketChannel ssChannel =<span style="color: #000000;"> ServerSocketChannel.open();
ssChannel.configureBlocking(</span><span style="color: #0000ff;">false</span>);<span style="color: #008000;">//</span><span style="color: #008000;">通道必须配置为非阻塞模式</span>
ssChannel.register(selector, SelectionKey.OP_ACCEPT);</pre>
</div>
<p>&nbsp;</p>
</div>
<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>它们在 SelectionKey 的定义如下：</p>
<div class="highlight">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> OP_READ = 1 &lt;&lt; 0<span style="color: #000000;">;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> OP_WRITE = 1 &lt;&lt; 2<span style="color: #000000;">;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> OP_CONNECT = 1 &lt;&lt; 3<span style="color: #000000;">;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> OP_ACCEPT = 1 &lt;&lt; 4;</pre>
</div>
<p>&nbsp;</p>
</div>
<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<div class="highlight">
<pre><code class="language-text">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</code></pre>
</div>
<h3>3. 监听事件</h3>
<div class="highlight">
<pre><code class="language-text">int num = selector.select();</code></pre>
</div>
<p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<h3>4. 获取到达的事件</h3>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre>Set&lt;SelectionKey&gt; keys =<span style="color: #000000;"> selector.selectedKeys();
Iterator</span>&lt;SelectionKey&gt; keyIterator =<span style="color: #000000;"> keys.iterator();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (keyIterator.hasNext()) {
SelectionKey key </span>=<span style="color: #000000;"> keyIterator.next();
</span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (key.isAcceptable()) {
</span><span style="color: #008000;">//</span><span style="color: #008000;"> ...</span>
} <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (key.isReadable()) {
</span><span style="color: #008000;">//</span><span style="color: #008000;"> ...</span>
<span style="color: #000000;">    }
keyIterator.remove();
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>5. 事件循环</h3>
<p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
</span><span style="color: #0000ff;">int</span> num =<span style="color: #000000;"> selector.select();
Set</span>&lt;SelectionKey&gt; keys =<span style="color: #000000;"> selector.selectedKeys();
Iterator</span>&lt;SelectionKey&gt; keyIterator =<span style="color: #000000;"> keys.iterator();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (keyIterator.hasNext()) {
SelectionKey key </span>=<span style="color: #000000;"> keyIterator.next();
</span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (key.isAcceptable()) {
</span><span style="color: #008000;">//</span><span style="color: #008000;"> ...</span>
} <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (key.isReadable()) {
</span><span style="color: #008000;">//</span><span style="color: #008000;"> ...</span>
<span style="color: #000000;">        }
keyIterator.remove();
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h2>套接字 NIO 实例</h2>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> NIOServer {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
</span><span style="color: #008000;">//</span><span style="color: #008000;">1. 创建选择器</span>
Selector selector =<span style="color: #000000;"> Selector.open();

</span><span style="color: #008000;">//</span><span style="color: #008000;">2.将通道注册到选择器上</span>
ServerSocketChannel ssChannel =<span style="color: #000000;"> ServerSocketChannel.open();
ssChannel.configureBlocking(</span><span style="color: #0000ff;">false</span><span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了</span>
<span style="color: #000000;">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);

ServerSocket ss</span>=<span style="color: #000000;">ssChannel.socket();
ss.bind(</span><span style="color: #0000ff;">new</span> InetSocketAddress("127.0.0.1",8888<span style="color: #000000;">));

</span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">){
</span><span style="color: #008000;">//</span><span style="color: #008000;">3. 监听事件</span>
<span style="color: #000000;">            selector.select();

</span><span style="color: #008000;">//</span><span style="color: #008000;">4. 获取到达的事件</span>
Set&lt;SelectionKey&gt; keys =<span style="color: #000000;"> selector.selectedKeys();
Iterator</span>&lt;SelectionKey&gt; keyIterator =<span style="color: #000000;"> keys.iterator();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (keyIterator.hasNext()) {
SelectionKey key </span>=<span style="color: #000000;"> keyIterator.next();
</span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (key.isAcceptable()) {
ServerSocketChannel ssChannel1 </span>=<span style="color: #000000;"> (ServerSocketChannel) key.channel();

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 服务器会为每个新连接创建一个 SocketChannel</span>
SocketChannel sChannel =<span style="color: #000000;"> ssChannel1.accept();
sChannel.configureBlocking(</span><span style="color: #0000ff;">false</span><span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 这个新连接主要用于从客户端读取数据</span>
<span style="color: #000000;">                    sChannel.register(selector, SelectionKey.OP_READ);

} </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (key.isReadable()) {
SocketChannel sChannel </span>=<span style="color: #000000;"> (SocketChannel) key.channel();
System.out.println(readDataFromSocketChannel(sChannel));
sChannel.close();
}
keyIterator.remove();
}
}
}

</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> String readDataFromSocketChannel(SocketChannel sChannel) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
ByteBuffer buffer </span>= ByteBuffer.allocate(1024<span style="color: #000000;">);
StringBuilder data </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuilder();

</span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
buffer.clear();
</span><span style="color: #0000ff;">int</span> r =<span style="color: #000000;"> sChannel.read(buffer);
</span><span style="color: #0000ff;">if</span> (r == -1<span style="color: #000000;">) {
</span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
}
buffer.flip();
</span><span style="color: #0000ff;">int</span> limit =<span style="color: #000000;"> buffer.limit();
</span><span style="color: #0000ff;">char</span>[] dst = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">char</span><span style="color: #000000;">[limit];
</span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; limit; i++<span style="color: #000000;">) {
dst[i] </span>= (<span style="color: #0000ff;">char</span><span style="color: #000000;">) buffer.get(i);
}
data.append(dst);
buffer.clear();
}
</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data.toString();
}
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> NIOClient {

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
Socket socket </span>= <span style="color: #0000ff;">new</span> Socket("127.0.0.1", 8888<span style="color: #000000;">);
OutputStream out </span>=<span style="color: #000000;"> socket.getOutputStream();
String s </span>= "hello world"<span style="color: #000000;">;
out.write(s.getBytes());
out.close();
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h2>内存映射文件</h2>
<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<div class="highlight">
<pre><code class="language-text">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);</code></pre>
</div>
<h2>NIO与IO对比</h2>
<p>NIO 与普通 I/O 的区别主要有以下三点：</p>
<ul>
<li>NIO 是非阻塞的；</li>
<li>NIO 面向块，I/O 面向流。</li>
<li>NIO有选择器，而I/O没有。</li>
</ul>
<h2>Path</h2>
<p>Java7中文件IO发生了很大的变化，专门引入了很多新的类来取代原来的 基于java.io.File的文件IO操作方式。</p>
<h3>创建一个Path</h3>
<p>使用Paths工具类的get()方法创建Path对象</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> PathDemo {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">方式一</span>
Path path=Paths.get("demo5.txt"<span style="color: #000000;">);
System.out.println(path);

</span><span style="color: #008000;">//</span><span style="color: #008000;">方式二</span>
Path path2 = FileSystems.getDefault().getPath("demo5.txt"<span style="color: #000000;">);
System.out.println(path2);
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>File和Path之间的转换，File和URI之间的转换</h3>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> PathDemo2 {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
Path path</span>=Paths.get("demo5.txt"<span style="color: #000000;">);
File file</span>=<span style="color: #000000;">path.toFile();
URI uri</span>=<span style="color: #000000;">path.toUri();
System.out.println(path);
System.out.println(file);
System.out.println(uri);
}
}
demo5.txt
demo5.txt
file:</span><span style="color: #008000;">//</span><span style="color: #008000;">/F:/Java_Review/05Java/JavaIO/demo5.txt</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>获取Path的相关信息</h3>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> PathDemo3 {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
Path path</span>= Paths.get("demo3\\test3.txt"<span style="color: #000000;">);
System.out.println(</span>"文件名："+<span style="color: #000000;"> path.getFileName());
System.out.println(</span>"名称元素的数量："+<span style="color: #000000;">path.getNameCount());
System.out.println(</span>"父路径："+<span style="color: #000000;"> path.getParent());
System.out.println(</span>"根路径："+<span style="color: #000000;"> path.getRoot());
System.out.println(</span>"是否是绝对路径:"+<span style="color: #000000;">path.isAbsolute());

</span><span style="color: #008000;">//</span><span style="color: #008000;">startWith() 参数既可以是字符串，也可以是Path</span>
System.out.println("是否是以路径demo3开头："+path.startsWith(Paths.get("demo3"<span style="color: #000000;">)));
System.out.println(</span>"该路径的字符串形式："+<span style="color: #000000;">path.toString());
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<pre><code class="language-text">
文件名：test3.txt
名称元素的数量：2
父路径：demo3
根路径：null
是否是绝对路径:false
是否是以路径demo3开头：true
该路径的字符串形式：demo3\test3.txt</code></pre>
</div>
<h3>移除Path中的冗余项</h3>
<p>\ .表示的是当前目录</p>
<p>\ ..表示父目录或者说是上一级目录</p>
<p>normalize() : 返回一个路径，该路径是取出冗余项的路径。</p>
<p>toRealPath() : 可以看成，先进行toAbsolutePath()操作，然后进行normalize()操作</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> PathDemo4 {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
Path path</span>= Paths.get("./demo3"<span style="color: #000000;">);

System.out.println(</span>"original ："+<span style="color: #000000;"> path.toAbsolutePath());
System.out.println(</span>"after normalize:"+<span style="color: #000000;"> path.toAbsolutePath().normalize());
System.out.println(</span>"after toRealPath:"+<span style="color: #000000;"> path.toRealPath());
}
}
original ：F:\Java_Review\05Java\JavaIO\.\demo3
after normalize:F:\Java_Review\05Java\JavaIO\demo3
after toRealPath:F:\Java_Review\05Java\JavaIO\demo3
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> PathDemo5 {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
Path path</span>= Paths.get("../JavaIO"<span style="color: #000000;">);

System.out.println(</span>"original ："+<span style="color: #000000;"> path.toAbsolutePath());
System.out.println(</span>"after normalize:"+<span style="color: #000000;"> path.toAbsolutePath().normalize());
System.out.println(</span>"after toRealPath:"+<span style="color: #000000;"> path.toRealPath());
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">original ：F:\Java_Review\05Java\JavaIO\..\JavaIO
after normalize:F:\Java_Review\05Java\JavaIO
after toRealPath:F:\Java_Review\05Java\JavaIO</span></pre>
</div>
<p>&nbsp;</p>
<pre><code class="language-text">&nbsp;</code></pre>
</div>
<h2>Files</h2>
<p>java.nio.file.Files类是和java.nio.file.Path相结合使用的</p>
<h3>检查给定的Path在文件系统中是否存在</h3>
<p>Files.exists()：检测文件路径是否存在</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FilesDemo {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
Path path </span>= Paths.get("demo5.txt"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">LinkOptions.NOFOLLOW_LINKS:表示检测时不包含符号链接文件。</span>
<span style="color: #0000ff;">boolean</span> isExist= Files.exists(path,<span style="color: #0000ff;">new</span><span style="color: #000000;"> LinkOption[]{LinkOption.NOFOLLOW_LINKS});
System.out.println(isExist);
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>创建文件/文件夹</h3>
<p>Files.createFile()：创建文件</p>
<p>Files.createDirectory()： 创建文件夹</p>
<p>Files.createDirectories()： 创建文件夹</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FilesDemo2 {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
Path path</span>= Paths.get("demo7.txt"<span style="color: #000000;">);
</span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">Files.exists(path)){
Files.createFile(path);
}

Path path2</span>=Paths.get("demo4"<span style="color: #000000;">);
</span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">Files.exists(path2)){
Files.createDirectory(path2);
}

Path path3</span>=Paths.get("demo5\\test"<span style="color: #000000;">);
</span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">Files.exists(path3)){
Files.createDirectories(path3);
}
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>删除文件或目录</h3>
<p>Files.delete()：删除一个文件或目录</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FilesDemo3 {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
Path path</span>= Paths.get("demo7.txt"<span style="color: #000000;">);
Files.delete(path);
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>把一个文件从一个地址复制到另一个位置</h3>
<p>Files.copy()：把一个文件从一个地址复制到另一个位置</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FilesDemo4 {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
Path srcPath</span>= Paths.get("demo6.txt"<span style="color: #000000;">);
Path destPath</span>=Paths.get("demo7.txt"<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;">Files.copy(srcPath,destPath);

</span><span style="color: #008000;">//</span><span style="color: #008000;">强制覆盖已经存在的目标文件</span>
<span style="color: #000000;">        Files.copy(srcPath,destPath, StandardCopyOption.REPLACE_EXISTING);
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>获取文件属性</h3>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FilesDemo5 {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
Path path</span>= Paths.get("demo7.txt"<span style="color: #000000;">);

System.out.println(Files.getLastModifiedTime(path));
System.out.println(Files.size(path));
System.out.println(Files.isSymbolicLink(path));
System.out.println(Files.isDirectory(path));
System.out.println(Files.readAttributes(path,</span>"*"<span style="color: #000000;">));
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>遍历一个文件夹</h3>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FilesDemo6 {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
Path path</span>= Paths.get("demo3\\demo2"<span style="color: #000000;">);

DirectoryStream</span>&lt;Path&gt; paths=<span style="color: #000000;">Files.newDirectoryStream(path);
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(Path p:paths){
System.out.println(p.getFileName());
}
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<h3>遍历整个文件目录</h3>
<p>FileVisitor需要调用方自行实现，然后作为参数传入walkFileTree()； FileVisitor的每个方法会在遍历过程中被调用多次。</p>
<div class="highlight">
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FilesDemo7 {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
Path path</span>= Paths.get("demo3\\demo2"<span style="color: #000000;">);

List</span>&lt;Path&gt; paths=<span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
Files.walkFileTree(path,</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> FileVisitor(paths));
System.out.println(</span>"paths:"+<span style="color: #000000;">paths);
}

</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> FileVisitor <span style="color: #0000ff;">extends</span> SimpleFileVisitor&lt;Path&gt;<span style="color: #000000;"> {
</span><span style="color: #0000ff;">private</span> List&lt;Path&gt;<span style="color: #000000;"> paths;

</span><span style="color: #0000ff;">public</span> FileVisitor(List&lt;Path&gt;<span style="color: #000000;"> paths){
</span><span style="color: #0000ff;">this</span>.paths=<span style="color: #000000;">paths;
}

@Override
</span><span style="color: #0000ff;">public</span> FileVisitResult visitFile(Path file, BasicFileAttributes attrs) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
</span><span style="color: #0000ff;">if</span>(file.toString().endsWith(".txt"<span style="color: #000000;">)){
paths.add(file.getFileName());
}
</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">super</span><span style="color: #000000;">.visitFile(file, attrs);
}
}
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
</div>
<p>输出结果：</p>
<div class="highlight">
<pre><code class="language-text">paths:[a.txt, test2.txt, test.txt, test3.txt]</code></pre>
</div>
<blockquote>免费Java高级资料需要自己领取，涵盖了Java、Redis、MongoDB、MySQL、Zookeeper、Spring Cloud、Dubbo高并发分布式等教程，一共30G。<br>传送门：<a class=" external" href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/JzddfH-7yNudmkjT0IRL8Q" rel="nofollow noreferrer" target="_blank" data-za-detail-view-id="1043"><span class="invisible">https://<span class="visible">mp.weixin.qq.com/s/Jzdd<span class="invisible">fH-7yNudmkjT0IRL8Q</span></span></span></a></blockquote></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info"><div id="green_channel">
<a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(10955256,cb_blogId,1);green_channel_success(this,'谢谢推荐！');">好文要顶</a>
<a id="green_channel_follow" onclick="follow('517e4646-ebe9-448a-4082-08d5cefee95e');" href="javascript:void(0);">关注我</a>
<a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
<a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="//common.cnblogs.com/images/icon_weibo_24.png" alt=""></a>
<a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="//common.cnblogs.com/images/wechat.png" alt=""></a>
</div>
<div id="author_profile">
<div id="author_profile_info" class="author_profile_info">
<a href="https://home.cnblogs.com/u/yuxiang1/" target="_blank"><img src="//pic.cnblogs.com/face/1420036/20180611161102.png" class="author_avatar" alt=""></a>
<div id="author_profile_detail" class="author_profile_info">
<a href="https://home.cnblogs.com/u/yuxiang1/">手留余香·</a><br>
<a href="https://home.cnblogs.com/u/yuxiang1/followees">关注 - 1</a><br>
<a href="https://home.cnblogs.com/u/yuxiang1/followers">粉丝 - 61</a>
</div>
</div>
<div class="clear"></div>
<div id="author_profile_honor"></div>
<div id="author_profile_follow">
<a href="javascript:void(0);" onclick="follow('517e4646-ebe9-448a-4082-08d5cefee95e');return false;">+加关注</a>
</div>
</div>
<div id="div_digg">
<div class="diggit" onclick="votePost(10955256,'Digg')">
<span class="diggnum" id="digg_count">0</span>
</div>
<div class="buryit" onclick="votePost(10955256,'Bury')">
<span class="burynum" id="bury_count">0</span>
</div>
<div class="clear"></div>
<div class="diggword" id="digg_tips">
</div>
</div>
<script type="text/javascript">
currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="https://www.cnblogs.com/yuxiang1/p/10949463.html" class="p_n_p_prefix">« </a> 上一篇：<a href="https://www.cnblogs.com/yuxiang1/p/10949463.html" title="发布于2019-05-30 14:48">Java线程安全面试题，你真的了解吗？</a><br><a href="https://www.cnblogs.com/yuxiang1/p/10959678.html" class="p_n_p_prefix">» </a> 下一篇：<a href="https://www.cnblogs.com/yuxiang1/p/10959678.html" title="发布于2019-06-01 15:09">基于JDK1.8，Java容器源码分析</a><br></div>
</div>


</div>