### 5.2.6 java线程池
<div class="post">
	<h1 class="postTitle"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/CarpenterLee/p/9558026.html">Java线程池详解</a></h1>
	<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"><p>构造一个线程池为什么需要几个参数？如果避免线程池出现OOM？<code>Runnable</code>和<code>Callable</code>的区别是什么？本文将对这些问题一一解答，同时还将给出使用线程池的常见场景和代码片段。</p>
<h2 id="基础知识">基础知识</h2>
<h3 id="executors创建线程池">Executors创建线程池</h3>
<p>Java中创建线程池很简单，只需要调用<code>Executors</code>中相应的便捷方法即可，比如<code>Executors.newFixedThreadPool(int nThreads)</code>，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。</p>
<p><code>Executors</code>创建线程池便捷方法列表：</p>
<table>
<thead>
<tr class="header">
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>newFixedThreadPool(int nThreads)</td>
<td>创建固定大小的线程池</td>
</tr>
<tr class="even">
<td>newSingleThreadExecutor()</td>
<td>创建只有一个线程的线程池</td>
</tr>
<tr class="odd">
<td>newCachedThreadPool()</td>
<td>创建一个不限线程数上限的线程池，任何提交的任务都将立即执行</td>
</tr>
</tbody>
</table>
<p>小程序使用这些快捷方法没什么问题，对于服务端需要长期运行的程序，创建线程池应该直接使用<code>ThreadPoolExecutor</code>的构造方法。没错，上述<code>Executors</code>方法创建的线程池就是<code>ThreadPoolExecutor</code>。</p>
<h3 id="threadpoolexecutor构造方法">ThreadPoolExecutor构造方法</h3>
<p><code>Executors</code>中创建线程池的快捷方法，实际上是调用了<code>ThreadPoolExecutor</code>的构造方法（定时任务使用的是<code>ScheduledThreadPoolExecutor</code>），该类构造方法参数列表如下：</p>
<pre class="java"><code class="hljs"><span class="hljs-comment">// Java线程池的完整构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(
  <span class="hljs-keyword">int</span> corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。
  <span class="hljs-keyword">int</span> maximumPoolSize, // 线程数的上限
  <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，
                                     // 超过这个时间，多余的线程会被回收。
  BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列
  ThreadFactory threadFactory, // 新线程的产生方式
  RejectedExecutionHandler handler)</span> <span class="hljs-comment">// 拒绝策略</span></span></code></pre>
<p>竟然有7个参数，很无奈，构造一个线程池确实需要这么多参数。这些参数中，比较容易引起问题的有<code>corePoolSize</code>, <code>maximumPoolSize</code>, <code>workQueue</code>以及<code>handler</code>：</p>
<ul>
<li><code>corePoolSize</code>和<code>maximumPoolSize</code>设置不当会影响效率，甚至耗尽线程；</li>
<li><code>workQueue</code>设置不当容易导致OOM；</li>
<li><code>handler</code>设置不当会导致提交任务时抛出异常。</li>
</ul>
<p>正确的参数设置方式会在下文给出。</p>
<h3 id="线程池的工作顺序">线程池的工作顺序</h3>
<blockquote>
<p>If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing.<br>
If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.<br>
If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.</p>
</blockquote>
<p>corePoolSize -&gt; 任务队列 -&gt; maximumPoolSize -&gt; 拒绝策略</p>
<h3 id="runnable和callable">Runnable和Callable</h3>
<p>可以向线程池提交的任务有两种：<code>Runnable</code>和<code>Callable</code>，二者的区别如下：</p>
<ol>
<li>方法签名不同，<code>void Runnable.run()</code>, <code>V Callable.call() throws Exception</code></li>
<li>是否允许有返回值，<code>Callable</code>允许有返回值</li>
<li>是否允许抛出异常，<code>Callable</code>允许抛出异常。</li>
</ol>
<p><code>Callable</code>是JDK1.5时加入的接口，作为<code>Runnable</code>的一种补充，允许有返回值，允许抛出异常。</p>
<h3 id="三种提交任务的方式">三种提交任务的方式：</h3>
<table>
<thead>
<tr class="header">
<th>提交方式</th>
<th>是否关心返回结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></td>
<td>是</td>
</tr>
<tr class="even">
<td><code>void execute(Runnable command)</code></td>
<td>否</td>
</tr>
<tr class="odd">
<td><code>Future&lt;?&gt; submit(Runnable task)</code></td>
<td>否，虽然返回Future，但是其get()方法总是返回null</td>
</tr>
</tbody>
</table>
<h2 id="如何正确使用线程池">如何正确使用线程池</h2>
<h3 id="避免使用无界队列">避免使用无界队列</h3>
<p>不要使用<code>Executors.newXXXThreadPool()</code>快捷方法创建线程池，因为这种方式会使用无界的任务队列，为避免OOM，我们应该使用<code>ThreadPoolExecutor</code>的构造方法手动指定队列的最大长度：</p>
<pre class="java"><code class="hljs">ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, 
                <span class="hljs-number">0</span>, TimeUnit.SECONDS, 
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">512</span>), <span class="hljs-comment">// 使用有界队列，避免OOM</span>
                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</code></pre>
<h3 id="明确拒绝任务时的行为">明确拒绝任务时的行为</h3>
<p>任务队列总有占满的时候，这是再<code>submit()</code>提交新的任务会怎么样呢？<code>RejectedExecutionHandler</code>接口为我们提供了控制方式，接口定义如下：</p>
<pre class="java"><code class="hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span></span>;
}</code></pre>
<p>线程池给我们提供了几种常见的拒绝策略：<br>
<img src="https://cdn.yuque.com/lark/2018/png/54845/1521946099154-17b29e18-6853-4b39-8e2a-007ea89387bd.png" alt="undefined"></p>
<table>
<thead>
<tr class="header">
<th>拒绝策略</th>
<th>拒绝行为</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AbortPolicy</td>
<td>抛出RejectedExecutionException</td>
</tr>
<tr class="even">
<td>DiscardPolicy</td>
<td>什么也不做，直接忽略</td>
</tr>
<tr class="odd">
<td>DiscardOldestPolicy</td>
<td>丢弃执行队列中最老的任务，尝试为当前提交的任务腾出位置</td>
</tr>
<tr class="even">
<td>CallerRunsPolicy</td>
<td>直接由提交任务者执行这个任务</td>
</tr>
</tbody>
</table>
<p>线程池默认的拒绝行为是<code>AbortPolicy</code>，也就是抛出<code>RejectedExecutionHandler</code>异常，该异常是非受检异常，很容易忘记捕获。如果不关心任务被拒绝的事件，可以将拒绝策略设置成<code>DiscardPolicy</code>，这样多余的任务会悄悄的被忽略。</p>
<pre class="java"><code class="hljs">ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, 
                <span class="hljs-number">0</span>, TimeUnit.SECONDS, 
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">512</span>), 
                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy());<span class="hljs-comment">// 指定拒绝策略</span></code></pre>
<h3 id="获取处理结果和异常">获取处理结果和异常</h3>
<p>线程池的处理结果、以及处理过程中的异常都被包装到<code>Future</code>中，并在调用<code>Future.get()</code>方法时获取，执行过程中的异常会被包装成<code>ExecutionException</code>，<code>submit()</code>方法本身不会传递结果和任务执行过程中的异常。获取执行结果的代码可以这样写：</p>
<pre class="java"><code class="hljs">ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);
Future&lt;Object&gt; future = executorService.submit(<span class="hljs-keyword">new</span> Callable&lt;Object&gt;() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"exception in call~"</span>);<span class="hljs-comment">// 该异常会在调用Future.get()时传递给调用者</span>
        }
    });
    
<span class="hljs-keyword">try</span> {
  Object result = future.get();
} <span class="hljs-keyword">catch</span> (InterruptedException e) {
  <span class="hljs-comment">// interrupt</span>
} <span class="hljs-keyword">catch</span> (ExecutionException e) {
  <span class="hljs-comment">// exception in Callable.call()</span>
  e.printStackTrace();
}</code></pre>
<p>上述代码输出类似如下：<br>
<img src="https://cdn.yuque.com/lark/2018/png/54845/1521958632700-9049b478-dd93-4b21-b158-10a97acb7699.png" alt="undefined"></p>
<h2 id="线程池的常用场景">线程池的常用场景</h2>
<h3 id="正确构造线程池">正确构造线程池</h3>
<pre class="java"><code class="hljs"><span class="hljs-keyword">int</span> poolSize = Runtime.getRuntime().availableProcessors() * <span class="hljs-number">2</span>;
BlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">512</span>);
RejectedExecutionHandler policy = <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy();
executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(poolSize, poolSize,
    <span class="hljs-number">0</span>, TimeUnit.SECONDS,
            queue,
            policy);</code></pre>
<h3 id="获取单个结果">获取单个结果</h3>
<p>过<code>submit()</code>向线程池提交任务后会返回一个<code>Future</code>，调用<code>V Future.get()</code>方法能够阻塞等待执行结果，<code>V get(long timeout, TimeUnit unit)</code>方法可以指定等待的超时时间。</p>
<h3 id="获取多个结果">获取多个结果</h3>
<p>如果向线程池提交了多个任务，要获取这些任务的执行结果，可以依次调用<code>Future.get()</code>获得。但对于这种场景，我们更应该使用<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorCompletionService.html">ExecutorCompletionService</a>，该类的<code>take()</code>方法总是阻塞等待某一个任务完成，然后返回该任务的<code>Future</code>对象。向<code>CompletionService</code>批量提交任务后，只需调用相同次数的<code>CompletionService.take()</code>方法，就能获取所有任务的执行结果，获取顺序是任意的，取决于任务的完成顺序：</p>
<pre class="java"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(Executor executor, Collection&lt;Callable&lt;Result&gt;&gt; solvers)</span>
   <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>{
   
   CompletionService&lt;Result&gt; ecs = <span class="hljs-keyword">new</span> ExecutorCompletionService&lt;Result&gt;(executor);<span class="hljs-comment">// 构造器</span>
   
   <span class="hljs-keyword">for</span> (Callable&lt;Result&gt; s : solvers)<span class="hljs-comment">// 提交所有任务</span>
       ecs.submit(s);
       
   <span class="hljs-keyword">int</span> n = solvers.size();
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<span class="hljs-comment">// 获取每一个完成的任务</span>
       Result r = ecs.take().get();
       <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)
           use(r);
   }
}</code></pre>
<h3 id="单个任务的超时时间">单个任务的超时时间</h3>
<p><code>V Future.get(long timeout, TimeUnit unit)</code>方法可以指定等待的超时时间，超时未完成会抛出<code>TimeoutException</code>。</p>
<h3 id="多个任务的超时时间">多个任务的超时时间</h3>
<p>等待多个任务完成，并设置最大等待时间，可以通过<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a>完成：</p>
<pre class="java"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLatch</span><span class="hljs-params">(ExecutorService executorService, List&lt;Runnable&gt; tasks)</span> 
    <span class="hljs-keyword">throws</span> InterruptedException</span>{
      
CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(tasks.size());
  <span class="hljs-keyword">for</span>(Runnable r : tasks){
      executorService.submit(<span class="hljs-keyword">new</span> Runnable() {
          <span class="hljs-meta">@Override</span>
          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
              <span class="hljs-keyword">try</span>{
                  r.run();
              }<span class="hljs-keyword">finally</span> {
                  latch.countDown();<span class="hljs-comment">// countDown</span>
              }
          }
      });
  }
  latch.await(<span class="hljs-number">10</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 指定超时时间</span>
  }</code></pre>
<h2 id="线程池和装修公司">线程池和装修公司</h2>
<p>以运营一家装修公司做个比喻。公司在办公地点等待客户来提交装修请求；公司有固定数量的正式工以维持运转；旺季业务较多时，新来的客户请求会被排期，比如接单后告诉用户一个月后才能开始装修；当排期太多时，为避免用户等太久，公司会通过某些渠道（比如人才市场、熟人介绍等）雇佣一些临时工（注意，招聘临时工是在排期排满之后）；如果临时工也忙不过来，公司将决定不再接收新的客户，直接拒单。</p>
<p>线程池就是程序中的“装修公司”，代劳各种脏活累活。上面的过程对应到线程池上：</p>
<pre class="java"><code class="hljs"><span class="hljs-comment">// Java线程池的完整构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(
  <span class="hljs-keyword">int</span> corePoolSize, // 正式工数量
  <span class="hljs-keyword">int</span> maximumPoolSize, // 工人数量上限，包括正式工和临时工
  <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, // 临时工游手好闲的最长时间，超过这个时间将被解雇
  BlockingQueue&lt;Runnable&gt; workQueue, // 排期队列
  ThreadFactory threadFactory, // 招人渠道
  RejectedExecutionHandler handler)</span> <span class="hljs-comment">// 拒单方式</span></span></code></pre>
<h2 id="总结">总结</h2>
<p><code>Executors</code>为我们提供了构造线程池的便捷方法，对于服务器程序我们应该杜绝使用这些便捷方法，而是直接使用线程池<code>ThreadPoolExecutor</code>的构造方法，避免无界队列可能导致的OOM以及线程个数限制不当导致的线程数耗尽等问题。<code>ExecutorCompletionService</code>提供了等待所有任务执行结束的有效方式，如果要设置等待的超时时间，则可以通过<code>CountDownLatch</code>完成。</p>
<h2 id="参考">参考</h2>
<p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor API Doc</a></p>
</div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag">标签: <a href="https://www.cnblogs.com/CarpenterLee/tag/Java/">Java</a>, <a href="https://www.cnblogs.com/CarpenterLee/tag/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a>, <a href="https://www.cnblogs.com/CarpenterLee/tag/ThreadPool/">ThreadPool</a></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(9558026,cb_blogId,1);green_channel_success(this,'谢谢推荐！');">好文要顶</a>
            <a id="green_channel_follow" onclick="follow('df1cf1f4-0106-e611-9fc1-ac853d9f53cc');" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="//common.cnblogs.com/images/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="//common.cnblogs.com/images/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/CarpenterLee/" target="_blank"><img src="//pic.cnblogs.com/face/939998/20181026213633.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/CarpenterLee/">CarpenterLee</a><br>
            <a href="https://home.cnblogs.com/u/CarpenterLee/followees">关注 - 2</a><br>
            <a href="https://home.cnblogs.com/u/CarpenterLee/followers">粉丝 - 427</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow('df1cf1f4-0106-e611-9fc1-ac853d9f53cc');return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(9558026,'Digg')">
        <span class="diggnum" id="digg_count">6</span>
    </div>
    <div class="buryit" onclick="votePost(9558026,'Bury')">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
<script type="text/javascript">
    currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="https://www.cnblogs.com/CarpenterLee/p/8241042.html" class="p_n_p_prefix">« </a> 上一篇：<a href="https://www.cnblogs.com/CarpenterLee/p/8241042.html" title="发布于2018-01-08 09:08">Java Proxy和CGLIB动态代理原理</a><br></div>
</div>


<div class="postDesc">posted on <span id="post-date">2018-08-30 08:32</span> <a href="https://www.cnblogs.com/CarpenterLee/">CarpenterLee</a> 阅读(<span id="post_view_count">4193</span>) 评论(<span id="post_comment_count">1</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9558026" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9558026);return false;">收藏</a></div>
</div>