## 组合索引的最左优先原则

<div id="topics">
<div class="post">
<h1 class="postTitle">
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/CKhomepage/p/10613618.html">组合索引的最左优先原则</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div id="cnblogs_post_body" class="blogpost-body"><p>MySQL数据库，game_order表表结构如下，下面哪些sql能使用到索引？</p>
<p><img src="https://img2018.cnblogs.com/blog/1634165/201903/1634165-20190328103958526-580710965.png" alt=""></p>
<div class="answer-brief">
<p>这道题目考察的知识点是MySQL组合索引（复合索引）的最左优先原则。</p>
<p><span style="color: #ff0000;"><strong>最左前缀匹配原则</strong></span></p>
<p>在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，组合索引的第一个字段必须出现在查询组句中，这个索引才会被用到，示例：<br>
对列col1、列col2和列col3建一个联合索引：</p>
<p><span style="font-family: times new roman, times;"><code class="sql keyword">KEY</code> <code class="sql plain">test_col1_col2_col3 </code><code class="sql keyword">on</code> <code class="sql plain">test(col1,col2,col3);</code></span></p>
<p>联合索引<span style="font-family: times new roman, times;"> <code>test_col1_col2_col3 </code></span>实际建立了<span style="font-family: times new roman, times;"><code>(col1)、(col1,col2)、(col,col2,col3)</code></span>三个索引。</p>
<p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。</p>
<p><span style="color: #ff0000;"><strong>注意</strong></span></p>
<p>索引的字段可以是任意顺序的，如：</p>
<div class="container">
<div class="line number1 index0 alt2"><span style="font-family: times new roman, times;"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">test </code><code class="sql keyword">WHERE</code> <code class="sql plain">col1=“1” </code><code class="sql color1">AND</code> <code class="sql plain">clo2=“2”</code></span></div>
<div class="line number2 index1 alt1"><span style="font-family: times new roman, times;"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">test </code><code class="sql keyword">WHERE</code> <code class="sql plain">col2=“2” </code><code class="sql color1">AND</code> <code class="sql plain">clo1=“1”</code></span>
<p>这两个查询语句都会用到索引(col1,col2)，mysql创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段col1的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段col2进行排序。其实就相当于实现了类似
order by col1 col2这样一种排序规则。</p>



</div>



</div>
<p>所以题目会创建三个索引（plat_order_id）、（plat_order_id与plat_game_id的组合索引）、（plat_order_id、plat_game_id与plat_id的组合索引）。根据最左匹配原则，where语句必须要有plat_order_id才能调用索引（如果没有plat_order_id字段那么一个索引也调用不到），如果同时出现plat_order_id与plat_game_id则会调用两者的组合索引，如果同时出现三者则调用三者的组合索引。</p>
<p><span style="color: #ff0000;"><strong>思考</strong><br>
</span></p>
<p>

对于联合索引(col1,col2,col3)，查询语句<span style="font-family: times new roman, times;"><code>SELECT * FROM test WHERE col2=2;</code></span>是否能够<span style="color: #0000ff;">触发</span>索引？</p>
<div class="container">
<div class="line number1 index0 alt2"><code class="sql plain">EXPLAIN </code><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">test </code><code class="sql keyword">WHERE</code> <code class="sql plain">col2=2;</code></div>
<div class="line number2 index1 alt1"><code class="sql plain">EXPLAIN </code><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">test </code><code class="sql keyword">WHERE</code> <code class="sql plain">col1=1;</code></div>
<div class="line number2 index1 alt1">
<p>借助mysql查询优化器explain，explain会纠正sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划，观察explain中上述两个sql语句结果的type字段。查询中分别是：</p>
<ul>
<li>type: index</li>
<li>type: ref<br>
</li>




</ul>
<p>index：这种类型表示mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个联合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会<span style="color: #0000ff;">触发</span>索引。<br>
ref：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。</p>



</div>



</div>
<p><span style="color: #ff0000;"><strong>为什么要使用联合索引</strong><br>
</span></p>
<p><strong>减少开销。</strong>建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！<br>
</p>
<p><strong>覆盖索引。</strong>对联合索引(col1,col2,col3)，如果有如下的sql: select 
col1,col2,col3 from test where col1=1 and 
col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。<br>
</p>
<p>

<strong>效率高。</strong>索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select 
from table where col1=1 and col2=2 and 
col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2
and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！</p>



</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory">分类: <a href="https://www.cnblogs.com/CKhomepage/category/1430769.html" target="_blank">MySQL之sql语句</a></div>
<div id="EntryTag"></div>
<div id="blog_post_info"><div id="green_channel">
<a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(10613618,cb_blogId,1);green_channel_success(this,'谢谢推荐！');">好文要顶</a>
<a id="green_channel_follow" onclick="follow('a9cf7079-96d7-45a5-5870-08d6aa739bca');" href="javascript:void(0);">关注我</a>
<a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
<a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="//common.cnblogs.com/images/icon_weibo_24.png" alt=""></a>
<a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="//common.cnblogs.com/images/wechat.png" alt=""></a>
</div>
<div id="author_profile">
<div id="author_profile_info" class="author_profile_info">
<a href="https://home.cnblogs.com/u/CKhomepage/" target="_blank"><img src="//pic.cnblogs.com/face/sample_face.gif" class="author_avatar" alt=""></a>
<div id="author_profile_detail" class="author_profile_info">
<a href="https://home.cnblogs.com/u/CKhomepage/">小六boss</a><br>
<a href="https://home.cnblogs.com/u/CKhomepage/followees">关注 - 1</a><br>
<a href="https://home.cnblogs.com/u/CKhomepage/followers">粉丝 - 0</a>
</div>
</div>
<div class="clear"></div>
<div id="author_profile_honor"></div>
<div id="author_profile_follow">
<a href="javascript:void(0);" onclick="follow('a9cf7079-96d7-45a5-5870-08d6aa739bca');return false;">+加关注</a>
</div>
</div>
<div id="div_digg">
<div class="diggit" onclick="votePost(10613618,'Digg')">
<span class="diggnum" id="digg_count">0</span>
</div>
<div class="buryit" onclick="votePost(10613618,'Bury')">
<span class="burynum" id="bury_count">0</span>
</div>
<div class="clear"></div>
<div class="diggword" id="digg_tips">
</div>
</div>
<script type="text/javascript">
currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="https://www.cnblogs.com/CKhomepage/p/10613158.html" class="p_n_p_prefix">« </a> 上一篇：<a href="https://www.cnblogs.com/CKhomepage/p/10613158.html" title="发布于2019-03-28 10:18">Java基础之二维数组的创建与访问</a><br><a href="https://www.cnblogs.com/CKhomepage/p/10613742.html" class="p_n_p_prefix">» </a> 下一篇：<a href="https://www.cnblogs.com/CKhomepage/p/10613742.html" title="发布于2019-03-28 11:20">父类引用指向子类对象</a><br></div>
</div>


</div>
<div class="postDesc">posted @ <span id="post-date">2019-03-28 11:05</span> <a href="https://www.cnblogs.com/CKhomepage/">小六boss</a> 阅读(<span id="post_view_count">194</span>) 评论(<span id="post_comment_count">0</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=10613618" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(10613618);return false;">收藏</a></div>
</div>
<script type="text/javascript">var allowComments=true,cb_blogId=504452,cb_entryId=10613618,cb_blogApp=currentBlogApp,cb_blogUserGuid='a9cf7079-96d7-45a5-5870-08d6aa739bca',cb_entryCreatedDate='2019/3/28 11:05:00';loadViewCount(cb_entryId);var cb_postType=1;var isMarkdown=false;</script>

</div>