<article data-v-0c3b915a="" itemscope="itemscope" itemtype="http://schema.org/Article" class="entry-content-box" data-v-c6a5c026=""><meta itemprop="url" content="https://juejin.im/entry/5a4b52eef265da431120954b"><meta itemprop="headline" content="MySQL-InnoDB-MVCC多版本并发控制"><meta itemprop="keywords" content="MySQL,数据库"><meta itemprop="datePublished" content="2018-01-02T09:37:50.865Z"><meta itemprop="image" content="https://b-gold-cdn.xitu.io/icon/icon-128.png"><div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="红烧不是清蒸"><meta itemprop="url" content="https://juejin.im/user/59845265f265da3e13575bb2"></div><div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"><div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://b-gold-cdn.xitu.io/icon/icon-white-180.png"><meta itemprop="width" content="180"><meta itemprop="height" content="180"></div></div><h1 data-v-0c3b915a="">MySQL-InnoDB-MVCC多版本并发控制</h1><div data-v-0c3b915a="" class="entry-public-info"><div data-v-0c3b915a="" class="text-muted info-item">阅读 1159</div><div data-v-0c3b915a="" class="text-muted info-item">收藏 46</div><div data-v-0c3b915a="" class="text-muted info-item">2018-01-02</div></div><div data-v-0c3b915a="" class="originalUrl">原文链接：<a data-v-0c3b915a="" st:name="originLink" href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000012650596" rel="nofollow noopener noreferrer" target="_blank">segmentfault.com</a></div><a data-v-0c3b915a="" class="banner" href="https://juejin.im/post/5d381e8051882541175c0fd0" target="_blank"><span data-v-0c3b915a="" class="text">如何通过 RESTful API 玩转Agora云录制</span><span data-v-0c3b915a="" class="link">juejin.im</span></a><div data-v-0c3b915a="" itemprop="articleBody" class="entry-content article-content">
<h2 data-id="heading-0">MVCC</h2>
<p>(Multiversion Concurrency Control)1.先引用《高性能MySQL》中对MVCC的部分介绍</p>
<blockquote>
<ul>
<li>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。<strong>基于提升并发性能的考虑</strong>, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。</li>
<li>可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</li>
<li>MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。</li>
<li>MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 <code>SERIALIZABLE</code> 则会对所有读取的行都加锁。</li>
</ul>
</blockquote>
<p>2.可以了解到:</p>
<ul>
<li>MVCC是被Mysql中<code>事务型存储引擎InnoDB</code>所支持的;</li>
<li> <strong>应对高并发事务, MVCC比单纯的加行锁更有效, 开销更小</strong>;</li>
<li>MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;</li>
<li>MVCC可以使用 <code>乐观(optimistic)锁</code> 和 <code>悲观(pessimistic)锁</code>来实现;</li>
</ul>
<p>3.另外, 《高性能Mysql》中提到, InnoDB的MVCC是通过在每行记录后面保存<strong>两个隐藏的列</strong>来实现的..... 这个貌似和网上很多观点不同, 具体可以参考<a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-multi-versioning.html" target="_blank" rel="nofollow noopener noreferrer">MySQL官方对InnoDB-MVCC的解释</a><br><strong>可以看到, InnoDB存储引擎在数据库每行数据的后面添加了三个字段, 不是两个!!</strong></p>
<h2 data-id="heading-1">分析</h2>
<p>1.InnoDB存储引擎在数据库每行数据的后面添加了三个字段</p>
<ul>
<li>6字节的事务ID(<code>DB_TRX_ID</code>)字段: 标记了最新更新这条行记录的transaction id，每处理一个事务，其值自动+1<br>另外，删除在内部被视为一个更新，其中行中的特殊位被设置为将其标记为已删除</li>
<li>7字节的回滚指针(<code>DB_ROLL_PTR</code>)字段 : 指向当前记录项的rollback segment的 <code>undo log</code>(撤销日志记录), 找之前版本的数据就是通过这个指针。</li>
<li>6字节的<code>DB_ROW_ID</code>字段: 当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，否则聚集索引中不包括这个值，这个用于索引当中。<br>结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID
了 。<br>关于聚簇索引, 《高性能MySQL》中的篇幅对我来说已经够用了, 稍后会整理一下以前的学习笔记, 然后更新上来。</li>
</ul>
<p>2.下面来演示一下事务对某行记录的更新过程:<br><img data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b63c130c3c306?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" class="lazyload inited loaded" data-width="592" data-height="800" src="https://user-gold-cdn.xitu.io/2018/1/2/160b63c130c3c306?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br>3.<code>read view</code></p>
<ul>
<li>判断当前版本数据项是否可见</li>
<li>在innodb中, 每创建一个新事务, 存储引擎都会将当前系统中的活跃事务列表(trx_sys-&gt;trx_list)创建一个副本(<code>read view</code>), 副本中保存的是系统中当前不应该被本事务看到的其他事务id列表。</li>
<li>当用户在事务中要读取某行记录的时候, innodb会将该行当前的版本号与该read view进行比较, 下面介绍 <code>比较算法</code> ;</li>
</ul>
<h2 data-id="heading-2">比较算法:</h2>
<p>设该行的当前事务id为<code>trx_id_current</code>, <code>read view</code>中该行最早的事务id为<code>trx_id_first</code>, 最迟的事务id为<code>trx_id_last</code></p>
<ol>
<li>如果<code>trx_id_current &lt; trx_id_first</code>, 那就表示<br>当前事务在读取该行记录的时候, 给该行数据设置的隐藏事务ID字段的值, 比<code>read view</code>中记录的 '当前系统中其他事务给该行记录设置的事务ID都要小'。<br>这就意味着, 当前所有和该行记录有关的事务中, 当前事务是第一个读取到该行记录的, 没有任何在当前事务前面对该行数据做过更改但还没有提交的事务, 所以当前事务可以直接拿到表中<strong>稳定的数据</strong>!</li>
<li>如果<code>trx_id_current &gt; trx_id_last</code> 的话，那就表示<br>当前事务在读取该行记录的时候, 给该行数据设置的隐藏事务ID字段的值, 比<code>read view</code>中记录的 '当前系统中其他事务给该行记录设置的事务ID都要大'。<br>这就意味着, 当前所有和该行记录有关的事务中, 当前事务是最后一个读取到该行记录的, 所以需要从该行记录的<code>DB_ROLL_PTR</code>指针所指向的回滚段中取出最新的undo-log的版本号,
将它赋值给<code>trx_id_current</code>，然后继续重新开始整套比较算法, 这么迭代下去, 会在undo-log中一层层往下找下去, 最终就会取到<strong>稳定的数据</strong>!</li>
<li>如果 <code>trx_id_first &lt; trx_id_current &lt; trx_id_last</code>, 同上;</li>
</ol>
<h2 data-id="heading-3">对比<code>READ COMMITED</code>和<code>REPEATABLE READ</code> </h2>
<ol>
<li> <code>read view</code> 生成原则如果想深入了解的话可以自行百度或者参考<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Ffd51cb8dc03b" target="_blank" rel="nofollow noopener noreferrer">fxliutao的博客</a> </li>
<li>之前已经了解到 MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;</li>
<li>
<p>并且根据 <code>read view</code> 的生成原则, 导致在这两个不同隔离级别下, <code>read committed</code> 总是读最新一份快照数据, 而repeatable read 读事务开始时的行数据版本;</p>
<ul>
<li>使得 <code>READ COMMITED</code> 级别能够保证, 只要是当前<strong>语句执行前</strong>已经提交的数据都是可见的**。注意和<code>REPEATABLE READ</code>级别的区!!!</li>
<li>使得 <code>REPEATABLE READ</code> 级别能够保证, 只要是当前<strong>事务执行前</strong>已经提交的数据都是可见的。</li>
</ul>
</li>
</ol>
<h2 data-id="heading-4">小结</h2>
<ol>
<li>
<p>一般我们认为MVCC有下面几个特点：</p>
<ul>
<li>每行数据都存在一个版本，每次数据更新时都更新该版本</li>
<li>修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰</li>
<li>保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)</li>
<li>就是每行都有版本号，保存时根据版本号决定是否成功，<strong>听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功</strong> </li>
</ul>
</li>
<li>
<p>而InnoDB实现MVCC的方式是:</p>
<ul>
<li>事务以排他锁的形式修改原始数据</li>
<li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li>
<li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li>
</ul>
</li>
<li> <strong>二者最本质的区别是</strong>: 当修改数据时是否要<code>排他锁定</code>，如果锁定了还算不算是MVCC？</li>
</ol>
<ul>
<li>Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, <code>undo log</code> 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。</li>
<li>比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 <code>第一类更新丢失</code> 的情况。</li>
<li>也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。</li>
</ul>
<h2 data-id="heading-5">本文主要参考和引用如下文章</h2>
<blockquote> <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.7%2Fen%2Finnodb-multi-versioning.html" target="_blank" rel="nofollow noopener noreferrer">MySQL官方对InnoDB-MVCC的解释</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Ffd51cb8dc03b" target="_blank" rel="nofollow noopener noreferrer">fxliutao的博客</a>然后结合自己的理解重新整理了一篇新的文章;</blockquote>
</div><div data-v-0c3b915a="" class="footer"><ul data-v-0c3b915a="" class="tag-list"><li data-v-0c3b915a="" class="item"><a data-v-0c3b915a="" href="/tag/MySQL" class="">MySQL</a></li><li data-v-0c3b915a="" class="item"><a data-v-0c3b915a="" href="/tag/%E6%95%B0%E6%8D%AE%E5%BA%93" class="">数据库</a></li></ul><section data-v-0c3b915a=""><div data-v-a5b7c540="" data-v-0c3b915a="" class="wechat-banner wechat-banner"><img data-v-a5b7c540="" src="https://b-gold-cdn.xitu.io/v3/static/img/backend.58ef824.png" class="wechat-img"></div></section><!----><div data-v-0c3b915a="" class="related-entry-list-box"><div data-v-0c3b915a="" class="title">相关热门文章</div><ul data-v-0c3b915a="" class="related-entry-list"><li data-v-0c3b915a="" class="item"><div data-v-4746b1eb="" data-v-0c3b915a="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-4746b1eb="" href="/post/5d3f9cc1f265da03a31d1192" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-9b8b7618="" data-v-c03cd73e="" data-v-4746b1eb="" data-src="https://b-gold-cdn.xitu.io/v3/static/img/default-thumb.4810307.png?imageView2/1/q/85/format/webp/interlace/1" class="lazy thumb thumb loaded" style="background-image: url(&quot;https://b-gold-cdn.xitu.io/v3/static/img/default-thumb.4810307.png?imageView2/1/q/85/format/webp/interlace/1&quot;); background-size: cover;"></div><div data-v-4746b1eb="" class="info"><div data-v-4746b1eb="" class="row title-row"><span data-v-4746b1eb="" class="title">在工作中常用到的SQL</span></div><div data-v-4746b1eb="" class="row meta-row"><ul data-v-4746b1eb="" class="meta-list"><li data-v-4746b1eb="" class="meta user"><div data-v-4746b1eb="" class="username">Java3y</div></li><li data-v-4746b1eb="" class="meta like"><div data-v-4746b1eb="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-4746b1eb="" class="count">50</div></li><li data-v-4746b1eb="" class="meta comment"><div data-v-4746b1eb="" class="icon icon-comments iconfont icon-xlchatbox"></div><div data-v-4746b1eb="" class="count">5</div></li></ul></div></div></a></div></li><li data-v-0c3b915a="" class="item"><div data-v-4746b1eb="" data-v-0c3b915a="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-4746b1eb="" href="/post/5d3ec40fe51d4561fc6209ce" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-9b8b7618="" data-v-c03cd73e="" data-v-4746b1eb="" data-src="https://b-gold-cdn.xitu.io/v3/static/img/default-thumb.4810307.png?imageView2/1/q/85/format/webp/interlace/1" class="lazy thumb thumb loaded" style="background-image: url(&quot;https://b-gold-cdn.xitu.io/v3/static/img/default-thumb.4810307.png?imageView2/1/q/85/format/webp/interlace/1&quot;); background-size: cover;"></div><div data-v-4746b1eb="" class="info"><div data-v-4746b1eb="" class="row title-row"><span data-v-4746b1eb="" class="title">为什么要有复合索引？</span></div><div data-v-4746b1eb="" class="row meta-row"><ul data-v-4746b1eb="" class="meta-list"><li data-v-4746b1eb="" class="meta user"><div data-v-4746b1eb="" class="username">think123</div></li><li data-v-4746b1eb="" class="meta like"><div data-v-4746b1eb="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-4746b1eb="" class="count">7</div></li><!----></ul></div></div></a></div></li><li data-v-0c3b915a="" class="item"><div data-v-4746b1eb="" data-v-0c3b915a="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-4746b1eb="" href="/post/5d3e8b63f265da1bce3e1988" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-9b8b7618="" data-v-c03cd73e="" data-v-4746b1eb="" data-src="https://b-gold-cdn.xitu.io/v3/static/img/default-thumb.4810307.png?imageView2/1/q/85/format/webp/interlace/1" class="lazy thumb thumb loaded" style="background-image: url(&quot;https://b-gold-cdn.xitu.io/v3/static/img/default-thumb.4810307.png?imageView2/1/q/85/format/webp/interlace/1&quot;); background-size: cover;"></div><div data-v-4746b1eb="" class="info"><div data-v-4746b1eb="" class="row title-row"><span data-v-4746b1eb="" class="title">MySQL锁机制——你想知道的都在这！</span></div><div data-v-4746b1eb="" class="row meta-row"><ul data-v-4746b1eb="" class="meta-list"><li data-v-4746b1eb="" class="meta user"><div data-v-4746b1eb="" class="username">白山丶</div></li><li data-v-4746b1eb="" class="meta like"><div data-v-4746b1eb="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-4746b1eb="" class="count">28</div></li><!----></ul></div></div></a></div></li><li data-v-0c3b915a="" class="item"><div data-v-4746b1eb="" data-v-0c3b915a="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-4746b1eb="" href="/post/5d23ef4ce51d45572c0600bc" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-9b8b7618="" data-v-c03cd73e="" data-v-4746b1eb="" data-src="https://b-gold-cdn.xitu.io/v3/static/img/default-thumb.4810307.png?imageView2/1/q/85/format/webp/interlace/1" class="lazy thumb thumb loaded" style="background-image: url(&quot;https://b-gold-cdn.xitu.io/v3/static/img/default-thumb.4810307.png?imageView2/1/q/85/format/webp/interlace/1&quot;); background-size: cover;"></div><div data-v-4746b1eb="" class="info"><div data-v-4746b1eb="" class="row title-row"><span data-v-4746b1eb="" class="title">我以为我对Mysql索引很了解，直到我遇到了阿里的面试官</span></div><div data-v-4746b1eb="" class="row meta-row"><ul data-v-4746b1eb="" class="meta-list"><li data-v-4746b1eb="" class="meta user"><div data-v-4746b1eb="" class="username">HollisChuang</div></li><li data-v-4746b1eb="" class="meta like"><div data-v-4746b1eb="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-4746b1eb="" class="count">448</div></li><li data-v-4746b1eb="" class="meta comment"><div data-v-4746b1eb="" class="icon icon-comments iconfont icon-xlchatbox"></div><div data-v-4746b1eb="" class="count">37</div></li></ul></div></div></a></div></li><li data-v-0c3b915a="" class="item"><div data-v-4746b1eb="" data-v-0c3b915a="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-4746b1eb="" href="/post/5d351303f265da1bd30596f9" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-9b8b7618="" data-v-c03cd73e="" data-v-4746b1eb="" data-src="https://b-gold-cdn.xitu.io/v3/static/img/default-thumb.4810307.png?imageView2/1/q/85/format/webp/interlace/1" class="lazy thumb thumb loaded" style="background-image: url(&quot;https://b-gold-cdn.xitu.io/v3/static/img/default-thumb.4810307.png?imageView2/1/q/85/format/webp/interlace/1&quot;); background-size: cover;"></div><div data-v-4746b1eb="" class="info"><div data-v-4746b1eb="" class="row title-row"><span data-v-4746b1eb="" class="title">[灵魂拷问]MySQL面试高频一百问(工程师方向)</span></div><div data-v-4746b1eb="" class="row meta-row"><ul data-v-4746b1eb="" class="meta-list"><li data-v-4746b1eb="" class="meta user"><div data-v-4746b1eb="" class="username">呼延十</div></li><li data-v-4746b1eb="" class="meta like"><div data-v-4746b1eb="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-4746b1eb="" class="count">126</div></li><li data-v-4746b1eb="" class="meta comment"><div data-v-4746b1eb="" class="icon icon-comments iconfont icon-xlchatbox"></div><div data-v-4746b1eb="" class="count">13</div></li></ul></div></div></a></div></li></ul></div></div></article>