<div class="post">
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/twoheads/p/9555867.html">循环屏障CyclicBarrier以及和CountDownLatch的区别</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><p>CyclicBarrier 的字面意思是<strong>可循环使用（Cyclic）的屏障（Barrier）</strong>。它要做的事情是，<span style="color: #ff0000;">让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</span></p>
<p><span style="color: #ff0000;">这个<span><strong>屏障</strong></span>之所以用<span><strong>循环</strong></span>修饰，<span style="color: #000000;">是因为在所有的线程释放彼此之后，这个<strong>屏障</strong>是可以重新使用的（reset()方法重置屏障点）。这一点与CountDownLatch不同</span></span></p>
<div>
<div>
<h4>CyclicBarrier</h4>
<p>CyclicBarrier，让一组线程到达一个同步点后再一起继续运行，在其中任意一个线程未达到同步点，其他到达的线程均会被阻塞。</p>
<p>&nbsp;</p>
<p>CyclicBarrier是一种同步机制允许一组线程相互等待，等到所有线程都到达一个屏障点才退出<span lang="en-us" xml:lang="en-us">await方法，它没有直接实现<span lang="en-us" xml:lang="en-us">AQS而是借助<span lang="en-us" xml:lang="en-us">ReentrantLock来实现的同步机制。它是可循环使用的，而<span lang="en-us" xml:lang="en-us">CountDownLatch是一次性的，另外它体现的语义也跟<span lang="en-us" xml:lang="en-us">CountDownLatch不同，<span lang="en-us" xml:lang="en-us">CountDownLatch减少计数到达条件采用的是<span lang="en-us" xml:lang="en-us">release方式，而<span lang="en-us" xml:lang="en-us">CyclicBarrier走向屏障点（<span lang="en-us" xml:lang="en-us">await）采用的是<span lang="en-us" xml:lang="en-us">Acquire方式，<span lang="en-us" xml:lang="en-us">Acquire是会阻塞的，这也实现了<span lang="en-us" xml:lang="en-us">CyclicBarrier的另外一个特点，只要有一个线程中断那么屏障点就被打破，所有线程都将被唤醒（<span lang="en-us" xml:lang="en-us">CyclicBarrier自己负责这部分实现，不是由<span lang="en-us" xml:lang="en-us">AQS调度的），这样也避免了因为一个线程中断引起永远不能到达屏障点而导致其他线程一直等待。屏障点被打破的<span lang="en-us" xml:lang="en-us">CyclicBarrier将不可再使用（会抛出<span lang="en-us" xml:lang="en-us">BrokenBarrierException）除非执行<span lang="en-us" xml:lang="en-us">reset操作。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<h3>CyclicBarrier源码分析</h3>
<ul>
<li>构造方法<br> CyclicBarrier提供两个构造方法<code>CyclicBarrier(int parties)</code>和<code>CyclicBarrier(int parties, Runnable barrierAction)</code>：<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill">&nbsp;</div>
<div class="image-view" data-width="627" data-height="478"><img src="//upload-images.jianshu.io/upload_images/3994601-9f7aa2c9ef36d186.png" alt="" data-original-src="//upload-images.jianshu.io/upload_images/3994601-9f7aa2c9ef36d186.png" data-original-width="627" data-original-height="478" data-original-format="image/png" data-original-filesize="104922"></div>







</div>
<div class="image-caption">CyclicBarrier构造方法</div>







</div>
<ul>
<li>
<p>CyclicBarrier(int parties)<br> 默认构造方法，<span style="color: #ff0000;">参数表示拦截的线程数量</span>。</p>







</li>
<li>
<p>CyclicBarrier(int parties, Runnable barrierAction)<br> 由于线程之前的调度是由CPU决定的，所以默认的构造方法无法设置线程执行优先级，CyclicBarrier提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达同步点时，优先执行线程barrierAction，这样可以更加方便的处理一些负责的业务场景。</p>







</li>







</ul>







</li>







</ul>
<p>创建CyclicBarrier后，每个线程调用await方法告诉CyclicBarrier自己已经到达同步点，然后当前线程被阻塞。接下来我们来看看await方法的具体实现。</p>
<ul>
<li>
<p>await实现<br> CyclicBarrier同样提供带超时时间的await和不带超时时间的await：</p>







<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill">&nbsp;</div>
<div class="image-view" data-width="569" data-height="227"><img src="//upload-images.jianshu.io/upload_images/3994601-190b7149b485721d.png" alt="" data-original-src="//upload-images.jianshu.io/upload_images/3994601-190b7149b485721d.png" data-original-width="569" data-original-height="227" data-original-format="image/png" data-original-filesize="37490"></div>







</div>
<div class="image-caption">await实现</div>







</div>







<br>
<p>整个await方法的核心是dowait方法的调用，我们来看看dowait的具体实现。</p>







</li>
<li>
<p>dowait实现</p>
<ol>
<li>
<p>在dowait的前段部分，主要完成了当所有线程都到达同步点（barrier）时，唤醒所有的等待线程，一起往下继续运行，可根据参数barrierAction决定优先执行的线程。</p>







<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill">&nbsp;</div>
<div class="image-view" data-width="558" data-height="508"><img src="//upload-images.jianshu.io/upload_images/3994601-85bc47dc1b0a0dd7.png" alt="" data-original-src="//upload-images.jianshu.io/upload_images/3994601-85bc47dc1b0a0dd7.png" data-original-width="558" data-original-height="508" data-original-format="image/png" data-original-filesize="70556"></div>







</div>
<div class="image-caption">dowait实现前半部分</div>







</div>







</li>
<li>
<p>在dowait的实现后半部分，主要实现了线程未到达同步点（barrier）时，线程进入Condition自旋等待，直到等待超时或者所有线程都到达barrier时被唤醒。</p>







</li>







</ol>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill">&nbsp;</div>
<div class="image-view" data-width="589" data-height="522"><img src="//upload-images.jianshu.io/upload_images/3994601-441d69b45b6415db.png" alt="" data-original-src="//upload-images.jianshu.io/upload_images/3994601-441d69b45b6415db.png" data-original-width="589" data-original-height="522" data-original-format="image/png" data-original-filesize="66868"></div>







</div>
<div class="image-caption">dowait实现后半部分</div>







</div>
<blockquote>
<p>在整个dowait：</p>







</blockquote>
<ol>
<li>使用ReentrantLock保证每一次操作线程安全；</li>
<li>线程等待/唤醒使用Lock配合Condition来实现；</li>
<li>线程被唤醒的条件：等待超时或者所有线程都到达barrier。</li>







</ol></li>







</ul>
<p>到这里为止，CyclicBarrier的重要实现源码分析就结束了，接下来还是照样给出一个具体的使用案例，方便掌握CyclicBarrier的具体用法。</p>
<h3>CyclicBarrier使用案例</h3>
<p><strong>需求</strong>：多线程计算数据，merge计算结果。</p>
<p><strong>代码实现</strong>：</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill">&nbsp;</div>
<div class="image-view" data-width="716" data-height="799"><img src="//upload-images.jianshu.io/upload_images/3994601-53ffb55ef09d4b6a.png" alt="" data-original-src="//upload-images.jianshu.io/upload_images/3994601-53ffb55ef09d4b6a.png" data-original-width="716" data-original-height="799" data-original-format="image/png" data-original-filesize="149305"></div>







</div>
<div class="image-caption">使用案例</div>







</div>
<p>运行结果：</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill">&nbsp;</div>
<div class="image-view" data-width="806" data-height="154"><img src="//upload-images.jianshu.io/upload_images/3994601-3af42fb573ca3496.png" alt="" data-original-src="//upload-images.jianshu.io/upload_images/3994601-3af42fb573ca3496.png" data-original-width="806" data-original-height="154" data-original-format="image/png" data-original-filesize="36454"></div>







</div>
<div class="image-caption">运行结果</div>







</div>
<p>CyclicBarrier和CountDownLatch都可以实现线程等待，那么它俩之间的区别是什么呢？</p>
<h3>CyclicBarrier和CountDownLatch的区别</h3>
<p>看了各种资料和书，大家一致的意见都是CountDownLatch是计数器，只能使用一次，而CyclicBarrier的计数器提供reset功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从jdk作者设计的目的来看，javadoc是这么描述它们的：</p>
<blockquote>
<p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p>







</blockquote>
<blockquote>
<p>CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.</p>







</blockquote>
<p>从javadoc的描述可以得出：</p>
<ul>
<li>CountDownLatch：一个或者多个线程，<span style="color: #ff0000;">等待其他</span>多个线程完成某件事情之后才能执行；</li>
<li>CyclicBarrier：多个线程<span style="color: #ff0000;">互相等待</span>，直到到达同一个同步点，再继续一起执行。</li>







</ul>
<p>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p>
<p>CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>







</div>







<br><br><br>链接：https://www.jianshu.com/p/bce9f156080f</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory">分类: <a href="https://www.cnblogs.com/twoheads/category/1289066.html" target="_blank">java并发</a></div>
<div id="EntryTag"></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(9555867,cb_blogId,1);green_channel_success(this,'谢谢推荐！');">好文要顶</a>
            <a id="green_channel_follow" onclick="follow('a92c95e9-9361-4e3b-2ce0-08d54dbac325');" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="//common.cnblogs.com/images/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="//common.cnblogs.com/images/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/twoheads/" target="_blank"><img src="//pic.cnblogs.com/face/sample_face.gif" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/twoheads/">twoheads</a><br>
            <a href="https://home.cnblogs.com/u/twoheads/followees">关注 - 1</a><br>
            <a href="https://home.cnblogs.com/u/twoheads/followers">粉丝 - 5</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow('a92c95e9-9361-4e3b-2ce0-08d54dbac325');return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(9555867,'Digg')">
        <span class="diggnum" id="digg_count">0</span>
    </div>
    <div class="buryit" onclick="votePost(9555867,'Bury')">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
<script type="text/javascript">
    currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="https://www.cnblogs.com/twoheads/p/9554645.html" class="p_n_p_prefix">« </a> 上一篇：<a href="https://www.cnblogs.com/twoheads/p/9554645.html" title="发布于2018-08-29 15:31">【JUC】CountDownLatch</a><br><a href="https://www.cnblogs.com/twoheads/p/9564461.html" class="p_n_p_prefix">» </a> 下一篇：<a href="https://www.cnblogs.com/twoheads/p/9564461.html" title="发布于2018-08-31 10:44">【1】AQS详解</a><br></div>
</div>


		</div>
		<div class="postDesc">posted @ <span id="post-date">2018-08-29 17:41</span> <a href="https://www.cnblogs.com/twoheads/">twoheads</a> 阅读(<span id="post_view_count">487</span>) 评论(<span id="post_comment_count">0</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9555867" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9555867);return false;">收藏</a></div>
	</div>